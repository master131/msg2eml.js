function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _defineProperty2(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.msg2eml = f();
  }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }
          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }
        return n[i].exports;
      }
      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
        o(t[i]);
      }
      return o;
    }
    return r;
  }()({
    1: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          var __extends = void 0 && (void 0).__extends || function () {
            var _extendStatics = function extendStatics(d, b) {
              _extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, b) {
                d.__proto__ = b;
              } || function (d, b) {
                for (var p in b) {
                  if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                }
              };
              return _extendStatics(d, b);
            };
            return function (d, b) {
              if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              _extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function (resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          };
          var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
            var _ = {
                label: 0,
                sent: function sent() {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                },
                trys: [],
                ops: []
              },
              f,
              y,
              t,
              g;
            return g = {
              next: verb(0),
              "throw": verb(1),
              "return": verb(2)
            }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
              return this;
            }), g;
            function verb(n) {
              return function (v) {
                return step([n, v]);
              };
            }
            function step(op) {
              if (f) throw new TypeError("Generator is already executing.");
              while (g && (g = 0, op[0] && (_ = 0)), _) {
                try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                  if (y = 0, t) op = [op[0] & 2, t.value];
                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op;
                      break;
                    case 4:
                      _.label++;
                      return {
                        value: op[1],
                        done: false
                      };
                    case 5:
                      _.label++;
                      y = op[1];
                      op = [0];
                      continue;
                    case 7:
                      op = _.ops.pop();
                      _.trys.pop();
                      continue;
                    default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                      }
                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                      }
                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                      }
                      if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                      }
                      if (t[2]) _.ops.pop();
                      _.trys.pop();
                      continue;
                  }
                  op = body.call(thisArg, _);
                } catch (e) {
                  op = [6, e];
                  y = 0;
                } finally {
                  f = t = 0;
                }
              }
              if (op[0] & 5) throw op[1];
              return {
                value: op[0] ? op[1] : void 0,
                done: true
              };
            }
          };
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.msg2eml = void 0;
          var iconvLite = require("iconv-lite");
          var rtf_stream_parser_1 = require("rtf-stream-parser");
          var CFB = require('cfb');
          var eml_format = require('eml-format');
          var moment = require('moment');
          var decompressRTF = require('@kenjiuno/decompressrtf').decompressRTF;
          var bigInt = require("big-integer");
          var property_tags = new Array(0x3F08 + 1);
          property_tags[0x01] = ['ACKNOWLEDGEMENT_MODE', 'I4'];
          property_tags[0x02] = ['ALTERNATE_RECIPIENT_ALLOWED', 'BOOLEAN'];
          property_tags[0x03] = ['AUTHORIZING_USERS', 'BINARY'];
          // Comment on an automatically forwarded message
          property_tags[0x04] = ['AUTO_FORWARD_COMMENT', 'STRING'];
          // Whether a message has been automatically forwarded
          property_tags[0x05] = ['AUTO_FORWARDED', 'BOOLEAN'];
          property_tags[0x06] = ['CONTENT_CONFIDENTIALITY_ALGORITHM_ID', 'BINARY'];
          property_tags[0x07] = ['CONTENT_CORRELATOR', 'BINARY'];
          property_tags[0x08] = ['CONTENT_IDENTIFIER', 'STRING'];
          // MIME content length
          property_tags[0x09] = ['CONTENT_LENGTH', 'I4'];
          property_tags[0x0A] = ['CONTENT_RETURN_REQUESTED', 'BOOLEAN'];
          property_tags[0x0B] = ['CONVERSATION_KEY', 'BINARY'];
          property_tags[0x0C] = ['CONVERSION_EITS', 'BINARY'];
          property_tags[0x0D] = ['CONVERSION_WITH_LOSS_PROHIBITED', 'BOOLEAN'];
          property_tags[0x0E] = ['CONVERTED_EITS', 'BINARY'];
          // Time to deliver for delayed delivery messages
          property_tags[0x0F] = ['DEFERRED_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x10] = ['DELIVER_TIME', 'SYSTIME'];
          // Reason a message was discarded
          property_tags[0x11] = ['DISCARD_REASON', 'I4'];
          property_tags[0x12] = ['DISCLOSURE_OF_RECIPIENTS', 'BOOLEAN'];
          property_tags[0x13] = ['DL_EXPANSION_HISTORY', 'BINARY'];
          property_tags[0x14] = ['DL_EXPANSION_PROHIBITED', 'BOOLEAN'];
          property_tags[0x15] = ['EXPIRY_TIME', 'SYSTIME'];
          property_tags[0x16] = ['IMPLICIT_CONVERSION_PROHIBITED', 'BOOLEAN'];
          // Message importance
          property_tags[0x17] = ['IMPORTANCE', 'I4'];
          property_tags[0x18] = ['IPM_ID', 'BINARY'];
          property_tags[0x19] = ['LATEST_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x1A] = ['MESSAGE_CLASS', 'STRING'];
          property_tags[0x1B] = ['MESSAGE_DELIVERY_ID', 'BINARY'];
          property_tags[0x1E] = ['MESSAGE_SECURITY_LABEL', 'BINARY'];
          property_tags[0x1F] = ['OBSOLETED_IPMS', 'BINARY'];
          // Person a message was originally for
          property_tags[0x20] = ['ORIGINALLY_INTENDED_RECIPIENT_NAME', 'BINARY'];
          property_tags[0x21] = ['ORIGINAL_EITS', 'BINARY'];
          property_tags[0x22] = ['ORIGINATOR_CERTIFICATE', 'BINARY'];
          property_tags[0x23] = ['ORIGINATOR_DELIVERY_REPORT_REQUESTED', 'BOOLEAN'];
          // Address of the message sender
          property_tags[0x24] = ['ORIGINATOR_RETURN_ADDRESS', 'BINARY'];
          property_tags[0x25] = ['PARENT_KEY', 'BINARY'];
          property_tags[0x26] = ['PRIORITY', 'I4'];
          property_tags[0x27] = ['ORIGIN_CHECK', 'BINARY'];
          property_tags[0x28] = ['PROOF_OF_SUBMISSION_REQUESTED', 'BOOLEAN'];
          // Whether a read receipt is desired
          property_tags[0x29] = ['READ_RECEIPT_REQUESTED', 'BOOLEAN'];
          // Time a message was received
          property_tags[0x2A] = ['RECEIPT_TIME', 'SYSTIME'];
          property_tags[0x2B] = ['RECIPIENT_REASSIGNMENT_PROHIBITED', 'BOOLEAN'];
          property_tags[0x2C] = ['REDIRECTION_HISTORY', 'BINARY'];
          property_tags[0x2D] = ['RELATED_IPMS', 'BINARY'];
          // Sensitivity of the original message
          property_tags[0x2E] = ['ORIGINAL_SENSITIVITY', 'I4'];
          property_tags[0x2F] = ['LANGUAGES', 'STRING'];
          property_tags[0x30] = ['REPLY_TIME', 'SYSTIME'];
          property_tags[0x31] = ['REPORT_TAG', 'BINARY'];
          property_tags[0x32] = ['REPORT_TIME', 'SYSTIME'];
          property_tags[0x33] = ['RETURNED_IPM', 'BOOLEAN'];
          property_tags[0x34] = ['SECURITY', 'I4'];
          property_tags[0x35] = ['INCOMPLETE_COPY', 'BOOLEAN'];
          property_tags[0x36] = ['SENSITIVITY', 'I4'];
          // The message subject
          property_tags[0x37] = ['SUBJECT', 'STRING'];
          property_tags[0x38] = ['SUBJECT_IPM', 'BINARY'];
          property_tags[0x39] = ['CLIENT_SUBMIT_TIME', 'SYSTIME'];
          property_tags[0x3A] = ['REPORT_NAME', 'STRING'];
          property_tags[0x3B] = ['SENT_REPRESENTING_SEARCH_KEY', 'BINARY'];
          property_tags[0x3C] = ['X400_CONTENT_TYPE', 'BINARY'];
          property_tags[0x3D] = ['SUBJECT_PREFIX', 'STRING'];
          property_tags[0x3E] = ['NON_RECEIPT_REASON', 'I4'];
          property_tags[0x3F] = ['RECEIVED_BY_ENTRYID', 'BINARY'];
          // Received by: entry
          property_tags[0x40] = ['RECEIVED_BY_NAME', 'STRING'];
          property_tags[0x41] = ['SENT_REPRESENTING_ENTRYID', 'BINARY'];
          property_tags[0x42] = ['SENT_REPRESENTING_NAME', 'STRING'];
          property_tags[0x43] = ['RCVD_REPRESENTING_ENTRYID', 'BINARY'];
          property_tags[0x44] = ['RCVD_REPRESENTING_NAME', 'STRING'];
          property_tags[0x45] = ['REPORT_ENTRYID', 'BINARY'];
          property_tags[0x46] = ['READ_RECEIPT_ENTRYID', 'BINARY'];
          property_tags[0x47] = ['MESSAGE_SUBMISSION_ID', 'BINARY'];
          property_tags[0x48] = ['PROVIDER_SUBMIT_TIME', 'SYSTIME'];
          // Subject of the original message
          property_tags[0x49] = ['ORIGINAL_SUBJECT', 'STRING'];
          property_tags[0x4A] = ['DISC_VAL', 'BOOLEAN'];
          property_tags[0x4B] = ['ORIG_MESSAGE_CLASS', 'STRING'];
          property_tags[0x4C] = ['ORIGINAL_AUTHOR_ENTRYID', 'BINARY'];
          // Author of the original message
          property_tags[0x4D] = ['ORIGINAL_AUTHOR_NAME', 'STRING'];
          // Time the original message was submitted
          property_tags[0x4E] = ['ORIGINAL_SUBMIT_TIME', 'SYSTIME'];
          property_tags[0x4F] = ['REPLY_RECIPIENT_ENTRIES', 'BINARY'];
          property_tags[0x50] = ['REPLY_RECIPIENT_NAMES', 'STRING'];
          property_tags[0x51] = ['RECEIVED_BY_SEARCH_KEY', 'BINARY'];
          property_tags[0x52] = ['RCVD_REPRESENTING_SEARCH_KEY', 'BINARY'];
          property_tags[0x53] = ['READ_RECEIPT_SEARCH_KEY', 'BINARY'];
          property_tags[0x54] = ['REPORT_SEARCH_KEY', 'BINARY'];
          property_tags[0x55] = ['ORIGINAL_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x56] = ['ORIGINAL_AUTHOR_SEARCH_KEY', 'BINARY'];
          property_tags[0x57] = ['MESSAGE_TO_ME', 'BOOLEAN'];
          property_tags[0x58] = ['MESSAGE_CC_ME', 'BOOLEAN'];
          property_tags[0x59] = ['MESSAGE_RECIP_ME', 'BOOLEAN'];
          // Sender of the original message
          property_tags[0x5A] = ['ORIGINAL_SENDER_NAME', 'STRING'];
          property_tags[0x5B] = ['ORIGINAL_SENDER_ENTRYID', 'BINARY'];
          property_tags[0x5C] = ['ORIGINAL_SENDER_SEARCH_KEY', 'BINARY'];
          property_tags[0x5D] = ['ORIGINAL_SENT_REPRESENTING_NAME', 'STRING'];
          property_tags[0x5E] = ['ORIGINAL_SENT_REPRESENTING_ENTRYID', 'BINARY'];
          property_tags[0x5F] = ['ORIGINAL_SENT_REPRESENTING_SEARCH_KEY', 'BINARY'];
          property_tags[0x60] = ['START_DATE', 'SYSTIME'];
          property_tags[0x61] = ['END_DATE', 'SYSTIME'];
          property_tags[0x62] = ['OWNER_APPT_ID', 'I4'];
          // Whether a response to the message is desired
          property_tags[0x63] = ['RESPONSE_REQUESTED', 'BOOLEAN'];
          property_tags[0x64] = ['SENT_REPRESENTING_ADDRTYPE', 'STRING'];
          property_tags[0x65] = ['SENT_REPRESENTING_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x66] = ['ORIGINAL_SENDER_ADDRTYPE', 'STRING'];
          // Email of the original message sender
          property_tags[0x67] = ['ORIGINAL_SENDER_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x68] = ['ORIGINAL_SENT_REPRESENTING_ADDRTYPE', 'STRING'];
          property_tags[0x69] = ['ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x70] = ['CONVERSATION_TOPIC', 'STRING'];
          property_tags[0x71] = ['CONVERSATION_INDEX', 'BINARY'];
          property_tags[0x72] = ['ORIGINAL_DISPLAY_BCC', 'STRING'];
          property_tags[0x73] = ['ORIGINAL_DISPLAY_CC', 'STRING'];
          property_tags[0x74] = ['ORIGINAL_DISPLAY_TO', 'STRING'];
          property_tags[0x75] = ['RECEIVED_BY_ADDRTYPE', 'STRING'];
          property_tags[0x76] = ['RECEIVED_BY_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x77] = ['RCVD_REPRESENTING_ADDRTYPE', 'STRING'];
          property_tags[0x78] = ['RCVD_REPRESENTING_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x79] = ['ORIGINAL_AUTHOR_ADDRTYPE', 'STRING'];
          property_tags[0x7A] = ['ORIGINAL_AUTHOR_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x7B] = ['ORIGINALLY_INTENDED_RECIP_ADDRTYPE', 'STRING'];
          property_tags[0x7C] = ['ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x7D] = ['TRANSPORT_MESSAGE_HEADERS', 'STRING'];
          property_tags[0x7E] = ['DELEGATION', 'BINARY'];
          property_tags[0x7F] = ['TNEF_CORRELATION_KEY', 'BINARY'];
          property_tags[0x1000] = ['BODY', 'STRING'];
          property_tags[0x1001] = ['REPORT_TEXT', 'STRING'];
          property_tags[0x1002] = ['ORIGINATOR_AND_DL_EXPANSION_HISTORY', 'BINARY'];
          property_tags[0x1003] = ['REPORTING_DL_NAME', 'BINARY'];
          property_tags[0x1004] = ['REPORTING_MTA_CERTIFICATE', 'BINARY'];
          property_tags[0x1006] = ['RTF_SYNC_BODY_CRC', 'I4'];
          property_tags[0x1007] = ['RTF_SYNC_BODY_COUNT', 'I4'];
          property_tags[0x1008] = ['RTF_SYNC_BODY_TAG', 'STRING'];
          property_tags[0x1009] = ['RTF_COMPRESSED', 'BINARY'];
          property_tags[0x1010] = ['RTF_SYNC_PREFIX_COUNT', 'I4'];
          property_tags[0x1011] = ['RTF_SYNC_TRAILING_COUNT', 'I4'];
          property_tags[0x1012] = ['ORIGINALLY_INTENDED_RECIP_ENTRYID', 'BINARY'];
          property_tags[0x0C00] = ['CONTENT_INTEGRITY_CHECK', 'BINARY'];
          property_tags[0x0C01] = ['EXPLICIT_CONVERSION', 'I4'];
          property_tags[0x0C02] = ['IPM_RETURN_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C03] = ['MESSAGE_TOKEN', 'BINARY'];
          property_tags[0x0C04] = ['NDR_REASON_CODE', 'I4'];
          property_tags[0x0C05] = ['NDR_DIAG_CODE', 'I4'];
          property_tags[0x0C06] = ['NON_RECEIPT_NOTIFICATION_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C07] = ['DELIVERY_POINT', 'I4'];
          property_tags[0x0C08] = ['ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C09] = ['ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT', 'BINARY'];
          property_tags[0x0C0A] = ['PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY', 'BOOLEAN'];
          property_tags[0x0C0B] = ['PHYSICAL_DELIVERY_MODE', 'I4'];
          property_tags[0x0C0C] = ['PHYSICAL_DELIVERY_REPORT_REQUEST', 'I4'];
          property_tags[0x0C0D] = ['PHYSICAL_FORWARDING_ADDRESS', 'BINARY'];
          property_tags[0x0C0E] = ['PHYSICAL_FORWARDING_ADDRESS_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C0F] = ['PHYSICAL_FORWARDING_PROHIBITED', 'BOOLEAN'];
          property_tags[0x0C10] = ['PHYSICAL_RENDITION_ATTRIBUTES', 'BINARY'];
          property_tags[0x0C11] = ['PROOF_OF_DELIVERY', 'BINARY'];
          property_tags[0x0C12] = ['PROOF_OF_DELIVERY_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C13] = ['RECIPIENT_CERTIFICATE', 'BINARY'];
          property_tags[0x0C14] = ['RECIPIENT_NUMBER_FOR_ADVICE', 'STRING'];
          property_tags[0x0C15] = ['RECIPIENT_TYPE', 'I4'];
          property_tags[0x0C16] = ['REGISTERED_MAIL_TYPE', 'I4'];
          property_tags[0x0C17] = ['REPLY_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C18] = ['REQUESTED_DELIVERY_METHOD', 'I4'];
          property_tags[0x0C19] = ['SENDER_ENTRYID', 'BINARY'];
          property_tags[0x0C1A] = ['SENDER_NAME', 'STRING'];
          property_tags[0x0C1B] = ['SUPPLEMENTARY_INFO', 'STRING'];
          property_tags[0x0C1C] = ['TYPE_OF_MTS_USER', 'I4'];
          property_tags[0x0C1D] = ['SENDER_SEARCH_KEY', 'BINARY'];
          property_tags[0x0C1E] = ['SENDER_ADDRTYPE', 'STRING'];
          property_tags[0x0C1F] = ['SENDER_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x0E00] = ['CURRENT_VERSION', 'I8'];
          property_tags[0x0E01] = ['DELETE_AFTER_SUBMIT', 'BOOLEAN'];
          property_tags[0x0E02] = ['DISPLAY_BCC', 'STRING'];
          property_tags[0x0E03] = ['DISPLAY_CC', 'STRING'];
          property_tags[0x0E04] = ['DISPLAY_TO', 'STRING'];
          property_tags[0x0E05] = ['PARENT_DISPLAY', 'STRING'];
          property_tags[0x0E06] = ['MESSAGE_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x0E07] = ['MESSAGE_FLAGS', 'I4'];
          property_tags[0x0E08] = ['MESSAGE_SIZE', 'I4'];
          property_tags[0x0E09] = ['PARENT_ENTRYID', 'BINARY'];
          property_tags[0x0E0A] = ['SENTMAIL_ENTRYID', 'BINARY'];
          property_tags[0x0E0C] = ['CORRELATE', 'BOOLEAN'];
          property_tags[0x0E0D] = ['CORRELATE_MTSID', 'BINARY'];
          property_tags[0x0E0E] = ['DISCRETE_VALUES', 'BOOLEAN'];
          property_tags[0x0E0F] = ['RESPONSIBILITY', 'BOOLEAN'];
          property_tags[0x0E10] = ['SPOOLER_STATUS', 'I4'];
          property_tags[0x0E11] = ['TRANSPORT_STATUS', 'I4'];
          property_tags[0x0E12] = ['MESSAGE_RECIPIENTS', 'OBJECT'];
          property_tags[0x0E13] = ['MESSAGE_ATTACHMENTS', 'OBJECT'];
          property_tags[0x0E14] = ['SUBMIT_FLAGS', 'I4'];
          property_tags[0x0E15] = ['RECIPIENT_STATUS', 'I4'];
          property_tags[0x0E16] = ['TRANSPORT_KEY', 'I4'];
          property_tags[0x0E17] = ['MSG_STATUS', 'I4'];
          property_tags[0x0E18] = ['MESSAGE_DOWNLOAD_TIME', 'I4'];
          property_tags[0x0E19] = ['CREATION_VERSION', 'I8'];
          property_tags[0x0E1A] = ['MODIFY_VERSION', 'I8'];
          property_tags[0x0E1B] = ['HASATTACH', 'BOOLEAN'];
          property_tags[0x0E1D] = ['NORMALIZED_SUBJECT', 'STRING'];
          property_tags[0x0E1F] = ['RTF_IN_SYNC', 'BOOLEAN'];
          property_tags[0x0E20] = ['ATTACH_SIZE', 'I4'];
          property_tags[0x0E21] = ['ATTACH_NUM', 'I4'];
          property_tags[0x0E22] = ['PREPROCESS', 'BOOLEAN'];
          property_tags[0x0E25] = ['ORIGINATING_MTA_CERTIFICATE', 'BINARY'];
          property_tags[0x0E26] = ['PROOF_OF_SUBMISSION', 'BINARY'];
          // A unique identifier for editing the properties of a MAPI object
          property_tags[0x0FFF] = ['ENTRYID', 'BINARY'];
          // The type of an object
          property_tags[0x0FFE] = ['OBJECT_TYPE', 'I4'];
          property_tags[0x0FFD] = ['ICON', 'BINARY'];
          property_tags[0x0FFC] = ['MINI_ICON', 'BINARY'];
          property_tags[0x0FFB] = ['STORE_ENTRYID', 'BINARY'];
          property_tags[0x0FFA] = ['STORE_RECORD_KEY', 'BINARY'];
          // Binary identifer for an individual object
          property_tags[0x0FF9] = ['RECORD_KEY', 'BINARY'];
          property_tags[0x0FF8] = ['MAPPING_SIGNATURE', 'BINARY'];
          property_tags[0x0FF7] = ['ACCESS_LEVEL', 'I4'];
          // The primary key of a column in a table
          property_tags[0x0FF6] = ['INSTANCE_KEY', 'BINARY'];
          property_tags[0x0FF5] = ['ROW_TYPE', 'I4'];
          property_tags[0x0FF4] = ['ACCESS', 'I4'];
          property_tags[0x3000] = ['ROWID', 'I4'];
          // The name to display for a given MAPI object
          property_tags[0x3001] = ['DISPLAY_NAME', 'STRING'];
          property_tags[0x3002] = ['ADDRTYPE', 'STRING'];
          // An email address
          property_tags[0x3003] = ['EMAIL_ADDRESS', 'STRING'];
          // A comment field
          property_tags[0x3004] = ['COMMENT', 'STRING'];
          property_tags[0x3005] = ['DEPTH', 'I4'];
          // Provider-defined display name for a service provider
          property_tags[0x3006] = ['PROVIDER_DISPLAY', 'STRING'];
          // The time an object was created
          property_tags[0x3007] = ['CREATION_TIME', 'SYSTIME'];
          // The time an object was last modified
          property_tags[0x3008] = ['LAST_MODIFICATION_TIME', 'SYSTIME'];
          // Flags describing a service provider, message service, or status object
          property_tags[0x3009] = ['RESOURCE_FLAGS', 'I4'];
          // The name of a provider dll, minus any "32" suffix and ".dll"
          property_tags[0x300A] = ['PROVIDER_DLL_NAME', 'STRING'];
          property_tags[0x300B] = ['SEARCH_KEY', 'BINARY'];
          property_tags[0x300C] = ['PROVIDER_UID', 'BINARY'];
          property_tags[0x300D] = ['PROVIDER_ORDINAL', 'I4'];
          property_tags[0x3301] = ['FORM_VERSION', 'STRING'];
          property_tags[0x3302] = ['FORM_CLSID', 'CLSID'];
          property_tags[0x3303] = ['FORM_CONTACT_NAME', 'STRING'];
          property_tags[0x3304] = ['FORM_CATEGORY', 'STRING'];
          property_tags[0x3305] = ['FORM_CATEGORY_SUB', 'STRING'];
          property_tags[0x3306] = ['FORM_HOST_MAP', 'MV_LONG'];
          property_tags[0x3307] = ['FORM_HIDDEN', 'BOOLEAN'];
          property_tags[0x3308] = ['FORM_DESIGNER_NAME', 'STRING'];
          property_tags[0x3309] = ['FORM_DESIGNER_GUID', 'CLSID'];
          property_tags[0x330A] = ['FORM_MESSAGE_BEHAVIOR', 'I4'];
          // Is this row the default message store?
          property_tags[0x3400] = ['DEFAULT_STORE', 'BOOLEAN'];
          property_tags[0x340D] = ['STORE_SUPPORT_MASK', 'I4'];
          property_tags[0x340E] = ['STORE_STATE', 'I4'];
          property_tags[0x3410] = ['IPM_SUBTREE_SEARCH_KEY', 'BINARY'];
          property_tags[0x3411] = ['IPM_OUTBOX_SEARCH_KEY', 'BINARY'];
          property_tags[0x3412] = ['IPM_WASTEBASKET_SEARCH_KEY', 'BINARY'];
          property_tags[0x3413] = ['IPM_SENTMAIL_SEARCH_KEY', 'BINARY'];
          // Provder-defined message store type
          property_tags[0x3414] = ['MDB_PROVIDER', 'BINARY'];
          property_tags[0x3415] = ['RECEIVE_FOLDER_SETTINGS', 'OBJECT'];
          property_tags[0x35DF] = ['VALID_FOLDER_MASK', 'I4'];
          property_tags[0x35E0] = ['IPM_SUBTREE_ENTRYID', 'BINARY'];
          property_tags[0x35E2] = ['IPM_OUTBOX_ENTRYID', 'BINARY'];
          property_tags[0x35E3] = ['IPM_WASTEBASKET_ENTRYID', 'BINARY'];
          property_tags[0x35E4] = ['IPM_SENTMAIL_ENTRYID', 'BINARY'];
          property_tags[0x35E5] = ['VIEWS_ENTRYID', 'BINARY'];
          property_tags[0x35E6] = ['COMMON_VIEWS_ENTRYID', 'BINARY'];
          property_tags[0x35E7] = ['FINDER_ENTRYID', 'BINARY'];
          property_tags[0x3600] = ['CONTAINER_FLAGS', 'I4'];
          property_tags[0x3601] = ['FOLDER_TYPE', 'I4'];
          property_tags[0x3602] = ['CONTENT_COUNT', 'I4'];
          property_tags[0x3603] = ['CONTENT_UNREAD', 'I4'];
          property_tags[0x3604] = ['CREATE_TEMPLATES', 'OBJECT'];
          property_tags[0x3605] = ['DETAILS_TABLE', 'OBJECT'];
          property_tags[0x3607] = ['SEARCH', 'OBJECT'];
          property_tags[0x3609] = ['SELECTABLE', 'BOOLEAN'];
          property_tags[0x360A] = ['SUBFOLDERS', 'BOOLEAN'];
          property_tags[0x360B] = ['STATUS', 'I4'];
          property_tags[0x360C] = ['ANR', 'STRING'];
          property_tags[0x360D] = ['CONTENTS_SORT_ORDER', 'MV_LONG'];
          property_tags[0x360E] = ['CONTAINER_HIERARCHY', 'OBJECT'];
          property_tags[0x360F] = ['CONTAINER_CONTENTS', 'OBJECT'];
          property_tags[0x3610] = ['FOLDER_ASSOCIATED_CONTENTS', 'OBJECT'];
          property_tags[0x3611] = ['DEF_CREATE_DL', 'BINARY'];
          property_tags[0x3612] = ['DEF_CREATE_MAILUSER', 'BINARY'];
          property_tags[0x3613] = ['CONTAINER_CLASS', 'STRING'];
          property_tags[0x3614] = ['CONTAINER_MODIFY_VERSION', 'I8'];
          property_tags[0x3615] = ['AB_PROVIDER_ID', 'BINARY'];
          property_tags[0x3616] = ['DEFAULT_VIEW_ENTRYID', 'BINARY'];
          property_tags[0x3617] = ['ASSOC_CONTENT_COUNT', 'I4'];
          property_tags[0x3700] = ['ATTACHMENT_X400_PARAMETERS', 'BINARY'];
          property_tags[0x3701] = ['ATTACH_DATA_OBJ', 'OBJECT'];
          property_tags[0x3701] = ['ATTACH_DATA_BIN', 'BINARY'];
          property_tags[0x3702] = ['ATTACH_ENCODING', 'BINARY'];
          property_tags[0x3703] = ['ATTACH_EXTENSION', 'STRING'];
          property_tags[0x3704] = ['ATTACH_FILENAME', 'STRING'];
          property_tags[0x3705] = ['ATTACH_METHOD', 'I4'];
          property_tags[0x3707] = ['ATTACH_LONG_FILENAME', 'STRING'];
          property_tags[0x3708] = ['ATTACH_PATHNAME', 'STRING'];
          property_tags[0x370A] = ['ATTACH_TAG', 'BINARY'];
          property_tags[0x370B] = ['RENDERING_POSITION', 'I4'];
          property_tags[0x370C] = ['ATTACH_TRANSPORT_NAME', 'STRING'];
          property_tags[0x370D] = ['ATTACH_LONG_PATHNAME', 'STRING'];
          property_tags[0x370E] = ['ATTACH_MIME_TAG', 'STRING'];
          property_tags[0x370F] = ['ATTACH_ADDITIONAL_INFO', 'BINARY'];
          property_tags[0x3900] = ['DISPLAY_TYPE', 'I4'];
          property_tags[0x3902] = ['TEMPLATEID', 'BINARY'];
          property_tags[0x3904] = ['PRIMARY_CAPABILITY', 'BINARY'];
          property_tags[0x39FF] = ['7BIT_DISPLAY_NAME', 'STRING'];
          property_tags[0x3A00] = ['ACCOUNT', 'STRING'];
          property_tags[0x3A01] = ['ALTERNATE_RECIPIENT', 'BINARY'];
          property_tags[0x3A02] = ['CALLBACK_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A03] = ['CONVERSION_PROHIBITED', 'BOOLEAN'];
          property_tags[0x3A04] = ['DISCLOSE_RECIPIENTS', 'BOOLEAN'];
          property_tags[0x3A05] = ['GENERATION', 'STRING'];
          property_tags[0x3A06] = ['GIVEN_NAME', 'STRING'];
          property_tags[0x3A07] = ['GOVERNMENT_ID_NUMBER', 'STRING'];
          property_tags[0x3A08] = ['BUSINESS_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A09] = ['HOME_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A0A] = ['INITIALS', 'STRING'];
          property_tags[0x3A0B] = ['KEYWORD', 'STRING'];
          property_tags[0x3A0C] = ['LANGUAGE', 'STRING'];
          property_tags[0x3A0D] = ['LOCATION', 'STRING'];
          property_tags[0x3A0E] = ['MAIL_PERMISSION', 'BOOLEAN'];
          property_tags[0x3A0F] = ['MHS_COMMON_NAME', 'STRING'];
          property_tags[0x3A10] = ['ORGANIZATIONAL_ID_NUMBER', 'STRING'];
          property_tags[0x3A11] = ['SURNAME', 'STRING'];
          property_tags[0x3A12] = ['ORIGINAL_ENTRYID', 'BINARY'];
          property_tags[0x3A13] = ['ORIGINAL_DISPLAY_NAME', 'STRING'];
          property_tags[0x3A14] = ['ORIGINAL_SEARCH_KEY', 'BINARY'];
          property_tags[0x3A15] = ['POSTAL_ADDRESS', 'STRING'];
          property_tags[0x3A16] = ['COMPANY_NAME', 'STRING'];
          property_tags[0x3A17] = ['TITLE', 'STRING'];
          property_tags[0x3A18] = ['DEPARTMENT_NAME', 'STRING'];
          property_tags[0x3A19] = ['OFFICE_LOCATION', 'STRING'];
          property_tags[0x3A1A] = ['PRIMARY_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1B] = ['BUSINESS2_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1C] = ['MOBILE_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1D] = ['RADIO_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1E] = ['CAR_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1F] = ['OTHER_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A20] = ['TRANSMITABLE_DISPLAY_NAME', 'STRING'];
          property_tags[0x3A21] = ['PAGER_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A22] = ['USER_CERTIFICATE', 'BINARY'];
          property_tags[0x3A23] = ['PRIMARY_FAX_NUMBER', 'STRING'];
          property_tags[0x3A24] = ['BUSINESS_FAX_NUMBER', 'STRING'];
          property_tags[0x3A25] = ['HOME_FAX_NUMBER', 'STRING'];
          property_tags[0x3A26] = ['COUNTRY', 'STRING'];
          property_tags[0x3A27] = ['LOCALITY', 'STRING'];
          property_tags[0x3A28] = ['STATE_OR_PROVINCE', 'STRING'];
          property_tags[0x3A29] = ['STREET_ADDRESS', 'STRING'];
          property_tags[0x3A2A] = ['POSTAL_CODE', 'STRING'];
          property_tags[0x3A2B] = ['POST_OFFICE_BOX', 'STRING'];
          property_tags[0x3A2C] = ['TELEX_NUMBER', 'STRING'];
          property_tags[0x3A2D] = ['ISDN_NUMBER', 'STRING'];
          property_tags[0x3A2E] = ['ASSISTANT_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A2F] = ['HOME2_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A30] = ['ASSISTANT', 'STRING'];
          property_tags[0x3A40] = ['SEND_RICH_INFO', 'BOOLEAN'];
          property_tags[0x3A41] = ['WEDDING_ANNIVERSARY', 'SYSTIME'];
          property_tags[0x3A42] = ['BIRTHDAY', 'SYSTIME'];
          property_tags[0x3A43] = ['HOBBIES', 'STRING'];
          property_tags[0x3A44] = ['MIDDLE_NAME', 'STRING'];
          property_tags[0x3A45] = ['DISPLAY_NAME_PREFIX', 'STRING'];
          property_tags[0x3A46] = ['PROFESSION', 'STRING'];
          property_tags[0x3A47] = ['PREFERRED_BY_NAME', 'STRING'];
          property_tags[0x3A48] = ['SPOUSE_NAME', 'STRING'];
          property_tags[0x3A49] = ['COMPUTER_NETWORK_NAME', 'STRING'];
          property_tags[0x3A4A] = ['CUSTOMER_ID', 'STRING'];
          property_tags[0x3A4B] = ['TTYTDD_PHONE_NUMBER', 'STRING'];
          property_tags[0x3A4C] = ['FTP_SITE', 'STRING'];
          property_tags[0x3A4D] = ['GENDER', 'I2'];
          property_tags[0x3A4E] = ['MANAGER_NAME', 'STRING'];
          property_tags[0x3A4F] = ['NICKNAME', 'STRING'];
          property_tags[0x3A50] = ['PERSONAL_HOME_PAGE', 'STRING'];
          property_tags[0x3A51] = ['BUSINESS_HOME_PAGE', 'STRING'];
          property_tags[0x3A52] = ['CONTACT_VERSION', 'CLSID'];
          property_tags[0x3A53] = ['CONTACT_ENTRYIDS', 'MV_BINARY'];
          property_tags[0x3A54] = ['CONTACT_ADDRTYPES', 'MV_STRING'];
          property_tags[0x3A55] = ['CONTACT_DEFAULT_ADDRESS_INDEX', 'I4'];
          property_tags[0x3A56] = ['CONTACT_EMAIL_ADDRESSES', 'MV_STRING'];
          property_tags[0x3A57] = ['COMPANY_MAIN_PHONE_NUMBER', 'STRING'];
          property_tags[0x3A58] = ['CHILDRENS_NAMES', 'MV_STRING'];
          property_tags[0x3A59] = ['HOME_ADDRESS_CITY', 'STRING'];
          property_tags[0x3A5A] = ['HOME_ADDRESS_COUNTRY', 'STRING'];
          property_tags[0x3A5B] = ['HOME_ADDRESS_POSTAL_CODE', 'STRING'];
          property_tags[0x3A5C] = ['HOME_ADDRESS_STATE_OR_PROVINCE', 'STRING'];
          property_tags[0x3A5D] = ['HOME_ADDRESS_STREET', 'STRING'];
          property_tags[0x3A5E] = ['HOME_ADDRESS_POST_OFFICE_BOX', 'STRING'];
          property_tags[0x3A5F] = ['OTHER_ADDRESS_CITY', 'STRING'];
          property_tags[0x3A60] = ['OTHER_ADDRESS_COUNTRY', 'STRING'];
          property_tags[0x3A61] = ['OTHER_ADDRESS_POSTAL_CODE', 'STRING'];
          property_tags[0x3A62] = ['OTHER_ADDRESS_STATE_OR_PROVINCE', 'STRING'];
          property_tags[0x3A63] = ['OTHER_ADDRESS_STREET', 'STRING'];
          property_tags[0x3A64] = ['OTHER_ADDRESS_POST_OFFICE_BOX', 'STRING'];
          property_tags[0x3D00] = ['STORE_PROVIDERS', 'BINARY'];
          property_tags[0x3D01] = ['AB_PROVIDERS', 'BINARY'];
          property_tags[0x3D02] = ['TRANSPORT_PROVIDERS', 'BINARY'];
          property_tags[0x3D04] = ['DEFAULT_PROFILE', 'BOOLEAN'];
          property_tags[0x3D05] = ['AB_SEARCH_PATH', 'MV_BINARY'];
          property_tags[0x3D06] = ['AB_DEFAULT_DIR', 'BINARY'];
          property_tags[0x3D07] = ['AB_DEFAULT_PAB', 'BINARY'];
          property_tags[0x3D09] = ['SERVICE_NAME', 'STRING'];
          property_tags[0x3D0A] = ['SERVICE_DLL_NAME', 'STRING'];
          property_tags[0x3D0B] = ['SERVICE_ENTRY_NAME', 'STRING'];
          property_tags[0x3D0C] = ['SERVICE_UID', 'BINARY'];
          property_tags[0x3D0D] = ['SERVICE_EXTRA_UIDS', 'BINARY'];
          property_tags[0x3D0E] = ['SERVICES', 'BINARY'];
          property_tags[0x3D0F] = ['SERVICE_SUPPORT_FILES', 'MV_STRING'];
          property_tags[0x3D10] = ['SERVICE_DELETE_FILES', 'MV_STRING'];
          property_tags[0x3D11] = ['AB_SEARCH_PATH_UPDATE', 'BINARY'];
          property_tags[0x3D12] = ['PROFILE_NAME', 'STRING'];
          property_tags[0x3E00] = ['IDENTITY_DISPLAY', 'STRING'];
          property_tags[0x3E01] = ['IDENTITY_ENTRYID', 'BINARY'];
          property_tags[0x3E02] = ['RESOURCE_METHODS', 'I4'];
          // Service provider type
          property_tags[0x3E03] = ['RESOURCE_TYPE', 'I4'];
          property_tags[0x3E04] = ['STATUS_CODE', 'I4'];
          property_tags[0x3E05] = ['IDENTITY_SEARCH_KEY', 'BINARY'];
          property_tags[0x3E06] = ['OWN_STORE_ENTRYID', 'BINARY'];
          property_tags[0x3E07] = ['RESOURCE_PATH', 'STRING'];
          property_tags[0x3E08] = ['STATUS_STRING', 'STRING'];
          property_tags[0x3E09] = ['X400_DEFERRED_DELIVERY_CANCEL', 'BOOLEAN'];
          property_tags[0x3E0A] = ['HEADER_FOLDER_ENTRYID', 'BINARY'];
          property_tags[0x3E0B] = ['REMOTE_PROGRESS', 'I4'];
          property_tags[0x3E0C] = ['REMOTE_PROGRESS_TEXT', 'STRING'];
          property_tags[0x3E0D] = ['REMOTE_VALIDATE_OK', 'BOOLEAN'];
          property_tags[0x3F00] = ['CONTROL_FLAGS', 'I4'];
          property_tags[0x3F01] = ['CONTROL_STRUCTURE', 'BINARY'];
          property_tags[0x3F02] = ['CONTROL_TYPE', 'I4'];
          property_tags[0x3F03] = ['DELTAX', 'I4'];
          property_tags[0x3F04] = ['DELTAY', 'I4'];
          property_tags[0x3F05] = ['XPOS', 'I4'];
          property_tags[0x3F06] = ['YPOS', 'I4'];
          property_tags[0x3F07] = ['CONTROL_ID', 'BINARY'];
          property_tags[0x3F08] = ['INITIAL_DETAILS_PANE', 'I4'];
          var FixedLengthValueLoader = /** @class */function () {
            function FixedLengthValueLoader() {
              this.fixed_length = "";
            }
            return FixedLengthValueLoader;
          }();
          var VariableLengthValueLoader = /** @class */function () {
            function VariableLengthValueLoader() {
              this.variable_length = "";
            }
            return VariableLengthValueLoader;
          }();
          var NULL = /** @class */function (_super) {
            __extends(NULL, _super);
            function NULL() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            NULL.prototype.load = function (value) {
              // value is an eight-byte long bytestring with unused content.
              return null;
            };
            return NULL;
          }(FixedLengthValueLoader);
          var BOOLEAN = /** @class */function (_super) {
            __extends(BOOLEAN, _super);
            function BOOLEAN() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            BOOLEAN.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding a two-byte integer.
              return value[0] == 1;
            };
            return BOOLEAN;
          }(FixedLengthValueLoader);
          var INTEGER16 = /** @class */function (_super) {
            __extends(INTEGER16, _super);
            function INTEGER16() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTEGER16.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding a two-byte integer.
              return value.slice(0, 2).reverse().reduce(function (a, b) {
                return (a << 8) + b;
              });
            };
            return INTEGER16;
          }(FixedLengthValueLoader);
          var INTEGER32 = /** @class */function (_super) {
            __extends(INTEGER32, _super);
            function INTEGER32() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTEGER32.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding a four-byte integer.
              return value.slice(0, 4).reverse().reduce(function (a, b) {
                return (a << 8) + b;
              });
            };
            return INTEGER32;
          }(FixedLengthValueLoader);
          var INTEGER64 = /** @class */function (_super) {
            __extends(INTEGER64, _super);
            function INTEGER64() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTEGER64.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding an eight-byte integer.
              return value.slice().reverse().reduce(function (a, b) {
                return bigInt(a).shiftLeft(8).add(bigInt(b));
              });
            };
            return INTEGER64;
          }(FixedLengthValueLoader);
          var INTTIME = /** @class */function (_super) {
            __extends(INTTIME, _super);
            function INTTIME() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTTIME.prototype.load = function (value) {
              // value is an eight-byte long bytestring encoding the integer number of
              // 100-nanosecond intervals since January 1, 1601.
              //
              // Use bigint due to number type being too small to fit a 64-bit integer
              var delta = value.slice().reverse().reduce(function (a, b) {
                return bigInt(a).shiftLeft(8).add(bigInt(b));
              });
              return new Date(new Date('1601-01-01T00:00:00Z').getTime() + Number(delta.divide(10000)));
            };
            return INTTIME;
          }(FixedLengthValueLoader);
          var BINARY = /** @class */function (_super) {
            __extends(BINARY, _super);
            function BINARY() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            BINARY.prototype.load = function (value) {
              return value;
            };
            return BINARY;
          }(VariableLengthValueLoader);
          var STRING8 = /** @class */function (_super) {
            __extends(STRING8, _super);
            function STRING8() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            STRING8.prototype.load = function (value) {
              return new TextDecoder("utf-8").decode(new Uint8Array(value || []));
            };
            return STRING8;
          }(VariableLengthValueLoader);
          var UNICODE = /** @class */function (_super) {
            __extends(UNICODE, _super);
            function UNICODE() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            UNICODE.prototype.load = function (value) {
              return new TextDecoder("utf-16le").decode(new Uint8Array(value || []));
            };
            return UNICODE;
          }(VariableLengthValueLoader);
          var EMBEDDED_MESSAGE = /** @class */function () {
            function EMBEDDED_MESSAGE() {}
            EMBEDDED_MESSAGE.prototype.load = function (cfb, entry_name) {
              return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4 /*yield*/, load_message_stream(cfb, entry_name, false)];
                    case 1:
                      return [2 /*return*/, _a.sent()];
                  }
                });
              });
            };
            return EMBEDDED_MESSAGE;
          }();
          var property_types = new Array(0x102 + 1);
          property_types[0x1] = new NULL();
          property_types[0x2] = new INTEGER16();
          property_types[0x3] = new INTEGER32();
          property_types[0x4] = "FLOAT";
          property_types[0x5] = "DOUBLE";
          property_types[0x6] = "CURRENCY";
          property_types[0x7] = "APPTIME";
          property_types[0xa] = "ERROR";
          property_types[0xb] = new BOOLEAN();
          property_types[0xd] = new EMBEDDED_MESSAGE();
          property_types[0x14] = new INTEGER64();
          property_types[0x1e] = new STRING8();
          property_types[0x1f] = new UNICODE();
          property_types[0x40] = new INTTIME();
          property_types[0x48] = "CLSID";
          property_types[0xFB] = "SVREID";
          property_types[0xFD] = "SRESTRICT";
          property_types[0xFE] = "ACTIONS";
          property_types[0x102] = new BINARY();
          function parse_properties(cfb, entry_name, is_top_level) {
            return __awaiter(this, void 0, void 0, function () {
              var entry, i, ret, property_type, property_tag, flags, value, tag_name, tag_type, stream_name, stream_name;
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    entry = CFB.find(cfb, entry_name);
                    if (entry == null) {
                      return [2 /*return*/, {}];
                    }
                    i = is_top_level ? 32 : 24;
                    ret = {};
                    _a.label = 1;
                  case 1:
                    if (!(i < entry.size)) return [3 /*break*/, 6];
                    property_type = entry.content.slice(i + 0, i + 2);
                    property_tag = entry.content.slice(i + 2, i + 4);
                    flags = entry.content.slice(i + 4, i + 8);
                    value = entry.content.slice(i + 8, i + 16);
                    i += 16;
                    // Turn the byte strings into numbers and look up the property type
                    property_type = property_type[0] + (property_type[1] << 8);
                    property_tag = property_tag[0] + (property_tag[1] << 8);
                    if (property_tag > property_tags.length || !property_tags[property_tag]) return [3 /*break*/, 1];
                    tag_name = property_tags[property_tag][0];
                    tag_type = property_types[property_type];
                    if (!(tag_type instanceof FixedLengthValueLoader)) return [3 /*break*/, 2];
                    ret[tag_name] = tag_type.load(value);
                    return [3 /*break*/, 5];
                  case 2:
                    if (!(tag_type instanceof VariableLengthValueLoader)) return [3 /*break*/, 3];
                    stream_name = "__substg1.0_" + property_tag.toString(16).toUpperCase().padStart(4, '0') + property_type.toString(16).toUpperCase().padStart(4, '0');
                    stream_name = entry_name.substring(0, entry_name.lastIndexOf('/')) + '/' + stream_name;
                    value = CFB.find(cfb, stream_name);
                    if (!value) return [3 /*break*/, 1];
                    ret[tag_name] = tag_type.load(value.content);
                    return [3 /*break*/, 5];
                  case 3:
                    if (!(tag_type instanceof EMBEDDED_MESSAGE)) return [3 /*break*/, 5];
                    stream_name = "__substg1.0_" + property_tag.toString(16).toUpperCase().padStart(4, '0') + property_type.toString(16).toUpperCase().padStart(4, '0');
                    stream_name = entry_name.substring(0, entry_name.lastIndexOf('/')) + '/' + stream_name;
                    return [4 /*yield*/, tag_type.load(cfb, stream_name)];
                  case 4:
                    value = _a.sent();
                    ret[tag_name] = value;
                    _a.label = 5;
                  case 5:
                    return [3 /*break*/, 1];
                  case 6:
                    return [2 /*return*/, ret];
                }
              });
            });
          }
          function process_attachment(cfb, entry_name, msg) {
            return __awaiter(this, void 0, void 0, function () {
              var props, blob, filename, mime_type;
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    return [4 /*yield*/, parse_properties(cfb, entry_name + "/__properties_version1.0", false)];
                  case 1:
                    props = _a.sent();
                    blob = props["ATTACH_DATA_BIN"];
                    if (!blob) {
                      return [2 /*return*/];
                    }

                    filename = props["ATTACH_LONG_FILENAME"] || props["ATTACH_FILENAME"];
                    // Determine the correct filename for embedded e-mails
                    if (!filename) {
                      if ("ATTACH_MIME_TAG" in props && props["ATTACH_MIME_TAG"] == "message/rfc822") {
                        if ("DISPLAY_NAME" in props && props["DISPLAY_NAME"]) {
                          filename = props["DISPLAY_NAME"].replace(/[/\\?%*:|"<>]/g, '-') + ".eml";
                        } else {
                          cfb.unknown_attachment_count = cfb.unknown_attachment_count || 0;
                          cfb.unknown_attachment_count++;
                          filename = "unknown_" + cfb.unknown_attachment_count + ".eml";
                        }
                        props["ATTACH_MIME_TAG"] = "message/rfc822";
                      } else {
                        cfb.unknown_attachment_count = cfb.unknown_attachment_count || 0;
                        cfb.unknown_attachment_count++;
                        filename = "unknown_" + cfb.unknown_attachment_count + ".dat";
                      }
                    }
                    mime_type = props["ATTACH_MIME_TAG"] || "application/octet-stream";
                    filename = filename.split("/").slice(-1)[0].split("\\").slice(-1)[0];
                    msg.attachments.push({
                      name: filename,
                      contentType: mime_type,
                      data: Buffer.from(blob)
                    });
                    return [2 /*return*/];
                }
              });
            });
          }

          function resolvePlaceholderHeaders(eml, headers) {
            return headers ? eml.toString().replace("Headers-Original: Headers-Original", headers.replace(/[\r\n]+$/, "")).replace(/To: Headers-Original(\r\n|$)/, "") : eml;
          }
          function load_message_stream(cfb, entry_name, is_top_level) {
            return __awaiter(this, void 0, void 0, function () {
              var props, msg, headers_obj, original_headers, headers, header_lines, attachment_refs, rtf, html, r, m, i;
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    return [4 /*yield*/, parse_properties(cfb, entry_name + "/__properties_version1.0", is_top_level)];
                  case 1:
                    props = _a.sent();
                    msg = {};
                    headers_obj = {};
                    original_headers = null;
                    if ('TRANSPORT_MESSAGE_HEADERS' in props) {
                      headers = props['TRANSPORT_MESSAGE_HEADERS'];
                      header_lines = Array.from(headers.split("\r\n"));
                      // Ensure the transport headers are valid
                      if (header_lines.length && header_lines.filter(function (h) {
                        return h.length && h.indexOf(': ') >= 0;
                      }).length > 0) {
                        // Put a placeholder header which will be resolved later
                        headers_obj["Headers-Original"] = "Headers-Original";
                        // Put a dummy To header to satisfy EML formatter
                        if (/(^|[\r\n])To: /.test(headers)) {
                          headers_obj["To"] = "Headers-Original";
                        } else if ("DISPLAY_TO" in props && props["DISPLAY_TO"]) {
                          headers_obj["To"] = props["DISPLAY_TO"].replace(/\x00$/, "");
                        }
                        // Strip headers for attachments
                        original_headers = headers.replace(/(^|[\r\n])\s*boundary=--[\s\S]+/, "").replace(/(^|[\r\n])Content-Type: .+(\r\n|$)/, "");
                      }
                    }
                    if (Object.keys(headers_obj).length == 0) {
                      // Construct common headers from metadata.
                      if ("MESSAGE_DELIVERY_TIME" in props) {
                        headers_obj["Date"] = moment(props["MESSAGE_DELIVERY_TIME"]).format("ddd, DD MMM YYYY HH:mm:ss ZZ");
                      }
                      if ("SENDER_NAME" in props && props["SENDER_NAME"]) {
                        if ("SENT_REPRESENTING_NAME" in props && props["SENT_REPRESENTING_NAME"] && props["SENDER_NAME"] != props["SENT_REPRESENTING_NAME"]) {
                          props["SENDER_NAME"] = props["SENDER_NAME"] + " (" + props["SENT_REPRESENTING_NAME"] + ")";
                        }
                        headers_obj["From"] = props["SENDER_NAME"];
                      }
                      if ("SENDER_EMAIL_ADDRESS" in props && props["SENDER_EMAIL_ADDRESS"]) {
                        headers_obj["From"] = (headers_obj["From"] || "") + " <" + props["SENDER_EMAIL_ADDRESS"] + ">";
                      }
                      if ("DISPLAY_TO" in props && props["DISPLAY_TO"]) {
                        headers_obj["To"] = props["DISPLAY_TO"].replace(/\x00$/, "");
                      }
                      if ("DISPLAY_CC" in props && props["DISPLAY_CC"]) {
                        headers_obj["CC"] = props["DISPLAY_CC"];
                      }
                      if ("DISPLAY_BCC" in props && props["DISPLAY_BCC"]) {
                        headers_obj["BCC"] = props["DISPLAY_BCC"];
                      }
                      if ("SUBJECT" in props && props["SUBJECT"]) {
                        headers_obj["Subject"] = props["SUBJECT"];
                      }
                    }
                    attachment_refs = {};
                    if ("BODY" in props && !("RTF_COMPRESSED" in props)) {
                      msg["text"] = props["BODY"];
                    } else {
                      rtf = new Uint8Array(decompressRTF(props["RTF_COMPRESSED"]));
                      // Check if the RTF actually contains HTML tags, otherwise use plaintext
                      if (new TextDecoder("utf-8").decode(rtf).indexOf("\\*\\htmltag") >= 0) {
                        html = (0, rtf_stream_parser_1.deEncapsulateSync)(Buffer.from(rtf), {
                          decode: iconvLite.decode
                        }).text;
                        msg["html"] = html;
                        r = /src="cid:(([^@]+)@[A-Z0-9]+\.[A-Z0-9]+)"/g;
                        m = void 0;
                        while ((m = r.exec(html)) !== null) {
                          attachment_refs[m[2]] = m[1];
                        }
                      } else {
                        msg["text"] = props["BODY"];
                      }
                    }
                    msg["headers"] = headers_obj;
                    // Copy all attachments
                    msg.attachments = msg.attachments || [];
                    i = 0;
                    _a.label = 2;
                  case 2:
                    if (!(i < cfb.FullPaths.length)) return [3 /*break*/, 5];
                    if (!(cfb.FullPaths[i].indexOf("/__attach_version1.0_#") >= 0 && cfb.FullPaths[i].indexOf(entry_name.replace(/\/$/g, "")) == 0 && cfb.FullPaths[i].replace(/\/$/g, "") != entry_name.replace(/\/$/g, "") && cfb.FullPaths[i].replace(/\/$/g, "").split('/').length == entry_name.replace(/\/$/g, "").split('/').length + 1)) return [3 /*break*/, 4];
                    return [4 /*yield*/, process_attachment(cfb, cfb.FullPaths[i].replace(/\/$/g, ""), msg)];
                  case 3:
                    _a.sent();
                    _a.label = 4;
                  case 4:
                    i++;
                    return [3 /*break*/, 2];
                  case 5:
                    // Fix inline-attachment references
                    msg.attachments.forEach(function (a) {
                      if (a.name in attachment_refs) {
                        a.cid = attachment_refs[a.name];
                      }
                    });
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                      eml_format.build(msg, function (error, eml) {
                        if (error) {
                          reject(error);
                        } else {
                          resolve(resolvePlaceholderHeaders(eml, original_headers));
                        }
                      });
                    })];
                }
              });
            });
          }
          moment.locale("en");
          function msg2eml(obj) {
            return __awaiter(this, void 0, void 0, function () {
              var arrBuffer, _a, result;
              return __generator(this, function (_b) {
                switch (_b.label) {
                  case 0:
                    if (!(obj.constructor && obj.constructor.name === 'Blob')) return [3 /*break*/, 2];
                    _a = Uint8Array.bind;
                    return [4 /*yield*/, obj.arrayBuffer()];
                  case 1:
                    arrBuffer = new (_a.apply(Uint8Array, [void 0, _b.sent()]))();
                    return [3 /*break*/, 3];
                  case 2:
                    if (obj.constructor && obj.constructor.name == 'Array' || obj.constructor && obj.constructor.name == 'ArrayBuffer') {
                      arrBuffer = new Uint8Array(obj);
                    } else {
                      throw 'Unknown or unsupported source type: ' + (obj.constructor ? obj.constructor.name : obj);
                    }
                    _b.label = 3;
                  case 3:
                    result = CFB.parse(arrBuffer);
                    return [4 /*yield*/, load_message_stream(result, "Root Entry", true)];
                  case 4:
                    return [2 /*return*/, _b.sent()];
                }
              });
            });
          }
          exports.msg2eml = msg2eml;
          ;
          if (typeof window !== 'undefined' && window) {
            window.msg2eml = msg2eml;
          }
          if (typeof module !== 'undefined' && module && module.exports) {
            module.exports = msg2eml;
          }
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "@kenjiuno/decompressrtf": 2,
      "big-integer": 4,
      "buffer": 7,
      "cfb": 8,
      "eml-format": 9,
      "iconv-lite": 31,
      "moment": 34,
      "rtf-stream-parser": 50
    }],
    2: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decompressRTF = void 0;
      var Stream = /** @class */function () {
        function Stream(buf) {
          this.buf = buf;
        }
        Stream.prototype.readInt32LE = function (offset) {
          var value = this.buf[offset] & 255 | (this.buf[offset + 1] & 255) << 8 | (this.buf[offset + 2] & 255) << 16 | (this.buf[offset + 3] & 255) << 24;
          return value;
        };
        Stream.prototype.readUInt16BE = function (offset) {
          var value = (this.buf[offset] & 255) << 8 | this.buf[offset + 1] & 255;
          return value;
        };
        Stream.prototype.readUInt8 = function (offset) {
          var value = this.buf[offset] & 255;
          return value;
        };
        Stream.prototype.writeUInt8 = function (value, offset) {
          this.buf[offset] = value & 255;
        };
        return Stream;
      }();
      /**
       * Decompress PR_RTF_COMPRESSED (PidTagRtfCompressed) data
       *
       * Check these:
       *
       * - The Compressed RTF Format
       *   https://www.freeutils.net/source/jtnef/rtfcompressed
       *
       * - 2.1.3.1 RTF Compression Format
       *   https://msdn.microsoft.com/en-us/library/ee159164(v=exchg.80).aspx
       *
       */
      function decompressRTF(inputArray) {
        if (inputArray.length < 16) {
          throw new Error("At least 16 bytes");
        }
        var input = new Stream(inputArray);
        var fileSize = input.readInt32LE(0);
        var rawSize = input.readInt32LE(4);
        var compType = input.readInt32LE(8);
        var crc = input.readInt32LE(12);
        var COMPRESSED = 0x75465A4C;
        var UNCOMPRESSED = 0x414C454D;
        if (compType == COMPRESSED) {
          var initialDictionary = "{\\rtf1\\ansi\\mac\\deff0\\deftab720{\\fonttbl;}{\\f0\\fnil \\froman \\fswi" + "ss \\fmodern \\fscript \\fdecor MS Sans SerifSymbolArialTimes New Ro" + "manCourier{\\colortbl\\red0\\green0\\blue0\r\n\\par \\pard\\plain\\f0\\fs20\\" + "b\\i\\u\\tab\\tx";
          //if (initialDictionary.length != 207) throw new Error("Fix initialDictionary!");
          var outputArray = []; // automatically expanded
          var output = new Stream(outputArray);
          var outPos = 0;
          var inPos = 16;
          var control = void 0;
          for (var x = 0; x < initialDictionary.length; x += 1) {
            output.writeUInt8(initialDictionary.charCodeAt(x), outPos);
            outPos += 1;
          }
          var inEnd = fileSize + 4;
          for (var run_1 = 0; inPos < inEnd; run_1 = run_1 + 1 & 7) {
            if (0 == run_1) {
              control = input.readUInt8(inPos);
              inPos += 1;
            }
            if (0 != (1 << run_1 & control)) {
              // dictionary
              var token = input.readUInt16BE(inPos);
              inPos += 2;
              var offset = token >> 4;
              var length_1 = (token & 15) + 2;
              var readPos = (outPos & ~4095) + offset;
              if (readPos == outPos) {
                break;
              }
              if (readPos > outPos) {
                readPos -= 4096;
              }
              for (var x = 0; x < length_1; x += 1) {
                var octet = output.readUInt8(readPos);
                output.writeUInt8(octet, outPos);
                readPos += 1;
                outPos += 1;
              }
            } else {
              // literal
              var octet = input.readUInt8(inPos);
              output.writeUInt8(octet, outPos);
              inPos += 1;
              outPos += 1;
            }
          }
          return outputArray.slice(initialDictionary.length);
        } else if (compType == UNCOMPRESSED) {
          return inputArray.slice(16, 16 + rawSize);
        } else {
          throw new Error("Either COMPRESSED or UNCOMPRESSED");
        }
      }
      exports.decompressRTF = decompressRTF;
    }, {}],
    3: [function (require, module, exports) {
      'use strict';

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications
      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
      function getLens(b64) {
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }

        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }

      // base64 is 4/3 + up to two characters of the original data
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;

        // if there are placeholders, only get up to the last complete 4 chars
        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i;
        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }
        return output.join('');
      }
      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
        }
        return parts.join('');
      }
    }, {}],
    4: [function (require, module, exports) {
      var bigInt = function (undefined) {
        "use strict";

        var BASE = 1e7,
          LOG_BASE = 7,
          MAX_INT = 9007199254740992,
          MAX_INT_ARR = smallToArray(MAX_INT),
          DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        var supportsNativeBigInt = typeof BigInt === "function";
        function Integer(v, radix, alphabet, caseSensitive) {
          if (typeof v === "undefined") return Integer[0];
          if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
          return parseValue(v);
        }
        function BigInteger(value, sign) {
          this.value = value;
          this.sign = sign;
          this.isSmall = false;
        }
        BigInteger.prototype = Object.create(Integer.prototype);
        function SmallInteger(value) {
          this.value = value;
          this.sign = value < 0;
          this.isSmall = true;
        }
        SmallInteger.prototype = Object.create(Integer.prototype);
        function NativeBigInt(value) {
          this.value = value;
        }
        NativeBigInt.prototype = Object.create(Integer.prototype);
        function isPrecise(n) {
          return -MAX_INT < n && n < MAX_INT;
        }
        function smallToArray(n) {
          // For performance reasons doesn't reference BASE, need to change this function if BASE changes
          if (n < 1e7) return [n];
          if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
          return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
        }
        function arrayToSmall(arr) {
          // If BASE changes this function may need to change
          trim(arr);
          var length = arr.length;
          if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
              case 0:
                return 0;
              case 1:
                return arr[0];
              case 2:
                return arr[0] + arr[1] * BASE;
              default:
                return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
          }
          return arr;
        }
        function trim(v) {
          var i = v.length;
          while (v[--i] === 0) {
            ;
          }
          v.length = i + 1;
        }
        function createArray(length) {
          // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
          var x = new Array(length);
          var i = -1;
          while (++i < length) {
            x[i] = 0;
          }
          return x;
        }
        function truncate(n) {
          if (n > 0) return Math.floor(n);
          return Math.ceil(n);
        }
        function add(a, b) {
          // assumes a and b are arrays with a.length >= b.length
          var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum,
            i;
          for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
          }
          while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
          }
          if (carry > 0) r.push(carry);
          return r;
        }
        function addAny(a, b) {
          if (a.length >= b.length) return add(a, b);
          return add(b, a);
        }
        function addSmall(a, carry) {
          // assumes a is array, carry is number with 0 <= carry < MAX_INT
          var l = a.length,
            r = new Array(l),
            base = BASE,
            sum,
            i;
          for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
          }
          while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r;
        }
        BigInteger.prototype.add = function (v) {
          var n = parseValue(v);
          if (this.sign !== n.sign) {
            return this.subtract(n.negate());
          }
          var a = this.value,
            b = n.value;
          if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
          }
          return new BigInteger(addAny(a, b), this.sign);
        };
        BigInteger.prototype.plus = BigInteger.prototype.add;
        SmallInteger.prototype.add = function (v) {
          var n = parseValue(v);
          var a = this.value;
          if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
          }
          var b = n.value;
          if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
          }
          return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
        };
        SmallInteger.prototype.plus = SmallInteger.prototype.add;
        NativeBigInt.prototype.add = function (v) {
          return new NativeBigInt(this.value + parseValue(v).value);
        };
        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
        function subtract(a, b) {
          // assumes a and b are arrays with a >= b
          var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i,
            difference;
          for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
              difference += base;
              borrow = 1;
            } else borrow = 0;
            r[i] = difference;
          }
          for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;else {
              r[i++] = difference;
              break;
            }
            r[i] = difference;
          }
          for (; i < a_l; i++) {
            r[i] = a[i];
          }
          trim(r);
          return r;
        }
        function subtractAny(a, b, sign) {
          var value;
          if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
          } else {
            value = subtract(b, a);
            sign = !sign;
          }
          value = arrayToSmall(value);
          if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
          }
          return new BigInteger(value, sign);
        }
        function subtractSmall(a, b, sign) {
          // assumes a is array, b is number with 0 <= b < MAX_INT
          var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i,
            difference;
          for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
          }
          r = arrayToSmall(r);
          if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
          }
          return new BigInteger(r, sign);
        }
        BigInteger.prototype.subtract = function (v) {
          var n = parseValue(v);
          if (this.sign !== n.sign) {
            return this.add(n.negate());
          }
          var a = this.value,
            b = n.value;
          if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
          return subtractAny(a, b, this.sign);
        };
        BigInteger.prototype.minus = BigInteger.prototype.subtract;
        SmallInteger.prototype.subtract = function (v) {
          var n = parseValue(v);
          var a = this.value;
          if (a < 0 !== n.sign) {
            return this.add(n.negate());
          }
          var b = n.value;
          if (n.isSmall) {
            return new SmallInteger(a - b);
          }
          return subtractSmall(b, Math.abs(a), a >= 0);
        };
        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
        NativeBigInt.prototype.subtract = function (v) {
          return new NativeBigInt(this.value - parseValue(v).value);
        };
        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
        BigInteger.prototype.negate = function () {
          return new BigInteger(this.value, !this.sign);
        };
        SmallInteger.prototype.negate = function () {
          var sign = this.sign;
          var small = new SmallInteger(-this.value);
          small.sign = !sign;
          return small;
        };
        NativeBigInt.prototype.negate = function () {
          return new NativeBigInt(-this.value);
        };
        BigInteger.prototype.abs = function () {
          return new BigInteger(this.value, false);
        };
        SmallInteger.prototype.abs = function () {
          return new SmallInteger(Math.abs(this.value));
        };
        NativeBigInt.prototype.abs = function () {
          return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
        };
        function multiplyLong(a, b) {
          var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product,
            carry,
            i,
            a_i,
            b_j;
          for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
              b_j = b[j];
              product = a_i * b_j + r[i + j];
              carry = Math.floor(product / base);
              r[i + j] = product - carry * base;
              r[i + j + 1] += carry;
            }
          }
          trim(r);
          return r;
        }
        function multiplySmall(a, b) {
          // assumes a is array, b is number with |b| < BASE
          var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product,
            i;
          for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
          }
          while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r;
        }
        function shiftLeft(x, n) {
          var r = [];
          while (n-- > 0) {
            r.push(0);
          }
          return r.concat(x);
        }
        function multiplyKaratsuba(x, y) {
          var n = Math.max(x.length, y.length);
          if (n <= 30) return multiplyLong(x, y);
          n = Math.ceil(n / 2);
          var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);
          var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
          var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
          trim(product);
          return product;
        }

        // The following function is derived from a surface fit of a graph plotting the performance difference
        // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
        function useKaratsuba(l1, l2) {
          return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
        }
        BigInteger.prototype.multiply = function (v) {
          var n = parseValue(v),
            a = this.value,
            b = n.value,
            sign = this.sign !== n.sign,
            abs;
          if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
              return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
          }
          if (useKaratsuba(a.length, b.length))
            // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
          return new BigInteger(multiplyLong(a, b), sign);
        };
        BigInteger.prototype.times = BigInteger.prototype.multiply;
        function multiplySmallAndArray(a, b, sign) {
          // a >= 0
          if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
          }
          return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
        }
        SmallInteger.prototype._multiplyBySmall = function (a) {
          if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
          }
          return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
        };
        BigInteger.prototype._multiplyBySmall = function (a) {
          if (a.value === 0) return Integer[0];
          if (a.value === 1) return this;
          if (a.value === -1) return this.negate();
          return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
        };
        SmallInteger.prototype.multiply = function (v) {
          return parseValue(v)._multiplyBySmall(this);
        };
        SmallInteger.prototype.times = SmallInteger.prototype.multiply;
        NativeBigInt.prototype.multiply = function (v) {
          return new NativeBigInt(this.value * parseValue(v).value);
        };
        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
        function square(a) {
          //console.assert(2 * BASE * BASE < MAX_INT);
          var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product,
            carry,
            i,
            a_i,
            a_j;
          for (i = 0; i < l; i++) {
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for (var j = i; j < l; j++) {
              a_j = a[j];
              product = 2 * (a_i * a_j) + r[i + j] + carry;
              carry = Math.floor(product / base);
              r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
          }
          trim(r);
          return r;
        }
        BigInteger.prototype.square = function () {
          return new BigInteger(square(this.value), false);
        };
        SmallInteger.prototype.square = function () {
          var value = this.value * this.value;
          if (isPrecise(value)) return new SmallInteger(value);
          return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
        };
        NativeBigInt.prototype.square = function (v) {
          return new NativeBigInt(this.value * this.value);
        };
        function divMod1(a, b) {
          // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
          var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit,
            shift,
            carry,
            borrow,
            i,
            l,
            q;
          if (remainder.length <= a_l) remainder.push(0);
          divisor.push(0);
          divisorMostSignificantDigit = divisor[b_l - 1];
          for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
              carry += quotientDigit * divisor[i];
              q = Math.floor(carry / base);
              borrow += remainder[shift + i] - (carry - q * base);
              carry = q;
              if (borrow < 0) {
                remainder[shift + i] = borrow + base;
                borrow = -1;
              } else {
                remainder[shift + i] = borrow;
                borrow = 0;
              }
            }
            while (borrow !== 0) {
              quotientDigit -= 1;
              carry = 0;
              for (i = 0; i < l; i++) {
                carry += remainder[shift + i] - base + divisor[i];
                if (carry < 0) {
                  remainder[shift + i] = carry + base;
                  carry = 0;
                } else {
                  remainder[shift + i] = carry;
                  carry = 1;
                }
              }
              borrow += carry;
            }
            result[shift] = quotientDigit;
          }
          // denormalization
          remainder = divModSmall(remainder, lambda)[0];
          return [arrayToSmall(result), arrayToSmall(remainder)];
        }
        function divMod2(a, b) {
          // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
          // Performs faster than divMod1 on larger input sizes.
          var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess,
            xlen,
            highx,
            highy,
            check;
          while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
              result.push(0);
              continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
              highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
              check = multiplySmall(b, guess);
              if (compareAbs(check, part) <= 0) break;
              guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
          }
          result.reverse();
          return [arrayToSmall(result), arrayToSmall(part)];
        }
        function divModSmall(value, lambda) {
          var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i,
            q,
            remainder,
            divisor;
          remainder = 0;
          for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
          }
          return [quotient, remainder | 0];
        }
        function divModAny(self, v) {
          var value,
            n = parseValue(v);
          if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
          }
          var a = self.value,
            b = n.value;
          var quotient;
          if (b === 0) throw new Error("Cannot divide by zero");
          if (self.isSmall) {
            if (n.isSmall) {
              return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
          }
          if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
              value = divModSmall(a, abs);
              quotient = arrayToSmall(value[0]);
              var remainder = value[1];
              if (self.sign) remainder = -remainder;
              if (typeof quotient === "number") {
                if (self.sign !== n.sign) quotient = -quotient;
                return [new SmallInteger(quotient), new SmallInteger(remainder)];
              }
              return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
          }
          var comparison = compareAbs(a, b);
          if (comparison === -1) return [Integer[0], self];
          if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

          // divMod1 is faster on smaller input sizes
          if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
          quotient = value[0];
          var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
          if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
          } else quotient = new BigInteger(quotient, qSign);
          if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
          } else mod = new BigInteger(mod, mSign);
          return [quotient, mod];
        }
        BigInteger.prototype.divmod = function (v) {
          var result = divModAny(this, v);
          return {
            quotient: result[0],
            remainder: result[1]
          };
        };
        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
        BigInteger.prototype.divide = function (v) {
          return divModAny(this, v)[0];
        };
        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
          return new NativeBigInt(this.value / parseValue(v).value);
        };
        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
        BigInteger.prototype.mod = function (v) {
          return divModAny(this, v)[1];
        };
        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
          return new NativeBigInt(this.value % parseValue(v).value);
        };
        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
        BigInteger.prototype.pow = function (v) {
          var n = parseValue(v),
            a = this.value,
            b = n.value,
            value,
            x,
            y;
          if (b === 0) return Integer[1];
          if (a === 0) return Integer[0];
          if (a === 1) return Integer[1];
          if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
          if (n.sign) {
            return Integer[0];
          }
          if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
          if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
          }
          x = this;
          y = Integer[1];
          while (true) {
            if (b & 1 === 1) {
              y = y.times(x);
              --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
          }
          return y;
        };
        SmallInteger.prototype.pow = BigInteger.prototype.pow;
        NativeBigInt.prototype.pow = function (v) {
          var n = parseValue(v);
          var a = this.value,
            b = n.value;
          var _0 = BigInt(0),
            _1 = BigInt(1),
            _2 = BigInt(2);
          if (b === _0) return Integer[1];
          if (a === _0) return Integer[0];
          if (a === _1) return Integer[1];
          if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
          if (n.isNegative()) return new NativeBigInt(_0);
          var x = this;
          var y = Integer[1];
          while (true) {
            if ((b & _1) === _1) {
              y = y.times(x);
              --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
          }
          return y;
        };
        BigInteger.prototype.modPow = function (exp, mod) {
          exp = parseValue(exp);
          mod = parseValue(mod);
          if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
          var r = Integer[1],
            base = this.mod(mod);
          if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
          }
          while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
          }
          return r;
        };
        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
        function compareAbs(a, b) {
          if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
          }
          for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
          }
          return 0;
        }
        BigInteger.prototype.compareAbs = function (v) {
          var n = parseValue(v),
            a = this.value,
            b = n.value;
          if (n.isSmall) return 1;
          return compareAbs(a, b);
        };
        SmallInteger.prototype.compareAbs = function (v) {
          var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
          if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
          }
          return -1;
        };
        NativeBigInt.prototype.compareAbs = function (v) {
          var a = this.value;
          var b = parseValue(v).value;
          a = a >= 0 ? a : -a;
          b = b >= 0 ? b : -b;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        BigInteger.prototype.compare = function (v) {
          // See discussion about comparison with Infinity:
          // https://github.com/peterolson/BigInteger.js/issues/61
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var n = parseValue(v),
            a = this.value,
            b = n.value;
          if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
          }
          if (n.isSmall) {
            return this.sign ? -1 : 1;
          }
          return compareAbs(a, b) * (this.sign ? -1 : 1);
        };
        BigInteger.prototype.compareTo = BigInteger.prototype.compare;
        SmallInteger.prototype.compare = function (v) {
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var n = parseValue(v),
            a = this.value,
            b = n.value;
          if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
          }
          if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
          }
          return a < 0 ? 1 : -1;
        };
        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
        NativeBigInt.prototype.compare = function (v) {
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var a = this.value;
          var b = parseValue(v).value;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
        BigInteger.prototype.equals = function (v) {
          return this.compare(v) === 0;
        };
        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
        BigInteger.prototype.notEquals = function (v) {
          return this.compare(v) !== 0;
        };
        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
        BigInteger.prototype.greater = function (v) {
          return this.compare(v) > 0;
        };
        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
        BigInteger.prototype.lesser = function (v) {
          return this.compare(v) < 0;
        };
        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
        BigInteger.prototype.greaterOrEquals = function (v) {
          return this.compare(v) >= 0;
        };
        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
        BigInteger.prototype.lesserOrEquals = function (v) {
          return this.compare(v) <= 0;
        };
        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
        BigInteger.prototype.isEven = function () {
          return (this.value[0] & 1) === 0;
        };
        SmallInteger.prototype.isEven = function () {
          return (this.value & 1) === 0;
        };
        NativeBigInt.prototype.isEven = function () {
          return (this.value & BigInt(1)) === BigInt(0);
        };
        BigInteger.prototype.isOdd = function () {
          return (this.value[0] & 1) === 1;
        };
        SmallInteger.prototype.isOdd = function () {
          return (this.value & 1) === 1;
        };
        NativeBigInt.prototype.isOdd = function () {
          return (this.value & BigInt(1)) === BigInt(1);
        };
        BigInteger.prototype.isPositive = function () {
          return !this.sign;
        };
        SmallInteger.prototype.isPositive = function () {
          return this.value > 0;
        };
        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
        BigInteger.prototype.isNegative = function () {
          return this.sign;
        };
        SmallInteger.prototype.isNegative = function () {
          return this.value < 0;
        };
        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
        BigInteger.prototype.isUnit = function () {
          return false;
        };
        SmallInteger.prototype.isUnit = function () {
          return Math.abs(this.value) === 1;
        };
        NativeBigInt.prototype.isUnit = function () {
          return this.abs().value === BigInt(1);
        };
        BigInteger.prototype.isZero = function () {
          return false;
        };
        SmallInteger.prototype.isZero = function () {
          return this.value === 0;
        };
        NativeBigInt.prototype.isZero = function () {
          return this.value === BigInt(0);
        };
        BigInteger.prototype.isDivisibleBy = function (v) {
          var n = parseValue(v);
          if (n.isZero()) return false;
          if (n.isUnit()) return true;
          if (n.compareAbs(2) === 0) return this.isEven();
          return this.mod(n).isZero();
        };
        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
        function isBasicPrime(v) {
          var n = v.abs();
          if (n.isUnit()) return false;
          if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
          if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
          if (n.lesser(49)) return true;
          // we don't know if it's prime: let the other functions figure it out
        }

        function millerRabinTest(n, a) {
          var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d,
            t,
            i,
            x;
          while (b.isEven()) {
            b = b.divide(2), r++;
          }
          next: for (i = 0; i < a.length; i++) {
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
              x = x.square().mod(n);
              if (x.isUnit()) return false;
              if (x.equals(nPrev)) continue next;
            }
            return false;
          }
          return true;
        }

        // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
        BigInteger.prototype.isPrime = function (strict) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined) return isPrime;
          var n = this.abs();
          var bits = n.bitLength();
          if (bits <= 64) return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
          var logN = Math.log(2) * bits.toJSNumber();
          var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
          for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt(i + 2));
          }
          return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
        BigInteger.prototype.isProbablePrime = function (iterations, rng) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined) return isPrime;
          var n = this.abs();
          var t = iterations === undefined ? 5 : iterations;
          for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt.randBetween(2, n.minus(2), rng));
          }
          return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
        BigInteger.prototype.modInv = function (n) {
          var t = bigInt.zero,
            newT = bigInt.one,
            r = parseValue(n),
            newR = this.abs(),
            q,
            lastT,
            lastR;
          while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
          }
          if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
          if (t.compare(0) === -1) {
            t = t.add(n);
          }
          if (this.isNegative()) {
            return t.negate();
          }
          return t;
        };
        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
        BigInteger.prototype.next = function () {
          var value = this.value;
          if (this.sign) {
            return subtractSmall(value, 1, this.sign);
          }
          return new BigInteger(addSmall(value, 1), this.sign);
        };
        SmallInteger.prototype.next = function () {
          var value = this.value;
          if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
          return new BigInteger(MAX_INT_ARR, false);
        };
        NativeBigInt.prototype.next = function () {
          return new NativeBigInt(this.value + BigInt(1));
        };
        BigInteger.prototype.prev = function () {
          var value = this.value;
          if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
          }
          return subtractSmall(value, 1, this.sign);
        };
        SmallInteger.prototype.prev = function () {
          var value = this.value;
          if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
          return new BigInteger(MAX_INT_ARR, true);
        };
        NativeBigInt.prototype.prev = function () {
          return new NativeBigInt(this.value - BigInt(1));
        };
        var powersOfTwo = [1];
        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) {
          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
        }
        var powers2Length = powersOfTwo.length,
          highestPower2 = powersOfTwo[powers2Length - 1];
        function shift_isSmall(n) {
          return Math.abs(n) <= BASE;
        }
        BigInteger.prototype.shiftLeft = function (v) {
          var n = parseValue(v).toJSNumber();
          if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
          }
          if (n < 0) return this.shiftRight(-n);
          var result = this;
          if (result.isZero()) return result;
          while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
          }
          return result.multiply(powersOfTwo[n]);
        };
        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
        BigInteger.prototype.shiftRight = function (v) {
          var remQuo;
          var n = parseValue(v).toJSNumber();
          if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
          }
          if (n < 0) return this.shiftLeft(-n);
          var result = this;
          while (n >= powers2Length) {
            if (result.isZero() || result.isNegative() && result.isUnit()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
          }
          remQuo = divModAny(result, powersOfTwo[n]);
          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        };
        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
        function bitwise(x, y, fn) {
          y = parseValue(y);
          var xSign = x.isNegative(),
            ySign = y.isNegative();
          var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
          var xDigit = 0,
            yDigit = 0;
          var xDivMod = null,
            yDivMod = null;
          var result = [];
          while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
              xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
              yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
          }
          var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
          for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
          }
          return sum;
        }
        BigInteger.prototype.not = function () {
          return this.negate().prev();
        };
        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
        BigInteger.prototype.and = function (n) {
          return bitwise(this, n, function (a, b) {
            return a & b;
          });
        };
        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
        BigInteger.prototype.or = function (n) {
          return bitwise(this, n, function (a, b) {
            return a | b;
          });
        };
        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
        BigInteger.prototype.xor = function (n) {
          return bitwise(this, n, function (a, b) {
            return a ^ b;
          });
        };
        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
        var LOBMASK_I = 1 << 30,
          LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
        function roughLOB(n) {
          // get lowestOneBit (rough)
          // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
          // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
          var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
          return x & -x;
        }
        function integerLogarithm(value, base) {
          if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? {
              p: t,
              e: e * 2 + 1
            } : {
              p: p,
              e: e * 2
            };
          }
          return {
            p: bigInt(1),
            e: 0
          };
        }
        BigInteger.prototype.bitLength = function () {
          var n = this;
          if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
          }
          if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
          }
          return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
        };
        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
        function max(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.greater(b) ? a : b;
        }
        function min(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.lesser(b) ? a : b;
        }
        function gcd(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          if (a.equals(b)) return a;
          if (a.isZero()) return b;
          if (b.isZero()) return a;
          var c = Integer[1],
            d,
            t;
          while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
          }
          while (a.isEven()) {
            a = a.divide(roughLOB(a));
          }
          do {
            while (b.isEven()) {
              b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
              t = b;
              b = a;
              a = t;
            }
            b = b.subtract(a);
          } while (!b.isZero());
          return c.isUnit() ? a : a.multiply(c);
        }
        function lcm(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          return a.divide(gcd(a, b)).multiply(b);
        }
        function randBetween(a, b, rng) {
          a = parseValue(a);
          b = parseValue(b);
          var usedRNG = rng || Math.random;
          var low = min(a, b),
            high = max(a, b);
          var range = high.subtract(low).add(1);
          if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
          var digits = toBase(range, BASE).value;
          var result = [],
            restricted = true;
          for (var i = 0; i < digits.length; i++) {
            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < digits[i]) restricted = false;
          }
          return low.add(Integer.fromArray(result, BASE, false));
        }
        var parseBase = function parseBase(text, base, alphabet, caseSensitive) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          text = String(text);
          if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
          }
          var length = text.length;
          var i;
          var absBase = Math.abs(base);
          var alphabetValues = {};
          for (i = 0; i < alphabet.length; i++) {
            alphabetValues[alphabet[i]] = i;
          }
          for (i = 0; i < length; i++) {
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
              if (alphabetValues[c] >= absBase) {
                if (c === "1" && absBase === 1) continue;
                throw new Error(c + " is not a valid digit in base " + base + ".");
              }
            }
          }
          base = parseValue(base);
          var digits = [];
          var isNegative = text[0] === "-";
          for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));else if (c === "<") {
              var start = i;
              do {
                i++;
              } while (text[i] !== ">" && i < text.length);
              digits.push(parseValue(text.slice(start + 1, i)));
            } else throw new Error(c + " is not a valid character");
          }
          return parseBaseFromArray(digits, base, isNegative);
        };
        function parseBaseFromArray(digits, base, isNegative) {
          var val = Integer[0],
            pow = Integer[1],
            i;
          for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
          }
          return isNegative ? val.negate() : val;
        }
        function stringify(digit, alphabet) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          if (digit < alphabet.length) {
            return alphabet[digit];
          }
          return "<" + digit + ">";
        }
        function toBase(n, base) {
          base = bigInt(base);
          if (base.isZero()) {
            if (n.isZero()) return {
              value: [0],
              isNegative: false
            };
            throw new Error("Cannot convert nonzero numbers to base 0.");
          }
          if (base.equals(-1)) {
            if (n.isZero()) return {
              value: [0],
              isNegative: false
            };
            if (n.isNegative()) return {
              value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
              isNegative: false
            };
            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
              value: [].concat.apply([], arr),
              isNegative: false
            };
          }
          var neg = false;
          if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
          }
          if (base.isUnit()) {
            if (n.isZero()) return {
              value: [0],
              isNegative: false
            };
            return {
              value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
              isNegative: neg
            };
          }
          var out = [];
          var left = n,
            divmod;
          while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
              digit = base.minus(digit).abs();
              left = left.next();
            }
            out.push(digit.toJSNumber());
          }
          out.push(left.toJSNumber());
          return {
            value: out.reverse(),
            isNegative: neg
          };
        }
        function toBaseString(n, base, alphabet) {
          var arr = toBase(n, base);
          return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            return stringify(x, alphabet);
          }).join('');
        }
        BigInteger.prototype.toArray = function (radix) {
          return toBase(this, radix);
        };
        SmallInteger.prototype.toArray = function (radix) {
          return toBase(this, radix);
        };
        NativeBigInt.prototype.toArray = function (radix) {
          return toBase(this, radix);
        };
        BigInteger.prototype.toString = function (radix, alphabet) {
          if (radix === undefined) radix = 10;
          if (radix !== 10) return toBaseString(this, radix, alphabet);
          var v = this.value,
            l = v.length,
            str = String(v[--l]),
            zeros = "0000000",
            digit;
          while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
          }
          var sign = this.sign ? "-" : "";
          return sign + str;
        };
        SmallInteger.prototype.toString = function (radix, alphabet) {
          if (radix === undefined) radix = 10;
          if (radix != 10) return toBaseString(this, radix, alphabet);
          return String(this.value);
        };
        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
        NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
          return this.toString();
        };
        BigInteger.prototype.valueOf = function () {
          return parseInt(this.toString(), 10);
        };
        BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
        SmallInteger.prototype.valueOf = function () {
          return this.value;
        };
        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
          return parseInt(this.toString(), 10);
        };
        function parseStringValue(v) {
          if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
          }
          var sign = v[0] === "-";
          if (sign) v = v.slice(1);
          var split = v.split(/e/i);
          if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
          if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
              exp -= text.length - decimalPlace - 1;
              text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += new Array(exp + 1).join("0");
            v = text;
          }
          var isValid = /^([0-9][0-9]*)$/.test(v);
          if (!isValid) throw new Error("Invalid integer: " + v);
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
          }
          var r = [],
            max = v.length,
            l = LOG_BASE,
            min = max - l;
          while (max > 0) {
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
          }
          trim(r);
          return new BigInteger(r, sign);
        }
        function parseNumberValue(v) {
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
          }
          if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
          }
          return parseStringValue(v.toString());
        }
        function parseValue(v) {
          if (typeof v === "number") {
            return parseNumberValue(v);
          }
          if (typeof v === "string") {
            return parseStringValue(v);
          }
          if (typeof v === "bigint") {
            return new NativeBigInt(v);
          }
          return v;
        }
        // Pre-define numbers in range [-999,999]
        for (var i = 0; i < 1000; i++) {
          Integer[i] = parseValue(i);
          if (i > 0) Integer[-i] = parseValue(-i);
        }
        // Backwards compatibility
        Integer.one = Integer[1];
        Integer.zero = Integer[0];
        Integer.minusOne = Integer[-1];
        Integer.max = max;
        Integer.min = min;
        Integer.gcd = gcd;
        Integer.lcm = lcm;
        Integer.isInstance = function (x) {
          return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
        };
        Integer.randBetween = randBetween;
        Integer.fromArray = function (digits, base, isNegative) {
          return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
        };
        return Integer;
      }();

      // Node.js check
      if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
        module.exports = bigInt;
      }

      //amd check
      if (typeof define === "function" && define.amd) {
        define(function () {
          return bigInt;
        });
      }
    }, {}],
    5: [function (require, module, exports) {}, {}],
    6: [function (require, module, exports) {
      arguments[4][5][0].apply(exports, arguments);
    }, {
      "dup": 5
    }],
    7: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */
          /* eslint-disable no-proto */

          'use strict';

          var base64 = require('base64-js');
          var ieee754 = require('ieee754');
          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;
          var K_MAX_LENGTH = 0x7fffffff;
          exports.kMaxLength = K_MAX_LENGTH;

          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Print warning and recommend using `buffer` v4.x which has an Object
           *               implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * We report that the browser does not support typed arrays if the are not subclassable
           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
           * for __proto__ and has a buggy typed array implementation.
           */
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
            console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
          }
          function typedArraySupport() {
            // Can typed array instances can be augmented?
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function foo() {
                  return 42;
                }
              };
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }
          Object.defineProperty(Buffer.prototype, 'parent', {
            enumerable: true,
            get: function get() {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.buffer;
            }
          });
          Object.defineProperty(Buffer.prototype, 'offset', {
            enumerable: true,
            get: function get() {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.byteOffset;
            }
          });
          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            // Return an augmented `Uint8Array` instance
            var buf = new Uint8Array(length);
            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */

          function Buffer(arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new TypeError('The "string" argument must be of type string. Received type number');
              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }

          // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
          if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
              enumerable: false,
              writable: false
            });
          }
          Buffer.poolSize = 8192; // not used by this implementation

          function from(value, encodingOrOffset, length) {
            if (typeof value === 'string') {
              return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }
            if (value == null) {
              throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === 'number') {
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            }
            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }
            var b = fromObject(value);
            if (b) return b;
            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
              return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
            }
            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
          }

          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/
          Buffer.from = function (value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };

          // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
          // https://github.com/feross/buffer/pull/148
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;
          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }
          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }

          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/
          Buffer.alloc = function (size, fill, encoding) {
            return alloc(size, fill, encoding);
          };
          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }

          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */
          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(size);
          };
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */
          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(size);
          };
          function fromString(string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8';
            }
            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }
            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);
            var actual = buf.write(string, encoding);
            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              buf = buf.slice(0, actual);
            }
            return buf;
          }
          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }
          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }
            var buf;
            if (byteOffset === undefined && length === undefined) {
              buf = new Uint8Array(array);
            } else if (length === undefined) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }

            // Return an augmented `Uint8Array` instance
            buf.__proto__ = Buffer.prototype;
            return buf;
          }
          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);
              if (buf.length === 0) {
                return buf;
              }
              obj.copy(buf, 0, 0, len);
              return buf;
            }
            if (obj.length !== undefined) {
              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }
            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }
          function checked(length) {
            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= K_MAX_LENGTH) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              // eslint-disable-line eqeqeq
              length = 0;
            }
            return Buffer.alloc(+length);
          }
          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
          };

          Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            }
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer.alloc(0);
            }
            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }
            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer.from(buf);
              }
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== 'string') {
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
            }
            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;

            // Use a for loop to avoid recursion
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len;
                case 'utf8':
                case 'utf-8':
                  return utf8ToBytes(string).length;
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;
                case 'hex':
                  return len >>> 1;
                case 'base64':
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                  }

                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
              start = 0;
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
              return '';
            }
            if (end === undefined || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return '';
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return '';
            }
            if (!encoding) encoding = 'utf8';
            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);
                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);
                case 'ascii':
                  return asciiSlice(this, start, end);
                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end);
                case 'base64':
                  return base64Slice(this, start, end);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;
              }
            }
          }

          // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
          // reliably in a browserify context because there could be multiple different
          // copies of the 'buffer' package in use. This method works even for Buffer
          // instances that were created from another copy of the `buffer` package.
          // See: https://github.com/feross/buffer/issues/154
          Buffer.prototype._isBuffer = true;
          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits');
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits');
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits');
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return '';
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.toLocaleString = Buffer.prototype.toString;
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;
            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
            if (this.length > max) str += ' ... ';
            return '<Buffer ' + str + '>';
          };
          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer.from(target, target.offset, target.byteLength);
            }
            if (!Buffer.isBuffer(target)) {
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
            }
            if (start === undefined) {
              start = 0;
            }
            if (end === undefined) {
              end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
              thisStart = 0;
            }
            if (thisEnd === undefined) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index');
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1;

            // Normalize byteOffset
            if (typeof byteOffset === 'string') {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff;
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000;
            }
            byteOffset = +byteOffset; // Coerce to Number.
            if (numberIsNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1;
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir) return -1;else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0;else return -1;
            }

            // Normalize val
            if (typeof val === 'string') {
              val = Buffer.from(val, encoding);
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === 'number') {
              val = val & 0xFF; // Search for a byte value [0-255]
              if (typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError('val must be string, number or Buffer');
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();
              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              } else {
                return buf.readUInt16BE(i * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found) return i;
              }
            }
            return -1;
          }
          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
              // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === undefined) encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }
            } else {
              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
            }
            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds');
            }
            if (!encoding) encoding = 'utf8';
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);
                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);
                case 'ascii':
                  return asciiWrite(this, string, offset, length);
                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length);
                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD;
                bytesPerSequence = 1;
              } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                codePoint = 0xDC00 | codePoint & 0x3FF;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }

          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 0x1000;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = '';
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7F);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = '';
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start) end = start;
            var newBuf = this.subarray(start, end);
            // Return an augmented `Uint8Array` instance
            newBuf.__proto__ = Buffer.prototype;
            return newBuf;
          };

          /*
           * Need to make sure that buffer isn't trying to write out of bounds.
           */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }
            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            this[offset] = value & 0xff;
            return offset + 1;
          };
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (value < 0) value = 0xff + value + 1;
            this[offset] = value & 0xff;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
            if (offset < 0) throw new RangeError('Index out of range');
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };

          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;

            // Copy 0 bytes; we're done
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;

            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
            if (end < 0) throw new RangeError('sourceEnd out of bounds');

            // Are we oob?
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
              // Use built-in when available, missing from IE11
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            }
            return len;
          };

          // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === 'string') {
                encoding = end;
                end = this.length;
              }
              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string');
              }
              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
                  // Fast path: If `val` fits into a single byte, use that numeric value.
                  val = code;
                }
              }
            } else if (typeof val === 'number') {
              val = val & 255;
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index');
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;
            if (!val) val = 0;
            var i;
            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val + '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };

          // HELPER FUNCTIONS
          // ================

          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
          function base64clean(str) {
            // Node takes equal signs as end of the Base64 encoding
            str = str.split('=')[0];
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = str.trim().replace(INVALID_BASE64_RE, '');
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return '';
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '=';
            }
            return str;
          }
          function toHex(n) {
            if (n < 16) return '0' + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);

              // is surrogate component
              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  }

                  // valid lead
                  leadSurrogate = codePoint;
                  continue;
                }

                // 2 leads in a row
                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  leadSurrogate = codePoint;
                  continue;
                }

                // valid surrogate pair
                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              }
              leadSurrogate = null;

              // encode utf8
              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else {
                throw new Error('Invalid code point');
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xFF);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }
            return i;
          }

          // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
          // the `instanceof` check but they should be treated as of that type.
          // See: https://github.com/feross/buffer/issues/166
          function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            // For IE11 support
            return obj !== obj; // eslint-disable-line no-self-compare
          }
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "base64-js": 3,
      "buffer": 7,
      "ieee754": 32
    }],
    8: [function (require, module, exports) {
      (function (process, Buffer) {
        (function () {
          /* cfb.js (C) 2013-present SheetJS -- http://sheetjs.com */
          /* vim: set ts=2: */
          /*jshint eqnull:true */
          /*exported CFB */
          /*global module, require:false, process:false, Buffer:false, Uint8Array:false, Uint16Array:false */

          var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          function Base64_encode(input) {
            var o = "";
            var c1 = 0,
              c2 = 0,
              c3 = 0,
              e1 = 0,
              e2 = 0,
              e3 = 0,
              e4 = 0;
            for (var i = 0; i < input.length;) {
              c1 = input.charCodeAt(i++);
              e1 = c1 >> 2;
              c2 = input.charCodeAt(i++);
              e2 = (c1 & 3) << 4 | c2 >> 4;
              c3 = input.charCodeAt(i++);
              e3 = (c2 & 15) << 2 | c3 >> 6;
              e4 = c3 & 63;
              if (isNaN(c2)) e3 = e4 = 64;else if (isNaN(c3)) e4 = 64;
              o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
            }
            return o;
          }
          function Base64_decode(input) {
            var o = "";
            var c1 = 0,
              c2 = 0,
              c3 = 0,
              e1 = 0,
              e2 = 0,
              e3 = 0,
              e4 = 0;
            input = input.replace(/[^\w\+\/\=]/g, "");
            for (var i = 0; i < input.length;) {
              e1 = Base64_map.indexOf(input.charAt(i++));
              e2 = Base64_map.indexOf(input.charAt(i++));
              c1 = e1 << 2 | e2 >> 4;
              o += String.fromCharCode(c1);
              e3 = Base64_map.indexOf(input.charAt(i++));
              c2 = (e2 & 15) << 4 | e3 >> 2;
              if (e3 !== 64) o += String.fromCharCode(c2);
              e4 = Base64_map.indexOf(input.charAt(i++));
              c3 = (e3 & 3) << 6 | e4;
              if (e4 !== 64) o += String.fromCharCode(c3);
            }
            return o;
          }
          var has_buf = function () {
            return typeof Buffer !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && !!process.versions.node;
          }();
          var Buffer_from = function () {
            if (typeof Buffer !== 'undefined') {
              var nbfs = !Buffer.from;
              if (!nbfs) try {
                Buffer.from("foo", "utf8");
              } catch (e) {
                nbfs = true;
              }
              return nbfs ? function (buf, enc) {
                return enc ? new Buffer(buf, enc) : new Buffer(buf);
              } : Buffer.from.bind(Buffer);
            }
            return function () {};
          }();
          function new_raw_buf(len) {
            /* jshint -W056 */
            if (has_buf) {
              if (Buffer.alloc) return Buffer.alloc(len);
              var b = new Buffer(len);
              b.fill(0);
              return b;
            }
            return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
            /* jshint +W056 */
          }

          function new_unsafe_buf(len) {
            /* jshint -W056 */
            if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
            return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
            /* jshint +W056 */
          }

          var s2a = function s2a(s) {
            if (has_buf) return Buffer_from(s, "binary");
            return s.split("").map(function (x) {
              return x.charCodeAt(0) & 0xff;
            });
          };
          var chr0 = /\u0000/g,
            chr1 = /[\u0001-\u0006]/g;
          var __toBuffer = function __toBuffer(bufs) {
            var x = [];
            for (var i = 0; i < bufs[0].length; ++i) {
              x.push.apply(x, bufs[0][i]);
            }
            return x;
          };
          var ___toBuffer = __toBuffer;
          var __utf16le = function __utf16le(b, s, e) {
            var ss = [];
            for (var i = s; i < e; i += 2) {
              ss.push(String.fromCharCode(__readUInt16LE(b, i)));
            }
            return ss.join("").replace(chr0, '');
          };
          var ___utf16le = __utf16le;
          var __hexlify = function __hexlify(b, s, l) {
            var ss = [];
            for (var i = s; i < s + l; ++i) {
              ss.push(("0" + b[i].toString(16)).slice(-2));
            }
            return ss.join("");
          };
          var ___hexlify = __hexlify;
          var __bconcat = function __bconcat(bufs) {
            if (Array.isArray(bufs[0])) return [].concat.apply([], bufs);
            var maxlen = 0,
              i = 0;
            for (i = 0; i < bufs.length; ++i) {
              maxlen += bufs[i].length;
            }
            var o = new Uint8Array(maxlen);
            for (i = 0, maxlen = 0; i < bufs.length; maxlen += bufs[i].length, ++i) {
              o.set(bufs[i], maxlen);
            }
            return o;
          };
          var bconcat = __bconcat;
          if (has_buf) {
            __utf16le = function __utf16le(b, s, e) {
              if (!Buffer.isBuffer(b)) return ___utf16le(b, s, e);
              return b.toString('utf16le', s, e).replace(chr0, '') /*.replace(chr1,'!')*/;
            };

            __hexlify = function __hexlify(b, s, l) {
              return Buffer.isBuffer(b) ? b.toString('hex', s, s + l) : ___hexlify(b, s, l);
            };
            __toBuffer = function __toBuffer(bufs) {
              return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs);
            };
            s2a = function s2a(s) {
              return Buffer_from(s, "binary");
            };
            bconcat = function bconcat(bufs) {
              return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : __bconcat(bufs);
            };
          }
          var __readUInt8 = function __readUInt8(b, idx) {
            return b[idx];
          };
          var __readUInt16LE = function __readUInt16LE(b, idx) {
            return b[idx + 1] * (1 << 8) + b[idx];
          };
          var __readInt16LE = function __readInt16LE(b, idx) {
            var u = b[idx + 1] * (1 << 8) + b[idx];
            return u < 0x8000 ? u : (0xffff - u + 1) * -1;
          };
          var __readUInt32LE = function __readUInt32LE(b, idx) {
            return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
          };
          var __readInt32LE = function __readInt32LE(b, idx) {
            return (b[idx + 3] << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
          };
          function ReadShift(size, t) {
            var oI,
              oS,
              type = 0;
            switch (size) {
              case 1:
                oI = __readUInt8(this, this.l);
                break;
              case 2:
                oI = (t !== 'i' ? __readUInt16LE : __readInt16LE)(this, this.l);
                break;
              case 4:
                oI = __readInt32LE(this, this.l);
                break;
              case 16:
                type = 2;
                oS = __hexlify(this, this.l, size);
            }
            this.l += size;
            if (type === 0) return oI;
            return oS;
          }
          var __writeUInt32LE = function __writeUInt32LE(b, val, idx) {
            b[idx] = val & 0xFF;
            b[idx + 1] = val >>> 8 & 0xFF;
            b[idx + 2] = val >>> 16 & 0xFF;
            b[idx + 3] = val >>> 24 & 0xFF;
          };
          var __writeInt32LE = function __writeInt32LE(b, val, idx) {
            b[idx] = val & 0xFF;
            b[idx + 1] = val >> 8 & 0xFF;
            b[idx + 2] = val >> 16 & 0xFF;
            b[idx + 3] = val >> 24 & 0xFF;
          };
          function WriteShift(t, val, f) {
            var size = 0,
              i = 0;
            switch (f) {
              case "hex":
                for (; i < t; ++i) {
                  this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
                }
                return this;
              case "utf16le":
                var end = this.l + t;
                for (i = 0; i < Math.min(val.length, t); ++i) {
                  var cc = val.charCodeAt(i);
                  this[this.l++] = cc & 0xff;
                  this[this.l++] = cc >> 8;
                }
                while (this.l < end) {
                  this[this.l++] = 0;
                }
                return this;
            }
            switch (t) {
              case 1:
                size = 1;
                this[this.l] = val & 0xFF;
                break;
              case 2:
                size = 2;
                this[this.l] = val & 0xFF;
                val >>>= 8;
                this[this.l + 1] = val & 0xFF;
                break;
              case 4:
                size = 4;
                __writeUInt32LE(this, val, this.l);
                break;
              case -4:
                size = 4;
                __writeInt32LE(this, val, this.l);
                break;
            }
            this.l += size;
            return this;
          }
          function CheckField(hexstr, fld) {
            var m = __hexlify(this, this.l, hexstr.length >> 1);
            if (m !== hexstr) throw new Error(fld + 'Expected ' + hexstr + ' saw ' + m);
            this.l += hexstr.length >> 1;
          }
          function prep_blob(blob, pos) {
            blob.l = pos;
            blob.read_shift = ReadShift;
            blob.chk = CheckField;
            blob.write_shift = WriteShift;
          }
          function new_buf(sz) {
            var o = new_raw_buf(sz);
            prep_blob(o, 0);
            return o;
          }

          /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
          /* vim: set ts=2: */
          /*exported CRC32 */
          var CRC32 = function () {
            var CRC32 = {};
            CRC32.version = '1.2.1';
            /*global Int32Array */
            function signed_crc_table() {
              var c = 0,
                table = new Array(256);
              for (var n = 0; n != 256; ++n) {
                c = n;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                table[n] = c;
              }
              return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
            }
            var T0 = signed_crc_table();
            function slice_by_16_tables(T) {
              var c = 0,
                v = 0,
                n = 0,
                table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096);
              for (n = 0; n != 256; ++n) {
                table[n] = T[n];
              }
              for (n = 0; n != 256; ++n) {
                v = T[n];
                for (c = 256 + n; c < 4096; c += 256) {
                  v = table[c] = v >>> 8 ^ T[v & 0xFF];
                }
              }
              var out = [];
              for (n = 1; n != 16; ++n) {
                out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
              }
              return out;
            }
            var TT = slice_by_16_tables(T0);
            var T1 = TT[0],
              T2 = TT[1],
              T3 = TT[2],
              T4 = TT[3],
              T5 = TT[4];
            var T6 = TT[5],
              T7 = TT[6],
              T8 = TT[7],
              T9 = TT[8],
              Ta = TT[9];
            var Tb = TT[10],
              Tc = TT[11],
              Td = TT[12],
              Te = TT[13],
              Tf = TT[14];
            function crc32_bstr(bstr, seed) {
              var C = seed ^ -1;
              for (var i = 0, L = bstr.length; i < L;) {
                C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 0xFF];
              }
              return ~C;
            }
            function crc32_buf(B, seed) {
              var C = seed ^ -1,
                L = B.length - 15,
                i = 0;
              for (; i < L;) {
                C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
              }
              L += 15;
              while (i < L) {
                C = C >>> 8 ^ T0[(C ^ B[i++]) & 0xFF];
              }
              return ~C;
            }
            function crc32_str(str, seed) {
              var C = seed ^ -1;
              for (var i = 0, L = str.length, c = 0, d = 0; i < L;) {
                c = str.charCodeAt(i++);
                if (c < 0x80) {
                  C = C >>> 8 ^ T0[(C ^ c) & 0xFF];
                } else if (c < 0x800) {
                  C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
                } else if (c >= 0xD800 && c < 0xE000) {
                  c = (c & 1023) + 64;
                  d = str.charCodeAt(i++) & 1023;
                  C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 0xFF];
                } else {
                  C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
                }
              }
              return ~C;
            }
            CRC32.table = T0;
            CRC32.bstr = crc32_bstr;
            CRC32.buf = crc32_buf;
            CRC32.str = crc32_str;
            return CRC32;
          }();
          /* [MS-CFB] v20171201 */
          var CFB = function _CFB() {
            var exports = {};
            exports.version = '1.2.2';
            /* [MS-CFB] 2.6.4 */
            function namecmp(l, r) {
              var L = l.split("/"),
                R = r.split("/");
              for (var i = 0, c = 0, Z = Math.min(L.length, R.length); i < Z; ++i) {
                if (c = L[i].length - R[i].length) return c;
                if (L[i] != R[i]) return L[i] < R[i] ? -1 : 1;
              }
              return L.length - R.length;
            }
            function dirname(p) {
              if (p.charAt(p.length - 1) == "/") return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
              var c = p.lastIndexOf("/");
              return c === -1 ? p : p.slice(0, c + 1);
            }
            function filename(p) {
              if (p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));
              var c = p.lastIndexOf("/");
              return c === -1 ? p : p.slice(c + 1);
            }
            /* -------------------------------------------------------------------------- */
            /* DOS Date format:
               high|YYYYYYYm.mmmddddd.HHHHHMMM.MMMSSSSS|low
               add 1980 to stored year
               stored second should be doubled
            */

            /* write JS date to buf as a DOS date */
            function write_dos_date(buf, date) {
              if (typeof date === "string") date = new Date(date);
              var hms = date.getHours();
              hms = hms << 6 | date.getMinutes();
              hms = hms << 5 | date.getSeconds() >>> 1;
              buf.write_shift(2, hms);
              var ymd = date.getFullYear() - 1980;
              ymd = ymd << 4 | date.getMonth() + 1;
              ymd = ymd << 5 | date.getDate();
              buf.write_shift(2, ymd);
            }

            /* read four bytes from buf and interpret as a DOS date */
            function parse_dos_date(buf) {
              var hms = buf.read_shift(2) & 0xFFFF;
              var ymd = buf.read_shift(2) & 0xFFFF;
              var val = new Date();
              var d = ymd & 0x1F;
              ymd >>>= 5;
              var m = ymd & 0x0F;
              ymd >>>= 4;
              val.setMilliseconds(0);
              val.setFullYear(ymd + 1980);
              val.setMonth(m - 1);
              val.setDate(d);
              var S = hms & 0x1F;
              hms >>>= 5;
              var M = hms & 0x3F;
              hms >>>= 6;
              val.setHours(hms);
              val.setMinutes(M);
              val.setSeconds(S << 1);
              return val;
            }
            function parse_extra_field(blob) {
              prep_blob(blob, 0);
              var o = {};
              var flags = 0;
              while (blob.l <= blob.length - 4) {
                var type = blob.read_shift(2);
                var sz = blob.read_shift(2),
                  tgt = blob.l + sz;
                var p = {};
                switch (type) {
                  /* UNIX-style Timestamps */
                  case 0x5455:
                    {
                      flags = blob.read_shift(1);
                      if (flags & 1) p.mtime = blob.read_shift(4);
                      /* for some reason, CD flag corresponds to LFH */
                      if (sz > 5) {
                        if (flags & 2) p.atime = blob.read_shift(4);
                        if (flags & 4) p.ctime = blob.read_shift(4);
                      }
                      if (p.mtime) p.mt = new Date(p.mtime * 1000);
                    }
                    break;
                }
                blob.l = tgt;
                o[type] = p;
              }
              return o;
            }
            var fs;
            function get_fs() {
              return fs || (fs = require('fs'));
            }
            function parse(file, options) {
              if (file[0] == 0x50 && file[1] == 0x4b) return parse_zip(file, options);
              if ((file[0] | 0x20) == 0x6d && (file[1] | 0x20) == 0x69) return parse_mad(file, options);
              if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
              var mver = 3;
              var ssz = 512;
              var nmfs = 0; // number of mini FAT sectors
              var difat_sec_cnt = 0;
              var dir_start = 0;
              var minifat_start = 0;
              var difat_start = 0;
              var fat_addrs = []; // locations of FAT sectors

              /* [MS-CFB] 2.2 Compound File Header */
              var blob = file.slice(0, 512);
              prep_blob(blob, 0);

              /* major version */
              var mv = check_get_mver(blob);
              mver = mv[0];
              switch (mver) {
                case 3:
                  ssz = 512;
                  break;
                case 4:
                  ssz = 4096;
                  break;
                case 0:
                  if (mv[1] == 0) return parse_zip(file, options);
                /* falls through */
                default:
                  throw new Error("Major Version: Expected 3 or 4 saw " + mver);
              }

              /* reprocess header */
              if (ssz !== 512) {
                blob = file.slice(0, ssz);
                prep_blob(blob, 28 /* blob.l */);
              }
              /* Save header for final object */
              var header = file.slice(0, ssz);
              check_shifts(blob, mver);

              // Number of Directory Sectors
              var dir_cnt = blob.read_shift(4, 'i');
              if (mver === 3 && dir_cnt !== 0) throw new Error('# Directory Sectors: Expected 0 saw ' + dir_cnt);

              // Number of FAT Sectors
              blob.l += 4;

              // First Directory Sector Location
              dir_start = blob.read_shift(4, 'i');

              // Transaction Signature
              blob.l += 4;

              // Mini Stream Cutoff Size
              blob.chk('00100000', 'Mini Stream Cutoff Size: ');

              // First Mini FAT Sector Location
              minifat_start = blob.read_shift(4, 'i');

              // Number of Mini FAT Sectors
              nmfs = blob.read_shift(4, 'i');

              // First DIFAT sector location
              difat_start = blob.read_shift(4, 'i');

              // Number of DIFAT Sectors
              difat_sec_cnt = blob.read_shift(4, 'i');

              // Grab FAT Sector Locations
              for (var q = -1, j = 0; j < 109; ++j) {
                /* 109 = (512 - blob.l)>>>2; */
                q = blob.read_shift(4, 'i');
                if (q < 0) break;
                fat_addrs[j] = q;
              }

              /** Break the file up into sectors */
              var sectors = sectorify(file, ssz);
              sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);

              /** Chains */
              var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
              sector_list[dir_start].name = "!Directory";
              if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
              sector_list[fat_addrs[0]].name = "!FAT";
              sector_list.fat_addrs = fat_addrs;
              sector_list.ssz = ssz;

              /* [MS-CFB] 2.6.1 Compound File Directory Entry */
              var files = {},
                Paths = [],
                FileIndex = [],
                FullPaths = [];
              read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
              build_full_paths(FileIndex, FullPaths, Paths);
              Paths.shift();
              var o = {
                FileIndex: FileIndex,
                FullPaths: FullPaths
              };

              // $FlowIgnore
              if (options && options.raw) o.raw = {
                header: header,
                sectors: sectors
              };
              return o;
            } // parse

            /* [MS-CFB] 2.2 Compound File Header -- read up to major version */
            function check_get_mver(blob) {
              if (blob[blob.l] == 0x50 && blob[blob.l + 1] == 0x4b) return [0, 0];
              // header signature 8
              blob.chk(HEADER_SIGNATURE, 'Header Signature: ');

              // clsid 16
              //blob.chk(HEADER_CLSID, 'CLSID: ');
              blob.l += 16;

              // minor version 2
              var mver = blob.read_shift(2, 'u');
              return [blob.read_shift(2, 'u'), mver];
            }
            function check_shifts(blob, mver) {
              var shift = 0x09;

              // Byte Order
              //blob.chk('feff', 'Byte Order: '); // note: some writers put 0xffff
              blob.l += 2;

              // Sector Shift
              switch (shift = blob.read_shift(2)) {
                case 0x09:
                  if (mver != 3) throw new Error('Sector Shift: Expected 9 saw ' + shift);
                  break;
                case 0x0c:
                  if (mver != 4) throw new Error('Sector Shift: Expected 12 saw ' + shift);
                  break;
                default:
                  throw new Error('Sector Shift: Expected 9 or 12 saw ' + shift);
              }

              // Mini Sector Shift
              blob.chk('0600', 'Mini Sector Shift: ');

              // Reserved
              blob.chk('000000000000', 'Reserved: ');
            }

            /** Break the file up into sectors */
            function sectorify(file, ssz) {
              var nsectors = Math.ceil(file.length / ssz) - 1;
              var sectors = [];
              for (var i = 1; i < nsectors; ++i) {
                sectors[i - 1] = file.slice(i * ssz, (i + 1) * ssz);
              }
              sectors[nsectors - 1] = file.slice(nsectors * ssz);
              return sectors;
            }

            /* [MS-CFB] 2.6.4 Red-Black Tree */
            function build_full_paths(FI, FP, Paths) {
              var i = 0,
                L = 0,
                R = 0,
                C = 0,
                j = 0,
                pl = Paths.length;
              var dad = [],
                q = [];
              for (; i < pl; ++i) {
                dad[i] = q[i] = i;
                FP[i] = Paths[i];
              }
              for (; j < q.length; ++j) {
                i = q[j];
                L = FI[i].L;
                R = FI[i].R;
                C = FI[i].C;
                if (dad[i] === i) {
                  if (L !== -1 /*NOSTREAM*/ && dad[L] !== L) dad[i] = dad[L];
                  if (R !== -1 && dad[R] !== R) dad[i] = dad[R];
                }
                if (C !== -1 /*NOSTREAM*/) dad[C] = i;
                if (L !== -1 && i != dad[i]) {
                  dad[L] = dad[i];
                  if (q.lastIndexOf(L) < j) q.push(L);
                }
                if (R !== -1 && i != dad[i]) {
                  dad[R] = dad[i];
                  if (q.lastIndexOf(R) < j) q.push(R);
                }
              }
              for (i = 1; i < pl; ++i) {
                if (dad[i] === i) {
                  if (R !== -1 /*NOSTREAM*/ && dad[R] !== R) dad[i] = dad[R];else if (L !== -1 && dad[L] !== L) dad[i] = dad[L];
                }
              }
              for (i = 1; i < pl; ++i) {
                if (FI[i].type === 0 /* unknown */) continue;
                j = i;
                if (j != dad[j]) do {
                  j = dad[j];
                  FP[i] = FP[j] + "/" + FP[i];
                } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
                dad[i] = -1;
              }
              FP[0] += "/";
              for (i = 1; i < pl; ++i) {
                if (FI[i].type !== 2 /* stream */) FP[i] += "/";
              }
            }
            function get_mfat_entry(entry, payload, mini) {
              var start = entry.start,
                size = entry.size;
              //return (payload.slice(start*MSSZ, start*MSSZ + size));
              var o = [];
              var idx = start;
              while (mini && size > 0 && idx >= 0) {
                o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
                size -= MSSZ;
                idx = __readInt32LE(mini, idx * 4);
              }
              if (o.length === 0) return new_buf(0);
              return bconcat(o).slice(0, entry.size);
            }

            /** Chase down the rest of the DIFAT chain to build a comprehensive list
                DIFAT chains by storing the next sector number as the last 32 bits */
            function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
              var q = ENDOFCHAIN;
              if (idx === ENDOFCHAIN) {
                if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
              } else if (idx !== -1 /*FREESECT*/) {
                var sector = sectors[idx],
                  m = (ssz >>> 2) - 1;
                if (!sector) return;
                for (var i = 0; i < m; ++i) {
                  if ((q = __readInt32LE(sector, i * 4)) === ENDOFCHAIN) break;
                  fat_addrs.push(q);
                }
                if (cnt >= 1) sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
              }
            }

            /** Follow the linked list of sectors for a given starting point */
            function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
              var buf = [],
                buf_chain = [];
              if (!chkd) chkd = [];
              var modulus = ssz - 1,
                j = 0,
                jj = 0;
              for (j = start; j >= 0;) {
                chkd[j] = true;
                buf[buf.length] = j;
                buf_chain.push(sectors[j]);
                var addr = fat_addrs[Math.floor(j * 4 / ssz)];
                jj = j * 4 & modulus;
                if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
                if (!sectors[addr]) break;
                j = __readInt32LE(sectors[addr], jj);
              }
              return {
                nodes: buf,
                data: __toBuffer([buf_chain])
              };
            }

            /** Chase down the sector linked lists */
            function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
              var sl = sectors.length,
                sector_list = [];
              var chkd = [],
                buf = [],
                buf_chain = [];
              var modulus = ssz - 1,
                i = 0,
                j = 0,
                k = 0,
                jj = 0;
              for (i = 0; i < sl; ++i) {
                buf = [];
                k = i + dir_start;
                if (k >= sl) k -= sl;
                if (chkd[k]) continue;
                buf_chain = [];
                var seen = [];
                for (j = k; j >= 0;) {
                  seen[j] = true;
                  chkd[j] = true;
                  buf[buf.length] = j;
                  buf_chain.push(sectors[j]);
                  var addr = fat_addrs[Math.floor(j * 4 / ssz)];
                  jj = j * 4 & modulus;
                  if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
                  if (!sectors[addr]) break;
                  j = __readInt32LE(sectors[addr], jj);
                  if (seen[j]) break;
                }
                sector_list[k] = {
                  nodes: buf,
                  data: __toBuffer([buf_chain])
                };
              }
              return sector_list;
            }

            /* [MS-CFB] 2.6.1 Compound File Directory Entry */
            function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
              var minifat_store = 0,
                pl = Paths.length ? 2 : 0;
              var sector = sector_list[dir_start].data;
              var i = 0,
                namelen = 0,
                name;
              for (; i < sector.length; i += 128) {
                var blob = sector.slice(i, i + 128);
                prep_blob(blob, 64);
                namelen = blob.read_shift(2);
                name = __utf16le(blob, 0, namelen - pl);
                Paths.push(name);
                var o = {
                  name: name,
                  type: blob.read_shift(1),
                  color: blob.read_shift(1),
                  L: blob.read_shift(4, 'i'),
                  R: blob.read_shift(4, 'i'),
                  C: blob.read_shift(4, 'i'),
                  clsid: blob.read_shift(16),
                  state: blob.read_shift(4, 'i'),
                  start: 0,
                  size: 0
                };
                var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
                if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);
                var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
                if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);
                o.start = blob.read_shift(4, 'i');
                o.size = blob.read_shift(4, 'i');
                if (o.size < 0 && o.start < 0) {
                  o.size = o.type = 0;
                  o.start = ENDOFCHAIN;
                  o.name = "";
                }
                if (o.type === 5) {
                  /* root */
                  minifat_store = o.start;
                  if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
                  /*minifat_size = o.size;*/
                } else if (o.size >= 4096 /* MSCSZ */) {
                  o.storage = 'fat';
                  if (sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
                  sector_list[o.start].name = o.name;
                  o.content = sector_list[o.start].data.slice(0, o.size);
                } else {
                  o.storage = 'minifat';
                  if (o.size < 0) o.size = 0;else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
                    o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
                  }
                }
                if (o.content) prep_blob(o.content, 0);
                files[name] = o;
                FileIndex.push(o);
              }
            }
            function read_date(blob, offset) {
              return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1000);
            }
            function read_file(filename, options) {
              get_fs();
              return parse(fs.readFileSync(filename), options);
            }
            function read(blob, options) {
              var type = options && options.type;
              if (!type) {
                if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
              }
              switch (type || "base64") {
                case "file":
                  return read_file(blob, options);
                case "base64":
                  return parse(s2a(Base64_decode(blob)), options);
                case "binary":
                  return parse(s2a(blob), options);
              }
              return parse(blob, options);
            }
            function init_cfb(cfb, opts) {
              var o = opts || {},
                root = o.root || "Root Entry";
              if (!cfb.FullPaths) cfb.FullPaths = [];
              if (!cfb.FileIndex) cfb.FileIndex = [];
              if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
              if (cfb.FullPaths.length === 0) {
                cfb.FullPaths[0] = root + "/";
                cfb.FileIndex[0] = {
                  name: root,
                  type: 5
                };
              }
              if (o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;
              seed_cfb(cfb);
            }
            function seed_cfb(cfb) {
              var nm = "\x01Sh33tJ5";
              if (CFB.find(cfb, "/" + nm)) return;
              var p = new_buf(4);
              p[0] = 55;
              p[1] = p[3] = 50;
              p[2] = 54;
              cfb.FileIndex.push({
                name: nm,
                type: 2,
                content: p,
                size: 4,
                L: 69,
                R: 69,
                C: 69
              });
              cfb.FullPaths.push(cfb.FullPaths[0] + nm);
              rebuild_cfb(cfb);
            }
            function rebuild_cfb(cfb, f) {
              init_cfb(cfb);
              var gc = false,
                s = false;
              for (var i = cfb.FullPaths.length - 1; i >= 0; --i) {
                var _file = cfb.FileIndex[i];
                switch (_file.type) {
                  case 0:
                    if (s) gc = true;else {
                      cfb.FileIndex.pop();
                      cfb.FullPaths.pop();
                    }
                    break;
                  case 1:
                  case 2:
                  case 5:
                    s = true;
                    if (isNaN(_file.R * _file.L * _file.C)) gc = true;
                    if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
                    break;
                  default:
                    gc = true;
                    break;
                }
              }
              if (!gc && !f) return;
              var now = new Date(1987, 1, 19),
                j = 0;
              // Track which names exist
              var fullPaths = Object.create ? Object.create(null) : {};
              var data = [];
              for (i = 0; i < cfb.FullPaths.length; ++i) {
                fullPaths[cfb.FullPaths[i]] = true;
                if (cfb.FileIndex[i].type === 0) continue;
                data.push([cfb.FullPaths[i], cfb.FileIndex[i]]);
              }
              for (i = 0; i < data.length; ++i) {
                var dad = dirname(data[i][0]);
                s = fullPaths[dad];
                while (!s) {
                  while (dirname(dad) && !fullPaths[dirname(dad)]) {
                    dad = dirname(dad);
                  }
                  data.push([dad, {
                    name: filename(dad).replace("/", ""),
                    type: 1,
                    clsid: HEADER_CLSID,
                    ct: now,
                    mt: now,
                    content: null
                  }]);

                  // Add name to set
                  fullPaths[dad] = true;
                  dad = dirname(data[i][0]);
                  s = fullPaths[dad];
                }
              }
              data.sort(function (x, y) {
                return namecmp(x[0], y[0]);
              });
              cfb.FullPaths = [];
              cfb.FileIndex = [];
              for (i = 0; i < data.length; ++i) {
                cfb.FullPaths[i] = data[i][0];
                cfb.FileIndex[i] = data[i][1];
              }
              for (i = 0; i < data.length; ++i) {
                var elt = cfb.FileIndex[i];
                var nm = cfb.FullPaths[i];
                elt.name = filename(nm).replace("/", "");
                elt.L = elt.R = elt.C = -(elt.color = 1);
                elt.size = elt.content ? elt.content.length : 0;
                elt.start = 0;
                elt.clsid = elt.clsid || HEADER_CLSID;
                if (i === 0) {
                  elt.C = data.length > 1 ? 1 : -1;
                  elt.size = 0;
                  elt.type = 5;
                } else if (nm.slice(-1) == "/") {
                  for (j = i + 1; j < data.length; ++j) {
                    if (dirname(cfb.FullPaths[j]) == nm) break;
                  }
                  elt.C = j >= data.length ? -1 : j;
                  for (j = i + 1; j < data.length; ++j) {
                    if (dirname(cfb.FullPaths[j]) == dirname(nm)) break;
                  }
                  elt.R = j >= data.length ? -1 : j;
                  elt.type = 1;
                } else {
                  if (dirname(cfb.FullPaths[i + 1] || "") == dirname(nm)) elt.R = i + 1;
                  elt.type = 2;
                }
              }
            }
            function _write(cfb, options) {
              var _opts = options || {};
              /* MAD is order-sensitive, skip rebuild and sort */
              if (_opts.fileType == 'mad') return write_mad(cfb, _opts);
              rebuild_cfb(cfb);
              switch (_opts.fileType) {
                case 'zip':
                  return write_zip(cfb, _opts);
                //case 'mad': return write_mad(cfb, _opts);
              }

              var L = function (cfb) {
                var mini_size = 0,
                  fat_size = 0;
                for (var i = 0; i < cfb.FileIndex.length; ++i) {
                  var file = cfb.FileIndex[i];
                  if (!file.content) continue;
                  var flen = file.content.length;
                  if (flen > 0) {
                    if (flen < 0x1000) mini_size += flen + 0x3F >> 6;else fat_size += flen + 0x01FF >> 9;
                  }
                }
                var dir_cnt = cfb.FullPaths.length + 3 >> 2;
                var mini_cnt = mini_size + 7 >> 3;
                var mfat_cnt = mini_size + 0x7F >> 7;
                var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
                var fat_cnt = fat_base + 0x7F >> 7;
                var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 0x7F);
                while (fat_base + fat_cnt + difat_cnt + 0x7F >> 7 > fat_cnt) {
                  difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 0x7F);
                }
                var L = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
                cfb.FileIndex[0].size = mini_size << 6;
                L[7] = (cfb.FileIndex[0].start = L[0] + L[1] + L[2] + L[3] + L[4] + L[5]) + (L[6] + 7 >> 3);
                return L;
              }(cfb);
              var o = new_buf(L[7] << 9);
              var i = 0,
                T = 0;
              {
                for (i = 0; i < 8; ++i) {
                  o.write_shift(1, HEADER_SIG[i]);
                }
                for (i = 0; i < 8; ++i) {
                  o.write_shift(2, 0);
                }
                o.write_shift(2, 0x003E);
                o.write_shift(2, 0x0003);
                o.write_shift(2, 0xFFFE);
                o.write_shift(2, 0x0009);
                o.write_shift(2, 0x0006);
                for (i = 0; i < 3; ++i) {
                  o.write_shift(2, 0);
                }
                o.write_shift(4, 0);
                o.write_shift(4, L[2]);
                o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
                o.write_shift(4, 0);
                o.write_shift(4, 1 << 12);
                o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
                o.write_shift(4, L[3]);
                o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
                o.write_shift(4, L[1]);
                for (i = 0; i < 109; ++i) {
                  o.write_shift(-4, i < L[2] ? L[1] + i : -1);
                }
              }
              if (L[1]) {
                for (T = 0; T < L[1]; ++T) {
                  for (; i < 236 + T * 127; ++i) {
                    o.write_shift(-4, i < L[2] ? L[1] + i : -1);
                  }
                  o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
                }
              }
              var chainit = function chainit(w) {
                for (T += w; i < T - 1; ++i) {
                  o.write_shift(-4, i + 1);
                }
                if (w) {
                  ++i;
                  o.write_shift(-4, ENDOFCHAIN);
                }
              };
              T = i = 0;
              for (T += L[1]; i < T; ++i) {
                o.write_shift(-4, consts.DIFSECT);
              }
              for (T += L[2]; i < T; ++i) {
                o.write_shift(-4, consts.FATSECT);
              }
              chainit(L[3]);
              chainit(L[4]);
              var j = 0,
                flen = 0;
              var file = cfb.FileIndex[0];
              for (; j < cfb.FileIndex.length; ++j) {
                file = cfb.FileIndex[j];
                if (!file.content) continue;
                flen = file.content.length;
                if (flen < 0x1000) continue;
                file.start = T;
                chainit(flen + 0x01FF >> 9);
              }
              chainit(L[6] + 7 >> 3);
              while (o.l & 0x1FF) {
                o.write_shift(-4, consts.ENDOFCHAIN);
              }
              T = i = 0;
              for (j = 0; j < cfb.FileIndex.length; ++j) {
                file = cfb.FileIndex[j];
                if (!file.content) continue;
                flen = file.content.length;
                if (!flen || flen >= 0x1000) continue;
                file.start = T;
                chainit(flen + 0x3F >> 6);
              }
              while (o.l & 0x1FF) {
                o.write_shift(-4, consts.ENDOFCHAIN);
              }
              for (i = 0; i < L[4] << 2; ++i) {
                var nm = cfb.FullPaths[i];
                if (!nm || nm.length === 0) {
                  for (j = 0; j < 17; ++j) {
                    o.write_shift(4, 0);
                  }
                  for (j = 0; j < 3; ++j) {
                    o.write_shift(4, -1);
                  }
                  for (j = 0; j < 12; ++j) {
                    o.write_shift(4, 0);
                  }
                  continue;
                }
                file = cfb.FileIndex[i];
                if (i === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
                var _nm = i === 0 && _opts.root || file.name;
                if (_nm.length > 32) {
                  console.error("Name " + _nm + " will be truncated to " + _nm.slice(0, 32));
                  _nm = _nm.slice(0, 32);
                }
                flen = 2 * (_nm.length + 1);
                o.write_shift(64, _nm, "utf16le");
                o.write_shift(2, flen);
                o.write_shift(1, file.type);
                o.write_shift(1, file.color);
                o.write_shift(-4, file.L);
                o.write_shift(-4, file.R);
                o.write_shift(-4, file.C);
                if (!file.clsid) for (j = 0; j < 4; ++j) {
                  o.write_shift(4, 0);
                } else o.write_shift(16, file.clsid, "hex");
                o.write_shift(4, file.state || 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, file.start);
                o.write_shift(4, file.size);
                o.write_shift(4, 0);
              }
              for (i = 1; i < cfb.FileIndex.length; ++i) {
                file = cfb.FileIndex[i];
                if (file.size >= 0x1000) {
                  o.l = file.start + 1 << 9;
                  if (has_buf && Buffer.isBuffer(file.content)) {
                    file.content.copy(o, o.l, 0, file.size);
                    // o is a 0-filled Buffer so just set next offset
                    o.l += file.size + 511 & -512;
                  } else {
                    for (j = 0; j < file.size; ++j) {
                      o.write_shift(1, file.content[j]);
                    }
                    for (; j & 0x1FF; ++j) {
                      o.write_shift(1, 0);
                    }
                  }
                }
              }
              for (i = 1; i < cfb.FileIndex.length; ++i) {
                file = cfb.FileIndex[i];
                if (file.size > 0 && file.size < 0x1000) {
                  if (has_buf && Buffer.isBuffer(file.content)) {
                    file.content.copy(o, o.l, 0, file.size);
                    // o is a 0-filled Buffer so just set next offset
                    o.l += file.size + 63 & -64;
                  } else {
                    for (j = 0; j < file.size; ++j) {
                      o.write_shift(1, file.content[j]);
                    }
                    for (; j & 0x3F; ++j) {
                      o.write_shift(1, 0);
                    }
                  }
                }
              }
              if (has_buf) {
                o.l = o.length;
              } else {
                // When using Buffer, already 0-filled
                while (o.l < o.length) {
                  o.write_shift(1, 0);
                }
              }
              return o;
            }
            /* [MS-CFB] 2.6.4 (Unicode 3.0.1 case conversion) */
            function find(cfb, path) {
              var UCFullPaths = cfb.FullPaths.map(function (x) {
                return x.toUpperCase();
              });
              var UCPaths = UCFullPaths.map(function (x) {
                var y = x.split("/");
                return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
              });
              var k = false;
              if (path.charCodeAt(0) === 47 /* "/" */) {
                k = true;
                path = UCFullPaths[0].slice(0, -1) + path;
              } else k = path.indexOf("/") !== -1;
              var UCPath = path.toUpperCase();
              var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
              if (w !== -1) return cfb.FileIndex[w];
              var m = !UCPath.match(chr1);
              UCPath = UCPath.replace(chr0, '');
              if (m) UCPath = UCPath.replace(chr1, '!');
              for (w = 0; w < UCFullPaths.length; ++w) {
                if ((m ? UCFullPaths[w].replace(chr1, '!') : UCFullPaths[w]).replace(chr0, '') == UCPath) return cfb.FileIndex[w];
                if ((m ? UCPaths[w].replace(chr1, '!') : UCPaths[w]).replace(chr0, '') == UCPath) return cfb.FileIndex[w];
              }
              return null;
            }
            /** CFB Constants */
            var MSSZ = 64; /* Mini Sector Size = 1<<6 */
            //var MSCSZ = 4096; /* Mini Stream Cutoff Size */
            /* 2.1 Compound File Sector Numbers and Types */
            var ENDOFCHAIN = -2;
            /* 2.2 Compound File Header */
            var HEADER_SIGNATURE = 'd0cf11e0a1b11ae1';
            var HEADER_SIG = [0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];
            var HEADER_CLSID = '00000000000000000000000000000000';
            var consts = {
              /* 2.1 Compund File Sector Numbers and Types */
              MAXREGSECT: -6,
              DIFSECT: -4,
              FATSECT: -3,
              ENDOFCHAIN: ENDOFCHAIN,
              FREESECT: -1,
              /* 2.2 Compound File Header */
              HEADER_SIGNATURE: HEADER_SIGNATURE,
              HEADER_MINOR_VERSION: '3e00',
              MAXREGSID: -6,
              NOSTREAM: -1,
              HEADER_CLSID: HEADER_CLSID,
              /* 2.6.1 Compound File Directory Entry */
              EntryTypes: ['unknown', 'storage', 'stream', 'lockbytes', 'property', 'root']
            };
            function write_file(cfb, filename, options) {
              get_fs();
              var o = _write(cfb, options);
              fs.writeFileSync(filename, o);
            }
            function a2s(o) {
              var out = new Array(o.length);
              for (var i = 0; i < o.length; ++i) {
                out[i] = String.fromCharCode(o[i]);
              }
              return out.join("");
            }
            function write(cfb, options) {
              var o = _write(cfb, options);
              switch (options && options.type || "buffer") {
                case "file":
                  get_fs();
                  fs.writeFileSync(options.filename, o);
                  return o;
                case "binary":
                  return typeof o == "string" ? o : a2s(o);
                case "base64":
                  return Base64_encode(typeof o == "string" ? o : a2s(o));
                case "buffer":
                  if (has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);
                /* falls through */
                case "array":
                  return typeof o == "string" ? s2a(o) : o;
              }
              return o;
            }
            /* node < 8.1 zlib does not expose bytesRead, so default to pure JS */
            var _zlib;
            function use_zlib(zlib) {
              try {
                var InflateRaw = zlib.InflateRaw;
                var InflRaw = new InflateRaw();
                InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
                if (InflRaw.bytesRead) _zlib = zlib;else throw new Error("zlib does not expose bytesRead");
              } catch (e) {
                console.error("cannot use native zlib: " + (e.message || e));
              }
            }
            function _inflateRawSync(payload, usz) {
              if (!_zlib) return _inflate(payload, usz);
              var InflateRaw = _zlib.InflateRaw;
              var InflRaw = new InflateRaw();
              var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
              payload.l += InflRaw.bytesRead;
              return out;
            }
            function _deflateRawSync(payload) {
              return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
            }
            var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

            /*  LEN_ID = [ 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285 ]; */
            var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];

            /*  DST_ID = [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  14,  15,  16,  17,  18,  19,   20,   21,   22,   23,   24,   25,   26,    27,    28,    29 ]; */
            var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
            function bit_swap_8(n) {
              var t = (n << 1 | n << 11) & 0x22110 | (n << 5 | n << 15) & 0x88440;
              return (t >> 16 | t >> 8 | t) & 0xFF;
            }
            var use_typed_arrays = typeof Uint8Array !== 'undefined';
            var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
            for (var q = 0; q < 1 << 8; ++q) {
              bitswap8[q] = bit_swap_8(q);
            }
            function bit_swap_n(n, b) {
              var rev = bitswap8[n & 0xFF];
              if (b <= 8) return rev >>> 8 - b;
              rev = rev << 8 | bitswap8[n >> 8 & 0xFF];
              if (b <= 16) return rev >>> 16 - b;
              rev = rev << 8 | bitswap8[n >> 16 & 0xFF];
              return rev >>> 24 - b;
            }

            /* helpers for unaligned bit reads */
            function read_bits_2(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 0x03;
            }
            function read_bits_3(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 0x07;
            }
            function read_bits_4(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 0x0F;
            }
            function read_bits_5(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 0x1F;
            }
            function read_bits_7(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 0x7F;
            }

            /* works up to n = 3 * 8 + 1 = 25 */
            function read_bits_n(buf, bl, n) {
              var w = bl & 7,
                h = bl >>> 3,
                f = (1 << n) - 1;
              var v = buf[h] >>> w;
              if (n < 8 - w) return v & f;
              v |= buf[h + 1] << 8 - w;
              if (n < 16 - w) return v & f;
              v |= buf[h + 2] << 16 - w;
              if (n < 24 - w) return v & f;
              v |= buf[h + 3] << 24 - w;
              return v & f;
            }

            /* helpers for unaligned bit writes */
            function write_bits_3(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              if (w <= 5) buf[h] |= (v & 7) << w;else {
                buf[h] |= v << w & 0xFF;
                buf[h + 1] = (v & 7) >> 8 - w;
              }
              return bl + 3;
            }
            function write_bits_1(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              v = (v & 1) << w;
              buf[h] |= v;
              return bl + 1;
            }
            function write_bits_8(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              v <<= w;
              buf[h] |= v & 0xFF;
              v >>>= 8;
              buf[h + 1] = v;
              return bl + 8;
            }
            function write_bits_16(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              v <<= w;
              buf[h] |= v & 0xFF;
              v >>>= 8;
              buf[h + 1] = v & 0xFF;
              buf[h + 2] = v >>> 8;
              return bl + 16;
            }

            /* until ArrayBuffer#realloc is a thing, fake a realloc */
            function realloc(b, sz) {
              var L = b.length,
                M = 2 * L > sz ? 2 * L : sz + 5,
                i = 0;
              if (L >= sz) return b;
              if (has_buf) {
                var o = new_unsafe_buf(M);
                // $FlowIgnore
                if (b.copy) b.copy(o);else for (; i < b.length; ++i) {
                  o[i] = b[i];
                }
                return o;
              } else if (use_typed_arrays) {
                var a = new Uint8Array(M);
                if (a.set) a.set(b);else for (; i < L; ++i) {
                  a[i] = b[i];
                }
                return a;
              }
              b.length = M;
              return b;
            }

            /* zero-filled arrays for older browsers */
            function zero_fill_array(n) {
              var o = new Array(n);
              for (var i = 0; i < n; ++i) {
                o[i] = 0;
              }
              return o;
            }

            /* build tree (used for literals and lengths) */
            function build_tree(clens, cmap, MAX) {
              var maxlen = 1,
                w = 0,
                i = 0,
                j = 0,
                ccode = 0,
                L = clens.length;
              var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
              for (i = 0; i < 32; ++i) {
                bl_count[i] = 0;
              }
              for (i = L; i < MAX; ++i) {
                clens[i] = 0;
              }
              L = clens.length;
              var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L); // []

              /* build code tree */
              for (i = 0; i < L; ++i) {
                bl_count[w = clens[i]]++;
                if (maxlen < w) maxlen = w;
                ctree[i] = 0;
              }
              bl_count[0] = 0;
              for (i = 1; i <= maxlen; ++i) {
                bl_count[i + 16] = ccode = ccode + bl_count[i - 1] << 1;
              }
              for (i = 0; i < L; ++i) {
                ccode = clens[i];
                if (ccode != 0) ctree[i] = bl_count[ccode + 16]++;
              }

              /* cmap[maxlen + 4 bits] = (off&15) + (lit<<4) reverse mapping */
              var cleni = 0;
              for (i = 0; i < L; ++i) {
                cleni = clens[i];
                if (cleni != 0) {
                  ccode = bit_swap_n(ctree[i], maxlen) >> maxlen - cleni;
                  for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j) {
                    cmap[ccode | j << cleni] = cleni & 15 | i << 4;
                  }
                }
              }
              return maxlen;
            }

            /* Fixed Huffman */
            var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
            var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
            if (!use_typed_arrays) {
              for (var i = 0; i < 512; ++i) {
                fix_lmap[i] = 0;
              }
              for (i = 0; i < 32; ++i) {
                fix_dmap[i] = 0;
              }
            }
            (function () {
              var dlens = [];
              var i = 0;
              for (; i < 32; i++) {
                dlens.push(5);
              }
              build_tree(dlens, fix_dmap, 32);
              var clens = [];
              i = 0;
              for (; i <= 143; i++) {
                clens.push(8);
              }
              for (; i <= 255; i++) {
                clens.push(9);
              }
              for (; i <= 279; i++) {
                clens.push(7);
              }
              for (; i <= 287; i++) {
                clens.push(8);
              }
              build_tree(clens, fix_lmap, 288);
            })();
            var _deflateRaw = function _deflateRawIIFE() {
              var DST_LN_RE = use_typed_arrays ? new Uint8Array(0x8000) : [];
              var j = 0,
                k = 0;
              for (; j < DST_LN.length - 1; ++j) {
                for (; k < DST_LN[j + 1]; ++k) {
                  DST_LN_RE[k] = j;
                }
              }
              for (; k < 32768; ++k) {
                DST_LN_RE[k] = 29;
              }
              var LEN_LN_RE = use_typed_arrays ? new Uint8Array(0x103) : [];
              for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
                for (; k < LEN_LN[j + 1]; ++k) {
                  LEN_LN_RE[k] = j;
                }
              }
              function write_stored(data, out) {
                var boff = 0;
                while (boff < data.length) {
                  var L = Math.min(0xFFFF, data.length - boff);
                  var h = boff + L == data.length;
                  out.write_shift(1, +h);
                  out.write_shift(2, L);
                  out.write_shift(2, ~L & 0xFFFF);
                  while (L-- > 0) {
                    out[out.l++] = data[boff++];
                  }
                }
                return out.l;
              }

              /* Fixed Huffman */
              function write_huff_fixed(data, out) {
                var bl = 0;
                var boff = 0;
                var addrs = use_typed_arrays ? new Uint16Array(0x8000) : [];
                while (boff < data.length) {
                  var L = /* data.length - boff; */Math.min(0xFFFF, data.length - boff);

                  /* write a stored block for short data */
                  if (L < 10) {
                    bl = write_bits_3(out, bl, +!!(boff + L == data.length)); // jshint ignore:line
                    if (bl & 7) bl += 8 - (bl & 7);
                    out.l = bl / 8 | 0;
                    out.write_shift(2, L);
                    out.write_shift(2, ~L & 0xFFFF);
                    while (L-- > 0) {
                      out[out.l++] = data[boff++];
                    }
                    bl = out.l * 8;
                    continue;
                  }
                  bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2); // jshint ignore:line
                  var hash = 0;
                  while (L-- > 0) {
                    var d = data[boff];
                    hash = (hash << 5 ^ d) & 0x7FFF;
                    var match = -1,
                      mlen = 0;
                    if (match = addrs[hash]) {
                      match |= boff & ~0x7FFF;
                      if (match > boff) match -= 0x8000;
                      if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) {
                        ++mlen;
                      }
                    }
                    if (mlen > 2) {
                      /* Copy Token  */
                      d = LEN_LN_RE[mlen];
                      if (d <= 22) bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;else {
                        write_bits_8(out, bl, 3);
                        bl += 5;
                        write_bits_8(out, bl, bitswap8[d - 23] >> 5);
                        bl += 3;
                      }
                      var len_eb = d < 8 ? 0 : d - 4 >> 2;
                      if (len_eb > 0) {
                        write_bits_16(out, bl, mlen - LEN_LN[d]);
                        bl += len_eb;
                      }
                      d = DST_LN_RE[boff - match];
                      bl = write_bits_8(out, bl, bitswap8[d] >> 3);
                      bl -= 3;
                      var dst_eb = d < 4 ? 0 : d - 2 >> 1;
                      if (dst_eb > 0) {
                        write_bits_16(out, bl, boff - match - DST_LN[d]);
                        bl += dst_eb;
                      }
                      for (var q = 0; q < mlen; ++q) {
                        addrs[hash] = boff & 0x7FFF;
                        hash = (hash << 5 ^ data[boff]) & 0x7FFF;
                        ++boff;
                      }
                      L -= mlen - 1;
                    } else {
                      /* Literal Token */
                      if (d <= 143) d = d + 48;else bl = write_bits_1(out, bl, 1);
                      bl = write_bits_8(out, bl, bitswap8[d]);
                      addrs[hash] = boff & 0x7FFF;
                      ++boff;
                    }
                  }
                  bl = write_bits_8(out, bl, 0) - 1;
                }
                out.l = (bl + 7) / 8 | 0;
                return out.l;
              }
              return function _deflateRaw(data, out) {
                if (data.length < 8) return write_stored(data, out);
                return write_huff_fixed(data, out);
              };
            }();
            function _deflate(data) {
              var buf = new_buf(50 + Math.floor(data.length * 1.1));
              var off = _deflateRaw(data, buf);
              return buf.slice(0, off);
            }
            /* modified inflate function also moves original read head */

            var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
            var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
            var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
            var dyn_len_1 = 1,
              dyn_len_2 = 1;

            /* 5.5.3 Expanding Huffman Codes */
            function dyn(data, boff) {
              /* nomenclature from RFC1951 refers to bit values; these are offset by the implicit constant */
              var _HLIT = read_bits_5(data, boff) + 257;
              boff += 5;
              var _HDIST = read_bits_5(data, boff) + 1;
              boff += 5;
              var _HCLEN = read_bits_4(data, boff) + 4;
              boff += 4;
              var w = 0;

              /* grab and store code lengths */
              var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
              var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              var maxlen = 1;
              var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
              var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
              var L = clens.length; /* 19 */
              for (var i = 0; i < _HCLEN; ++i) {
                clens[CLEN_ORDER[i]] = w = read_bits_3(data, boff);
                if (maxlen < w) maxlen = w;
                bl_count[w]++;
                boff += 3;
              }

              /* build code tree */
              var ccode = 0;
              bl_count[0] = 0;
              for (i = 1; i <= maxlen; ++i) {
                next_code[i] = ccode = ccode + bl_count[i - 1] << 1;
              }
              for (i = 0; i < L; ++i) {
                if ((ccode = clens[i]) != 0) ctree[i] = next_code[ccode]++;
              }
              /* cmap[7 bits from stream] = (off&7) + (lit<<3) */
              var cleni = 0;
              for (i = 0; i < L; ++i) {
                cleni = clens[i];
                if (cleni != 0) {
                  ccode = bitswap8[ctree[i]] >> 8 - cleni;
                  for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) {
                    dyn_cmap[ccode | j << cleni] = cleni & 7 | i << 3;
                  }
                }
              }

              /* read literal and dist codes at once */
              var hcodes = [];
              maxlen = 1;
              for (; hcodes.length < _HLIT + _HDIST;) {
                ccode = dyn_cmap[read_bits_7(data, boff)];
                boff += ccode & 7;
                switch (ccode >>>= 3) {
                  case 16:
                    w = 3 + read_bits_2(data, boff);
                    boff += 2;
                    ccode = hcodes[hcodes.length - 1];
                    while (w-- > 0) {
                      hcodes.push(ccode);
                    }
                    break;
                  case 17:
                    w = 3 + read_bits_3(data, boff);
                    boff += 3;
                    while (w-- > 0) {
                      hcodes.push(0);
                    }
                    break;
                  case 18:
                    w = 11 + read_bits_7(data, boff);
                    boff += 7;
                    while (w-- > 0) {
                      hcodes.push(0);
                    }
                    break;
                  default:
                    hcodes.push(ccode);
                    if (maxlen < ccode) maxlen = ccode;
                    break;
                }
              }

              /* build literal / length trees */
              var h1 = hcodes.slice(0, _HLIT),
                h2 = hcodes.slice(_HLIT);
              for (i = _HLIT; i < 286; ++i) {
                h1[i] = 0;
              }
              for (i = _HDIST; i < 30; ++i) {
                h2[i] = 0;
              }
              dyn_len_1 = build_tree(h1, dyn_lmap, 286);
              dyn_len_2 = build_tree(h2, dyn_dmap, 30);
              return boff;
            }

            /* return [ data, bytesRead ] */
            function inflate(data, usz) {
              /* shortcircuit for empty buffer [0x03, 0x00] */
              if (data[0] == 3 && !(data[1] & 0x3)) {
                return [new_raw_buf(usz), 2];
              }

              /* bit offset */
              var boff = 0;

              /* header includes final bit and type bits */
              var header = 0;
              var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
              var woff = 0;
              var OL = outbuf.length >>> 0;
              var max_len_1 = 0,
                max_len_2 = 0;
              while ((header & 1) == 0) {
                header = read_bits_3(data, boff);
                boff += 3;
                if (header >>> 1 == 0) {
                  /* Stored block */
                  if (boff & 7) boff += 8 - (boff & 7);
                  /* 2 bytes sz, 2 bytes bit inverse */
                  var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
                  boff += 32;
                  /* push sz bytes */
                  if (sz > 0) {
                    if (!usz && OL < woff + sz) {
                      outbuf = realloc(outbuf, woff + sz);
                      OL = outbuf.length;
                    }
                    while (sz-- > 0) {
                      outbuf[woff++] = data[boff >>> 3];
                      boff += 8;
                    }
                  }
                  continue;
                } else if (header >> 1 == 1) {
                  /* Fixed Huffman */
                  max_len_1 = 9;
                  max_len_2 = 5;
                } else {
                  /* Dynamic Huffman */
                  boff = dyn(data, boff);
                  max_len_1 = dyn_len_1;
                  max_len_2 = dyn_len_2;
                }
                for (;;) {
                  // while(true) is apparently out of vogue in modern JS circles
                  if (!usz && OL < woff + 32767) {
                    outbuf = realloc(outbuf, woff + 32767);
                    OL = outbuf.length;
                  }
                  /* ingest code and move read head */
                  var bits = read_bits_n(data, boff, max_len_1);
                  var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
                  boff += code & 15;
                  code >>>= 4;
                  /* 0-255 are literals, 256 is end of block token, 257+ are copy tokens */
                  if ((code >>> 8 & 0xFF) === 0) outbuf[woff++] = code;else if (code == 256) break;else {
                    code -= 257;
                    var len_eb = code < 8 ? 0 : code - 4 >> 2;
                    if (len_eb > 5) len_eb = 0;
                    var tgt = woff + LEN_LN[code];
                    /* length extra bits */
                    if (len_eb > 0) {
                      tgt += read_bits_n(data, boff, len_eb);
                      boff += len_eb;
                    }

                    /* dist code */
                    bits = read_bits_n(data, boff, max_len_2);
                    code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
                    boff += code & 15;
                    code >>>= 4;
                    var dst_eb = code < 4 ? 0 : code - 2 >> 1;
                    var dst = DST_LN[code];
                    /* dist extra bits */
                    if (dst_eb > 0) {
                      dst += read_bits_n(data, boff, dst_eb);
                      boff += dst_eb;
                    }

                    /* in the common case, manual byte copy is faster than TA set / Buffer copy */
                    if (!usz && OL < tgt) {
                      outbuf = realloc(outbuf, tgt + 100);
                      OL = outbuf.length;
                    }
                    while (woff < tgt) {
                      outbuf[woff] = outbuf[woff - dst];
                      ++woff;
                    }
                  }
                }
              }
              if (usz) return [outbuf, boff + 7 >>> 3];
              return [outbuf.slice(0, woff), boff + 7 >>> 3];
            }
            function _inflate(payload, usz) {
              var data = payload.slice(payload.l || 0);
              var out = inflate(data, usz);
              payload.l += out[1];
              return out[0];
            }
            function warn_or_throw(wrn, msg) {
              if (wrn) {
                if (typeof console !== 'undefined') console.error(msg);
              } else throw new Error(msg);
            }
            function parse_zip(file, options) {
              var blob = file;
              prep_blob(blob, 0);
              var FileIndex = [],
                FullPaths = [];
              var o = {
                FileIndex: FileIndex,
                FullPaths: FullPaths
              };
              init_cfb(o, {
                root: options.root
              });

              /* find end of central directory, start just after signature */
              var i = blob.length - 4;
              while ((blob[i] != 0x50 || blob[i + 1] != 0x4b || blob[i + 2] != 0x05 || blob[i + 3] != 0x06) && i >= 0) {
                --i;
              }
              blob.l = i + 4;

              /* parse end of central directory */
              blob.l += 4;
              var fcnt = blob.read_shift(2);
              blob.l += 6;
              var start_cd = blob.read_shift(4);

              /* parse central directory */
              blob.l = start_cd;
              for (i = 0; i < fcnt; ++i) {
                /* trust local file header instead of CD entry */
                blob.l += 20;
                var csz = blob.read_shift(4);
                var usz = blob.read_shift(4);
                var namelen = blob.read_shift(2);
                var efsz = blob.read_shift(2);
                var fcsz = blob.read_shift(2);
                blob.l += 8;
                var offset = blob.read_shift(4);
                var EF = parse_extra_field(blob.slice(blob.l + namelen, blob.l + namelen + efsz));
                blob.l += namelen + efsz + fcsz;
                var L = blob.l;
                blob.l = offset + 4;
                parse_local_file(blob, csz, usz, o, EF);
                blob.l = L;
              }
              return o;
            }

            /* head starts just after local file header signature */
            function parse_local_file(blob, csz, usz, o, EF) {
              /* [local file header] */
              blob.l += 2;
              var flags = blob.read_shift(2);
              var meth = blob.read_shift(2);
              var date = parse_dos_date(blob);
              if (flags & 0x2041) throw new Error("Unsupported ZIP encryption");
              var crc32 = blob.read_shift(4);
              var _csz = blob.read_shift(4);
              var _usz = blob.read_shift(4);
              var namelen = blob.read_shift(2);
              var efsz = blob.read_shift(2);

              // TODO: flags & (1<<11) // UTF8
              var name = "";
              for (var i = 0; i < namelen; ++i) {
                name += String.fromCharCode(blob[blob.l++]);
              }
              if (efsz) {
                var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));
                if ((ef[0x5455] || {}).mt) date = ef[0x5455].mt;
                if (((EF || {})[0x5455] || {}).mt) date = EF[0x5455].mt;
              }
              blob.l += efsz;

              /* [encryption header] */

              /* [file data] */
              var data = blob.slice(blob.l, blob.l + _csz);
              switch (meth) {
                case 8:
                  data = _inflateRawSync(blob, _usz);
                  break;
                case 0:
                  break;
                // TODO: scan for magic number
                default:
                  throw new Error("Unsupported ZIP Compression method " + meth);
              }

              /* [data descriptor] */
              var wrn = false;
              if (flags & 8) {
                crc32 = blob.read_shift(4);
                if (crc32 == 0x08074b50) {
                  crc32 = blob.read_shift(4);
                  wrn = true;
                }
                _csz = blob.read_shift(4);
                _usz = blob.read_shift(4);
              }
              if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
              if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
              var _crc32 = CRC32.buf(data, 0);
              if (crc32 >> 0 != _crc32 >> 0) warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);
              cfb_add(o, name, data, {
                unsafe: true,
                mt: date
              });
            }
            function write_zip(cfb, options) {
              var _opts = options || {};
              var out = [],
                cdirs = [];
              var o = new_buf(1);
              var method = _opts.compression ? 8 : 0,
                flags = 0;
              var desc = false;
              if (desc) flags |= 8;
              var i = 0,
                j = 0;
              var start_cd = 0,
                fcnt = 0;
              var root = cfb.FullPaths[0],
                fp = root,
                fi = cfb.FileIndex[0];
              var crcs = [];
              var sz_cd = 0;
              for (i = 1; i < cfb.FullPaths.length; ++i) {
                fp = cfb.FullPaths[i].slice(root.length);
                fi = cfb.FileIndex[i];
                if (!fi.size || !fi.content || fp == "\x01Sh33tJ5") continue;
                var start = start_cd;

                /* TODO: CP437 filename */
                var namebuf = new_buf(fp.length);
                for (j = 0; j < fp.length; ++j) {
                  namebuf.write_shift(1, fp.charCodeAt(j) & 0x7F);
                }
                namebuf = namebuf.slice(0, namebuf.l);
                crcs[fcnt] = CRC32.buf(fi.content, 0);
                var outbuf = fi.content;
                if (method == 8) outbuf = _deflateRawSync(outbuf);

                /* local file header */
                o = new_buf(30);
                o.write_shift(4, 0x04034b50);
                o.write_shift(2, 20);
                o.write_shift(2, flags);
                o.write_shift(2, method);
                /* TODO: last mod file time/date */
                if (fi.mt) write_dos_date(o, fi.mt);else o.write_shift(4, 0);
                o.write_shift(-4, flags & 8 ? 0 : crcs[fcnt]);
                o.write_shift(4, flags & 8 ? 0 : outbuf.length);
                o.write_shift(4, flags & 8 ? 0 : fi.content.length);
                o.write_shift(2, namebuf.length);
                o.write_shift(2, 0);
                start_cd += o.length;
                out.push(o);
                start_cd += namebuf.length;
                out.push(namebuf);

                /* TODO: extra fields? */

                /* TODO: encryption header ? */

                start_cd += outbuf.length;
                out.push(outbuf);

                /* data descriptor */
                if (flags & 8) {
                  o = new_buf(12);
                  o.write_shift(-4, crcs[fcnt]);
                  o.write_shift(4, outbuf.length);
                  o.write_shift(4, fi.content.length);
                  start_cd += o.l;
                  out.push(o);
                }

                /* central directory */
                o = new_buf(46);
                o.write_shift(4, 0x02014b50);
                o.write_shift(2, 0);
                o.write_shift(2, 20);
                o.write_shift(2, flags);
                o.write_shift(2, method);
                o.write_shift(4, 0); /* TODO: last mod file time/date */
                o.write_shift(-4, crcs[fcnt]);
                o.write_shift(4, outbuf.length);
                o.write_shift(4, fi.content.length);
                o.write_shift(2, namebuf.length);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(4, 0);
                o.write_shift(4, start);
                sz_cd += o.l;
                cdirs.push(o);
                sz_cd += namebuf.length;
                cdirs.push(namebuf);
                ++fcnt;
              }

              /* end of central directory */
              o = new_buf(22);
              o.write_shift(4, 0x06054b50);
              o.write_shift(2, 0);
              o.write_shift(2, 0);
              o.write_shift(2, fcnt);
              o.write_shift(2, fcnt);
              o.write_shift(4, sz_cd);
              o.write_shift(4, start_cd);
              o.write_shift(2, 0);
              return bconcat([bconcat(out), bconcat(cdirs), o]);
            }
            var ContentTypeMap = {
              "htm": "text/html",
              "xml": "text/xml",
              "gif": "image/gif",
              "jpg": "image/jpeg",
              "png": "image/png",
              "mso": "application/x-mso",
              "thmx": "application/vnd.ms-officetheme",
              "sh33tj5": "application/octet-stream"
            };
            function get_content_type(fi, fp) {
              if (fi.ctype) return fi.ctype;
              var ext = fi.name || "",
                m = ext.match(/\.([^\.]+)$/);
              if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
              if (fp) {
                m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
                if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
              }
              return "application/octet-stream";
            }

            /* 76 character chunks TODO: intertwine encoding */
            function write_base64_76(bstr) {
              var data = Base64_encode(bstr);
              var o = [];
              for (var i = 0; i < data.length; i += 76) {
                o.push(data.slice(i, i + 76));
              }
              return o.join("\r\n") + "\r\n";
            }

            /*
            Rules for QP:
            	- escape =## applies for all non-display characters and literal "="
            	- space or tab at end of line must be encoded
            	- \r\n newlines can be preserved, but bare \r and \n must be escaped
            	- lines must not exceed 76 characters, use soft breaks =\r\n
            
            TODO: Some files from word appear to write line extensions with bare equals:
            
            ```
            <table class=3DMsoTableGrid border=3D1 cellspacing=3D0 cellpadding=3D0 width=
            ="70%"
            ```
            */
            function write_quoted_printable(text) {
              var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function (c) {
                var w = c.charCodeAt(0).toString(16).toUpperCase();
                return "=" + (w.length == 1 ? "0" + w : w);
              });
              encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
              if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
              encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
              var o = [],
                split = encoded.split("\r\n");
              for (var si = 0; si < split.length; ++si) {
                var str = split[si];
                if (str.length == 0) {
                  o.push("");
                  continue;
                }
                for (var i = 0; i < str.length;) {
                  var end = 76;
                  var tmp = str.slice(i, i + end);
                  if (tmp.charAt(end - 1) == "=") end--;else if (tmp.charAt(end - 2) == "=") end -= 2;else if (tmp.charAt(end - 3) == "=") end -= 3;
                  tmp = str.slice(i, i + end);
                  i += end;
                  if (i < str.length) tmp += "=";
                  o.push(tmp);
                }
              }
              return o.join("\r\n");
            }
            function parse_quoted_printable(data) {
              var o = [];

              /* unify long lines */
              for (var di = 0; di < data.length; ++di) {
                var line = data[di];
                while (di <= data.length && line.charAt(line.length - 1) == "=") {
                  line = line.slice(0, line.length - 1) + data[++di];
                }
                o.push(line);
              }

              /* decode */
              for (var oi = 0; oi < o.length; ++oi) {
                o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function ($$) {
                  return String.fromCharCode(parseInt($$.slice(1), 16));
                });
              }
              return s2a(o.join("\r\n"));
            }
            function parse_mime(cfb, data, root) {
              var fname = "",
                cte = "",
                ctype = "",
                fdata;
              var di = 0;
              for (; di < 10; ++di) {
                var line = data[di];
                if (!line || line.match(/^\s*$/)) break;
                var m = line.match(/^(.*?):\s*([^\s].*)$/);
                if (m) switch (m[1].toLowerCase()) {
                  case "content-location":
                    fname = m[2].trim();
                    break;
                  case "content-type":
                    ctype = m[2].trim();
                    break;
                  case "content-transfer-encoding":
                    cte = m[2].trim();
                    break;
                }
              }
              ++di;
              switch (cte.toLowerCase()) {
                case 'base64':
                  fdata = s2a(Base64_decode(data.slice(di).join("")));
                  break;
                case 'quoted-printable':
                  fdata = parse_quoted_printable(data.slice(di));
                  break;
                default:
                  throw new Error("Unsupported Content-Transfer-Encoding " + cte);
              }
              var file = cfb_add(cfb, fname.slice(root.length), fdata, {
                unsafe: true
              });
              if (ctype) file.ctype = ctype;
            }
            function parse_mad(file, options) {
              if (a2s(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
              var root = options && options.root || "";
              // $FlowIgnore
              var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s(file)).split("\r\n");
              var di = 0,
                row = "";

              /* if root is not specified, scan for the common prefix */
              for (di = 0; di < data.length; ++di) {
                row = data[di];
                if (!/^Content-Location:/i.test(row)) continue;
                row = row.slice(row.indexOf("file"));
                if (!root) root = row.slice(0, row.lastIndexOf("/") + 1);
                if (row.slice(0, root.length) == root) continue;
                while (root.length > 0) {
                  root = root.slice(0, root.length - 1);
                  root = root.slice(0, root.lastIndexOf("/") + 1);
                  if (row.slice(0, root.length) == root) break;
                }
              }
              var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
              if (!mboundary) throw new Error("MAD cannot find boundary");
              var boundary = "--" + (mboundary[1] || "");
              var FileIndex = [],
                FullPaths = [];
              var o = {
                FileIndex: FileIndex,
                FullPaths: FullPaths
              };
              init_cfb(o);
              var start_di,
                fcnt = 0;
              for (di = 0; di < data.length; ++di) {
                var line = data[di];
                if (line !== boundary && line !== boundary + "--") continue;
                if (fcnt++) parse_mime(o, data.slice(start_di, di), root);
                start_di = di;
              }
              return o;
            }
            function write_mad(cfb, options) {
              var opts = options || {};
              var boundary = opts.boundary || "SheetJS";
              boundary = '------=' + boundary;
              var out = ['MIME-Version: 1.0', 'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"', '', '', ''];
              var root = cfb.FullPaths[0],
                fp = root,
                fi = cfb.FileIndex[0];
              for (var i = 1; i < cfb.FullPaths.length; ++i) {
                fp = cfb.FullPaths[i].slice(root.length);
                fi = cfb.FileIndex[i];
                if (!fi.size || !fi.content || fp == "\x01Sh33tJ5") continue;

                /* Normalize filename */
                fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function (c) {
                  return "_x" + c.charCodeAt(0).toString(16) + "_";
                }).replace(/[\u0080-\uFFFF]/g, function (u) {
                  return "_u" + u.charCodeAt(0).toString(16) + "_";
                });

                /* Extract content as binary string */
                var ca = fi.content;
                // $FlowIgnore
                var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s(ca);

                /* 4/5 of first 1024 chars ascii -> quoted printable, else base64 */
                var dispcnt = 0,
                  L = Math.min(1024, cstr.length),
                  cc = 0;
                for (var csl = 0; csl <= L; ++csl) {
                  if ((cc = cstr.charCodeAt(csl)) >= 0x20 && cc < 0x80) ++dispcnt;
                }
                var qp = dispcnt >= L * 4 / 5;
                out.push(boundary);
                out.push('Content-Location: ' + (opts.root || 'file:///C:/SheetJS/') + fp);
                out.push('Content-Transfer-Encoding: ' + (qp ? 'quoted-printable' : 'base64'));
                out.push('Content-Type: ' + get_content_type(fi, fp));
                out.push('');
                out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
              }
              out.push(boundary + '--\r\n');
              return out.join("\r\n");
            }
            function cfb_new(opts) {
              var o = {};
              init_cfb(o, opts);
              return o;
            }
            function cfb_add(cfb, name, content, opts) {
              var unsafe = opts && opts.unsafe;
              if (!unsafe) init_cfb(cfb);
              var file = !unsafe && CFB.find(cfb, name);
              if (!file) {
                var fpath = cfb.FullPaths[0];
                if (name.slice(0, fpath.length) == fpath) fpath = name;else {
                  if (fpath.slice(-1) != "/") fpath += "/";
                  fpath = (fpath + name).replace("//", "/");
                }
                file = {
                  name: filename(name),
                  type: 2
                };
                cfb.FileIndex.push(file);
                cfb.FullPaths.push(fpath);
                if (!unsafe) CFB.utils.cfb_gc(cfb);
              }
              file.content = content;
              file.size = content ? content.length : 0;
              if (opts) {
                if (opts.CLSID) file.clsid = opts.CLSID;
                if (opts.mt) file.mt = opts.mt;
                if (opts.ct) file.ct = opts.ct;
              }
              return file;
            }
            function cfb_del(cfb, name) {
              init_cfb(cfb);
              var file = CFB.find(cfb, name);
              if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) {
                if (cfb.FileIndex[j] == file) {
                  cfb.FileIndex.splice(j, 1);
                  cfb.FullPaths.splice(j, 1);
                  return true;
                }
              }
              return false;
            }
            function cfb_mov(cfb, old_name, new_name) {
              init_cfb(cfb);
              var file = CFB.find(cfb, old_name);
              if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) {
                if (cfb.FileIndex[j] == file) {
                  cfb.FileIndex[j].name = filename(new_name);
                  cfb.FullPaths[j] = new_name;
                  return true;
                }
              }
              return false;
            }
            function cfb_gc(cfb) {
              rebuild_cfb(cfb, true);
            }
            exports.find = find;
            exports.read = read;
            exports.parse = parse;
            exports.write = write;
            exports.writeFile = write_file;
            exports.utils = {
              cfb_new: cfb_new,
              cfb_add: cfb_add,
              cfb_del: cfb_del,
              cfb_mov: cfb_mov,
              cfb_gc: cfb_gc,
              ReadShift: ReadShift,
              CheckField: CheckField,
              prep_blob: prep_blob,
              bconcat: bconcat,
              use_zlib: use_zlib,
              _deflateRaw: _deflate,
              _inflateRaw: _inflate,
              consts: consts
            };
            return exports;
          }();
          if (typeof require !== 'undefined' && typeof module !== 'undefined' && typeof DO_NOT_EXPORT_CFB === 'undefined') {
            module.exports = CFB;
          }
        }).call(this);
      }).call(this, require('_process'), require("buffer").Buffer);
    }, {
      "_process": 36,
      "buffer": 7,
      "fs": 5
    }],
    9: [function (require, module, exports) {
      module.exports = require('./lib/eml-format.js');
    }, {
      "./lib/eml-format.js": 10
    }],
    10: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          /******************************************************************************************
           * EML format parser. EML is raw e-mail message header + body as returned by POP3 protocol.
           * RFC 822: http://www.ietf.org/rfc/rfc0822.txt
           * RFC 1521: https://www.ietf.org/rfc/rfc1521.txt
           ******************************************************************************************/

          var iconv = require('iconv-lite');

          //Default character set
          var defaultCharset = 'utf-8'; //to use if charset=... is missing

          //Gets the character encoding name for iconv, e.g. 'iso-8859-2' -> 'iso88592'
          function getCharsetName(charset) {
            return charset.toLowerCase().replace(/[^0-9a-z]/g, "");
          }

          //Generates a random id
          function guid() {
            return 'xxxxxxxxxxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
              var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : r & 0x3 | 0x8;
              return v.toString(16);
            }).replace("-", "");
          }

          //Word-wrap the string 's' to 'i' chars per row
          function wrap(s, i) {
            var a = [];
            do {
              a.push(s.substring(0, i));
            } while ((s = s.substring(i, s.length)) != "");
            return a.join("\r\n");
          }

          //Overridable properties and functions
          var emlformat = {
            verbose: false,
            fileExtensions: {
              "text/plain": ".txt",
              "text/html": ".html",
              "image/png": ".png",
              "image/jpg": ".jpg",
              "image/jpeg": ".jpg"
            },
            //Gets file extension by mime type
            getFileExtension: function getFileExtension(mimeType) {
              return emlformat.fileExtensions[mimeType] || "";
            },
            //Gets the boundary name
            getBoundary: function getBoundary(contentType) {
              var match = /boundary="?(.+?)"?(\s*;[\s\S]*)?$/g.exec(contentType);
              return match ? match[1] : undefined;
            },
            //Gets character set name, e.g. contentType='.....charset="iso-8859-2"....'
            getCharset: function getCharset(contentType) {
              var match = /charset\s*=\W*([\w\-]+)/g.exec(contentType);
              return match ? match[1] : undefined;
            },
            //Gets name and e-mail address from a string, e.g. "PayPal" <noreply@paypal.com> => { name: "PayPal", email: "noreply@paypal.com" }
            getEmailAddress: function getEmailAddress(raw) {
              var list = [];

              //Split around ',' char
              //var parts = raw.split(/,/g); //Will also split ',' inside the quotes
              //var parts = raw.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g); //Ignore ',' within the double quotes
              var parts = raw.match(/("[^"]*")|[^,]+/g); //Ignore ',' within the double quotes

              for (var i = 0; i < parts.length; i++) {
                var address = {};

                //Quoted name but without the e-mail address
                if (/^".*"$/g.test(parts[i])) {
                  address.name = emlformat.unquoteString(parts[i]).replace(/"/g, "").trim();
                  i++; //Shift to another part to capture e-mail address
                }

                var regex = /^(.*?)(\s*\<(.*?)\>)$/g;
                var match = regex.exec(parts[i]);
                if (match) {
                  var name = emlformat.unquoteString(match[1]).replace(/"/g, "").trim();
                  if (name && name.length) {
                    address.name = name;
                  }
                  address.email = match[3].trim();
                  list.push(address);
                } else {
                  //E-mail address only (without the name)
                  address.email = parts[i].trim();
                  list.push(address);
                }
              }

              //Return result
              if (list.length == 0) {
                return null; //No e-mail address
              }

              if (list.length == 1) {
                return list[0]; //Only one record, return as object, required to preserve backward compatibility
              }

              return list; //Multiple e-mail addresses as array
            },

            //Builds e-mail address string, e.g. { name: "PayPal", email: "noreply@paypal.com" } => "PayPal" <noreply@paypal.com>
            toEmailAddress: function toEmailAddress(data) {
              var email = "";
              if (typeof data == "undefined") {
                //No e-mail address
              } else if (typeof data == "string") {
                email = data;
              } else if (_typeof(data) == "object") {
                if (Array.isArray(data)) {
                  for (var i = 0; i < data.length; i++) {
                    email += email.length ? ', ' : '';
                    if (data[i].name) {
                      email += '"' + data[i].name + '"';
                    }
                    if (data[i].email) {
                      email += (email.length ? ' ' : '') + '<' + data[i].email + '>';
                    }
                  }
                } else {
                  if (data.name) {
                    email += '"' + data.name + '"';
                  }
                  if (data.email) {
                    email += (email.length ? ' ' : '') + '<' + data.email + '>';
                  }
                }
              }
              return email;
            },
            //Decodes string by detecting the charset
            unquoteString: function unquoteString(s) {
              var regex = /=\?([^?]+)\?(B|Q)\?(.+?)(\?=)/gi;
              var match = regex.exec(s);
              if (match) {
                var charset = getCharsetName(match[1] || defaultCharset); //eq. match[1] = 'iso-8859-2'; charset = 'iso88592'
                var type = match[2].toUpperCase();
                var value = match[3];
                if (type == "B") {
                  //Base64
                  if (charset == "utf8") {
                    return Buffer.from(value.replace(/\r?\n/g, ""), "base64").toString("utf8");
                  } else {
                    return iconv.decode(Buffer.from(value.replace(/\r?\n/g, ""), "base64"), charset);
                  }
                } else if (type == "Q") {
                  //Quoted printable
                  return emlformat.unquotePrintable(value, charset);
                }
              }
              return s;
            },
            //Decodes string like =?UTF-8?B?V2hhdOKAmXMgeW91ciBvbmxpbmUgc2hvcHBpbmcgc3R5bGU/?= or =?UTF-8?Q?...?=
            unquoteUTF8: function unquoteUTF8(s) {
              var regex = /=\?UTF\-8\?(B|Q)\?(.+?)(\?=)/gi;
              var match = regex.exec(s);
              if (match) {
                var type = match[1].toUpperCase();
                var value = match[2];
                if (type == "B") {
                  //Base64
                  return Buffer.from(value.replace(/\r?\n/g, ""), "base64").toString("utf8");
                } else if (type == "Q") {
                  //Quoted printable
                  return emlformat.unquotePrintable(value);
                }
              }
              return s;
            },
            //Decodes "quoted-printable"
            unquotePrintable: function unquotePrintable(s, charset) {
              //Convert =0D to '\r', =20 to ' ', etc.
              if (!charset || charset == "utf8" || charset == "utf-8") {
                return s.replace(/=([\w\d]{2})=([\w\d]{2})=([\w\d]{2})/gi, function (matcher, p1, p2, p3, offset, string) {
                  return Buffer.from([parseInt(p1, 16), parseInt(p2, 16), parseInt(p3, 16)]).toString("utf8");
                }).replace(/=([\w\d]{2})=([\w\d]{2})/gi, function (matcher, p1, p2, offset, string) {
                  return Buffer.from([parseInt(p1, 16), parseInt(p2, 16)]).toString("utf8");
                }).replace(/=([\w\d]{2})/gi, function (matcher, p1, offset, string) {
                  return String.fromCharCode(parseInt(p1, 16));
                }).replace(/=\r?\n/gi, ""); //Join line
              } else {
                return s.replace(/=([\w\d]{2})=([\w\d]{2})/gi, function (matcher, p1, p2, offset, string) {
                  return iconv.decode(Buffer.from([parseInt(p1, 16), parseInt(p2, 16)]), charset);
                }).replace(/=([\w\d]{2})/gi, function (matcher, p1, offset, string) {
                  return iconv.decode(Buffer.from([parseInt(p1, 16)]), charset);
                }).replace(/=\r?\n/gi, ""); //Join line
              }
            }
          };

          /******************************************************************************************
           * Unpacks EML message and attachments to a directory.
           * @params eml         EML file content or object from 'parse'
           * @params directory   Folder name or directory path where to unpack
           * @params options     Optional parameters: { parsedJsonFile, readJsonFile, simulate }
           * @params callback    Callback function(error)
           ******************************************************************************************/
          emlformat.unpack = function (eml, directory, options, callback) {
            var fs = require("fs");
            var path = require("path");

            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            var result = {
              files: []
            };
            function _unpack(data) {
              try {
                //Create the target directory
                if (!fs.existsSync(directory)) {
                  fs.mkdirSync(directory);
                }

                //Plain text file
                if (typeof data.text == "string") {
                  result.files.push("index.txt");
                  if (options && options.simulate) {
                    //Skip writing to file
                  } else {
                    fs.writeFileSync(path.join(directory, "index.txt"), data.text);
                  }
                }

                //Message in HTML format
                if (typeof data.html == "string") {
                  result.files.push("index.html");
                  if (options && options.simulate) {
                    //Skip writing to file
                  } else {
                    fs.writeFileSync(path.join(directory, "index.html"), data.html);
                  }
                }

                //Attachments
                if (data.attachments && data.attachments.length > 0) {
                  for (var i = 0; i < data.attachments.length; i++) {
                    var attachment = data.attachments[i];
                    var filename = attachment.name;
                    if (!filename) {
                      filename = "attachment_" + (i + 1) + emlformat.getFileExtension(attachment.mimeType);
                    }
                    result.files.push(filename);
                    if (options && options.simulate) continue; //Skip writing to file
                    fs.writeFileSync(path.join(directory, filename), attachment.data);
                  }
                }
                callback(null, result);
              } catch (e) {
                callback(e);
              }
            }

            //Check the directory argument
            if (typeof directory != "string" || directory.length == 0) {
              return callback(new Error("Directory argument is missing!"));
            }

            //Argument as EML file content or "parsed" version of object
            if (typeof eml == "string" || _typeof(eml) == "object" && eml.headers && eml.body) {
              emlformat.parse(eml, function (error, parsed) {
                if (error) return callback(error);

                //Save parsed EML as JSON file
                if (options && options.parsedJsonFile) {
                  var file = path.resolve(directory, options.parsedJsonFile);
                  var dir = path.dirname(file);
                  if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir);
                  }
                  result.files.push(options.parsedJsonFile);
                  fs.writeFileSync(file, JSON.stringify(parsed, " ", 2));
                }

                //Convert parsed EML object to a friendly object with text, html and attachments
                emlformat.read(parsed, function (error, data) {
                  if (error) return callback(error);

                  //Save read structure as JSON file
                  if (options && options.readJsonFile) {
                    var file = path.resolve(directory, options.readJsonFile);
                    var dir = path.dirname(file);
                    if (!fs.existsSync(dir)) {
                      fs.mkdirSync(dir);
                    }
                    result.files.push(options.readJsonFile);
                    var json = data.attachments ? JSON.stringify(data) : JSON.stringify(data, " ", 2); //Attachments may be large, so make a compact JSON string
                    fs.writeFileSync(file, json);
                  }

                  //Extract files from the EML file
                  _unpack(data);
                });
              });
            } else if (_typeof(eml) != "object") {
              return callback(new Error("Expected string or object as argument!"));
            } else {
              _unpack(eml);
            }
          };

          /******************************************************************************************
           * Parses EML file content and return user-friendly object.
           * @params data        EML structure
           * @params options     EML build options
           * @params callback    Callback function(error, data)
           ******************************************************************************************/
          emlformat.build = function (data, options, callback) {
            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            var eml = "";
            var EOL = "\r\n"; //End-of-line

            try {
              if (!data || _typeof(data) != "object") {
                throw new Error("Argument 'data' expected to be an object!");
              }
              if (!data.headers) {
                data.headers = {};
              }
              if (typeof data.subject == "string") {
                data.headers["Subject"] = data.subject;
              }
              if (typeof data.from != "undefined") {
                data.headers["From"] = typeof data.from == "string" ? data.from : emlformat.toEmailAddress(data.from);
              }
              if (typeof data.to != "undefined") {
                data.headers["To"] = typeof data.to == "string" ? data.to : emlformat.toEmailAddress(data.to);
              }
              if (typeof data.cc != "undefined") {
                data.headers["Cc"] = typeof data.cc == "string" ? data.cc : emlformat.toEmailAddress(data.cc);
              }
              if (!data.headers["To"]) {
                throw new Error("Missing 'To' e-mail address!");
              }
              var boundary = "----=" + guid();
              if (typeof data.headers["Content-Type"] == "undefined") {
                data.headers["Content-Type"] = 'multipart/mixed;' + EOL + 'boundary="' + boundary + '"';
              } else {
                var name = emlformat.getBoundary(data.headers["Content-Type"]);
                if (name) {
                  boundary = name;
                }
              }

              //Build headers
              var keys = Object.keys(data.headers);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = data.headers[key];
                if (typeof value == "undefined") {
                  continue; //Skip missing headers
                } else if (typeof value == "string") {
                  eml += key + ": " + value.replace(/\r?\n/g, EOL + "  ") + EOL;
                } else {
                  //Array
                  for (var j = 0; j < value.length; j++) {
                    eml += key + ": " + value[j].replace(/\r?\n/g, EOL + "  ") + EOL;
                  }
                }
              }

              //Start the body
              eml += EOL;

              //Plain text content
              if (data.text) {
                eml += "--" + boundary + EOL;
                eml += "Content-Type: text/plain; charset=utf-8" + EOL;
                eml += EOL;
                eml += data.text;
                eml += EOL + EOL;
              }

              //HTML content
              if (data.html) {
                eml += "--" + boundary + EOL;
                eml += "Content-Type: text/html; charset=utf-8" + EOL;
                eml += EOL;
                eml += data.html;
                eml += EOL + EOL;
              }

              //Append attachments
              if (data.attachments) {
                for (var i = 0; i < data.attachments.length; i++) {
                  var attachment = data.attachments[i];
                  eml += '--' + boundary + EOL;
                  eml += 'Content-Type: ' + (attachment.contentType || "application/octet-stream") + EOL;
                  eml += 'Content-Transfer-Encoding: base64' + EOL;
                  eml += 'Content-Disposition: ' + (attachment.inline ? "inline" : "attachment") + '; filename="' + (attachment.filename || attachment.name || "attachment_" + (i + 1)) + '"' + EOL;
                  if (attachment.cid) {
                    eml += 'Content-ID: <' + attachment.cid + ">" + EOL;
                  }
                  eml += EOL;
                  if (typeof attachment.data == "string") {
                    var content = Buffer.from(attachment.data).toString("base64");
                    eml += wrap(content, 76) + EOL;
                  } else {
                    //Buffer
                    var content = attachment.data.toString("base64");
                    eml += wrap(content, 76) + EOL;
                  }
                  eml += EOL;
                }
              }

              //Finish the boundary
              eml += "--" + boundary + "--" + EOL;
              callback(null, eml);
            } catch (e) {
              callback(e);
            }
          };

          /******************************************************************************************
           * Parses EML file content and return user-friendly object.
           * @params eml         EML file content or object from 'parse'
           * @params options     EML parse options
           * @params callback    Callback function(error, data)
           ******************************************************************************************/
          emlformat.read = function (eml, options, callback) {
            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            function _read(data) {
              try {
                var result = {};
                if (data.headers["Date"]) {
                  result.date = new Date(data.headers["Date"]);
                }
                if (data.headers["Subject"]) {
                  result.subject = emlformat.unquoteString(data.headers["Subject"]);
                }
                if (data.headers["From"]) {
                  result.from = emlformat.getEmailAddress(data.headers["From"]);
                }
                if (data.headers["To"]) {
                  result.to = emlformat.getEmailAddress(data.headers["To"]);
                }
                if (data.headers["CC"]) {
                  result.cc = emlformat.getEmailAddress(data.headers["CC"]);
                }
                if (data.headers["Cc"]) {
                  result.cc = emlformat.getEmailAddress(data.headers["Cc"]);
                }
                result.headers = data.headers;

                //Appends the boundary to the result
                function _append(headers, content) {
                  var contentType = headers["Content-Type"];
                  var charset = getCharsetName(emlformat.getCharset(contentType) || defaultCharset);
                  var encoding = headers["Content-Transfer-Encoding"];
                  if (typeof encoding == "string") {
                    encoding = encoding.toLowerCase();
                  }
                  if (encoding == "base64") {
                    if (contentType.indexOf("gbk") >= 0) {
                      content = new Buffer(iconv.decode(new Buffer(content, 'base64'), 'gb2312'), 'utf8');
                    } else {
                      content = Buffer.from(content.replace(/\r?\n/g, ""), "base64");
                    }
                  } else if (encoding == "quoted-printable") {
                    content = emlformat.unquotePrintable(content, charset);
                  } else if (charset != "utf8" && (encoding.startsWith("binary") || encoding.startsWith("8bit"))) {
                    //"8bit", "binary", "8bitmime", "binarymime"
                    content = iconv.decode(Buffer.from(content, 'binary'), charset);
                  }
                  if (!result.html && contentType && contentType.indexOf("text/html") >= 0) {
                    if (typeof content != "string") {
                      //content = content.toString("utf8");
                      content = iconv.decode(Buffer.from(content), charset);
                    }
                    //Message in HTML format
                    result.html = content;
                  } else if (!result.text && contentType && contentType.indexOf("text/plain") >= 0) {
                    if (typeof content != "string") {
                      //content = content.toString("utf8");
                      content = iconv.decode(Buffer.from(content), charset);
                    }
                    //Plain text message
                    result.text = content;
                  } else {
                    //Get the attachment
                    if (!result.attachments) {
                      result.attachments = [];
                    }
                    var attachment = {};
                    var id = headers["Content-ID"];
                    if (id) {
                      attachment.id = id;
                    }
                    var name = headers["Content-Disposition"] || headers["Content-Type"];
                    if (name) {
                      var match = /name="?(.+?)"?$/gi.exec(name);
                      if (match) {
                        name = match[1];
                      } else {
                        name = null;
                      }
                    }
                    if (name) {
                      attachment.name = name;
                    }
                    var ct = headers["Content-Type"];
                    if (ct) {
                      attachment.contentType = ct;
                    }
                    var cd = headers["Content-Disposition"];
                    if (cd) {
                      attachment.inline = /^\s*inline/g.test(cd);
                    }
                    attachment.data = content;
                    result.attachments.push(attachment);
                  }
                }

                //Content mime type
                var boundary = null;
                var ct = data.headers["Content-Type"];
                if (ct && /^multipart\//g.test(ct)) {
                  var b = emlformat.getBoundary(ct);
                  if (b && b.length) {
                    boundary = b;
                  }
                }
                if (boundary) {
                  for (var i = 0; i < data.body.length; i++) {
                    var b = data.body[i];

                    //Get the message content
                    if (typeof b.part == "undefined") {
                      console.warn("Warning: undefined b.part");
                    } else if (typeof b.part == "string") {
                      result.data = b.part;
                    } else {
                      if (typeof b.part.body == "undefined") {
                        console.warn("Warning: undefined b.part.body");
                      } else if (typeof b.part.body == "string") {
                        b.part.body;
                        var headers = b.part.headers;
                        var content = b.part.body;
                        _append(headers, content);
                      } else {
                        for (var j = 0; j < b.part.body.length; j++) {
                          if (typeof b.part.body[j] == "string") {
                            result.data = b.part.body[j];
                            continue;
                          }
                          var headers = b.part.body[j].part.headers;
                          var content = b.part.body[j].part.body;
                          _append(headers, content);
                        }
                      }
                    }
                  }
                } else if (typeof data.body == "string") {
                  _append(data.headers, data.body);
                }
                callback(null, result);
              } catch (e) {
                callback(e);
              }
            }
            if (typeof eml == "string") {
              emlformat.parse(eml, options, function (error, data) {
                if (error) return callback(error);
                if (!data) return callback(new Error("Cannot parse EML content!"));
                _read(data);
              });
            } else if (_typeof(eml) == "object") {
              _read(eml);
            } else {
              callback(new Error("Missing EML file content!"));
            }
          };

          /******************************************************************************************
           * Parses EML file content and returns object-oriented representation of the content.
           * @params eml         EML file content
           * @params options     EML parse options
           * @params callback    Callback function(error, data)
           ******************************************************************************************/
          emlformat.parse = function (eml, options, callback) {
            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            try {
              if (typeof eml != "string") {
                throw new Error("Argument 'eml' expected to be string!");
              }
              var lines = eml.split(/\r?\n/);
              var result = {};
              parseRecursive(lines, 0, result, options);
              callback(null, result);
            } catch (e) {
              callback(e);
            }
          };

          /******************************************************************************************
           * Parses EML file content.
           ******************************************************************************************/
          function parseRecursive(lines, start, parent, options) {
            var boundary = null;
            var lastHeaderName = "";
            var findBoundary = "";
            var insideBody = false;
            var insideBoundary = false;
            var isMultiHeader = false;
            var isMultipart = false;
            parent.headers = {};
            //parent.body = null;

            function complete(boundary) {
              //boundary.part = boundary.lines.join("\r\n");
              boundary.part = {};
              parseRecursive(boundary.lines, 0, boundary.part, options);
              delete boundary.lines;
            }

            //Read line by line
            for (var i = start; i < lines.length; i++) {
              var line = lines[i];

              //Header
              if (!insideBody) {
                //Search for empty line
                if (line == "") {
                  insideBody = true;
                  if (options && options.headersOnly) {
                    break;
                  }

                  //Expected boundary
                  var ct = parent.headers["Content-Type"];
                  if (ct && /^multipart\//g.test(ct)) {
                    var b = emlformat.getBoundary(ct);
                    if (b && b.length) {
                      findBoundary = b;
                      isMultipart = true;
                      parent.body = [];
                    } else {
                      if (emlformat.verbose) {
                        console.warn("Multipart without boundary! " + ct.replace(/\r?\n/g, " "));
                      }
                    }
                  }
                  continue;
                }

                //Header value with new line
                var match = /^\s+([^\r\n]+)/g.exec(line);
                if (match) {
                  if (isMultiHeader) {
                    parent.headers[lastHeaderName][parent.headers[lastHeaderName].length - 1] += "\r\n" + match[1];
                  } else {
                    parent.headers[lastHeaderName] += "\r\n" + match[1];
                  }
                  continue;
                }

                //Header name and value
                var match = /^([\w\d\-]+):\s+([^\r\n]+)/gi.exec(line);
                if (match) {
                  lastHeaderName = match[1];
                  if (parent.headers[lastHeaderName]) {
                    //Multiple headers with the same name
                    isMultiHeader = true;
                    if (typeof parent.headers[lastHeaderName] == "string") {
                      parent.headers[lastHeaderName] = [parent.headers[lastHeaderName]];
                    }
                    parent.headers[lastHeaderName].push(match[2]);
                  } else {
                    //Header first appeared here
                    isMultiHeader = false;
                    parent.headers[lastHeaderName] = match[2];
                  }
                  continue;
                }
              }
              //Body
              else {
                //Multipart body
                if (isMultipart) {
                  //Search for boundary start

                  //Updated on 2019-10-12: A line before the boundary marker is not required to be an empty line
                  //if (lines[i - 1] == "" && line.indexOf("--" + findBoundary) == 0 && !/\-\-(\r?\n)?$/g.test(line)) {
                  if (line.indexOf("--" + findBoundary) == 0 && !/\-\-(\r?\n)?$/g.test(line)) {
                    insideBoundary = true;

                    //Complete the previous boundary
                    if (boundary && boundary.lines) {
                      complete(boundary);
                    }

                    //Start a new boundary
                    var match = /^\-\-([^\r\n]+)(\r?\n)?$/g.exec(line);
                    boundary = {
                      boundary: match[1],
                      lines: []
                    };
                    parent.body.push(boundary);
                    if (emlformat.verbose) {
                      console.log("Found boundary: " + boundary.boundary);
                    }
                    continue;
                  }
                  if (insideBoundary) {
                    //Search for boundary end
                    if (boundary.boundary && lines[i - 1] == "" && line.indexOf("--" + findBoundary + "--") == 0) {
                      insideBoundary = false;
                      complete(boundary);
                      continue;
                    }
                    boundary.lines.push(line);
                  }
                } else {
                  //Solid string body
                  parent.body = lines.splice(i).join("\r\n");
                  break;
                }
              }
            }

            //Complete the last boundary
            if (parent.body && parent.body.length && parent.body[parent.body.length - 1].lines) {
              complete(parent.body[parent.body.length - 1]);
            }
          }
          module.exports = emlformat;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "buffer": 7,
      "fs": 6,
      "iconv-lite": 31,
      "path": 35
    }],
    11: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
      var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === 'function') {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;

      // Backwards-compat with node 0.10.x
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = undefined;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = undefined;

      // By default EventEmitters will print a warning if more than 10 listeners are
      // added to it. This is a useful default which helps finding memory leaks.
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== 'function') {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
        }
      }
      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
        enumerable: true,
        get: function get() {
          return defaultMaxListeners;
        },
        set: function set(arg) {
          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function () {
        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || undefined;
      };

      // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var doError = type === 'error';
        var events = this._events;
        if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

        // If there is no 'error' event listener then throw.
        if (doError) {
          var er;
          if (args.length > 0) er = args[0];
          if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
          }
          // At least give some kind of context to the user
          var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
          err.context = er;
          throw err; // Unhandled 'error' event
        }

        var handler = events[type];
        if (handler === undefined) return false;
        if (typeof handler === 'function') {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            ReflectApply(listeners[i], this, args);
          }
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === undefined) {
          events = target._events = Object.create(null);
          target._eventsCount = 0;
        } else {
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);

            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === undefined) {
          // Optimize the case of one listener. Don't need the extra array object.
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            // If we've already got an array, just append.
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }

          // Check for listener leak
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0) return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = {
          fired: false,
          wrapFn: undefined,
          target: target,
          type: type,
          listener: listener
        };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

      // Emits a 'removeListener' event if and only if the listener was removed.
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === undefined) return this;
        list = events[type];
        if (list === undefined) return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0) this._events = Object.create(null);else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0) return this;
          if (position === 0) list.shift();else {
            spliceOne(list, position);
          }
          if (list.length === 1) events[type] = list[0];
          if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === undefined) return this;

        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === undefined) return [];
        var evlistener = events[type];
        if (evlistener === undefined) return [];
        if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function (emitter, type) {
        if (typeof emitter.listenerCount === 'function') {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== undefined) {
          var evlistener = events[type];
          if (typeof evlistener === 'function') {
            return 1;
          } else if (evlistener !== undefined) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i) {
          copy[i] = arr[i];
        }
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++) {
          list[index] = list[index + 1];
        }
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function (resolve, reject) {
          function eventListener() {
            if (errorListener !== undefined) {
              emitter.removeListener('error', errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          var errorListener;

          // Adding an error listener is not optional because
          // if an error is thrown on an event emitter we cannot
          // guarantee that the actual event we are waiting will
          // be fired. The result could be a silent way to create
          // memory or file descriptor leaks, which is something
          // we should avoid.
          if (name !== 'error') {
            errorListener = function errorListener(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once('error', errorListener);
          }
          emitter.once(name, eventListener);
        });
      }
    }, {}],
    12: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
      // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
      // To save memory and loading time, we read table files only when requested.

      exports._dbcs = DBCSCodec;
      var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START = -10,
        NODE_START = -1000,
        UNASSIGNED_NODE = new Array(0x100),
        DEF_CHAR = -1;
      for (var i = 0; i < 0x100; i++) {
        UNASSIGNED_NODE[i] = UNASSIGNED;
      }

      // Class DBCSCodec reads and initializes mapping tables.
      function DBCSCodec(codecOptions, iconv) {
        this.encodingName = codecOptions.encodingName;
        if (!codecOptions) throw new Error("DBCS codec is called without the data.");
        if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

        // Load tables.
        var mappingTable = codecOptions.table();

        // Decode tables: MBCS -> Unicode.

        // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
        // Trie root is decodeTables[0].
        // Values: >=  0 -> unicode character code. can be > 0xFFFF
        //         == UNASSIGNED -> unknown/unassigned sequence.
        //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
        //         <= NODE_START -> index of the next node in our trie to process next byte.
        //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

        // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
        this.decodeTableSeq = [];

        // Actual mapping tables consist of chunks. Use them to fill up decode tables.
        for (var i = 0; i < mappingTable.length; i++) {
          this._addDecodeChunk(mappingTable[i]);
        }
        this.defaultCharUnicode = iconv.defaultCharUnicode;

        // Encode tables: Unicode -> DBCS.

        // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
        // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
        // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
        //         == UNASSIGNED -> no conversion found. Output a default char.
        //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
        this.encodeTable = [];

        // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
        // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
        // means end of sequence (needed when one sequence is a strict subsequence of another).
        // Objects are kept separately from encodeTable to increase performance.
        this.encodeTableSeq = [];

        // Some chars can be decoded, but need not be encoded.
        var skipEncodeChars = {};
        if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
          var val = codecOptions.encodeSkipVals[i];
          if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) {
            skipEncodeChars[j] = true;
          }
        }

        // Use decode trie to recursively fill out encode tables.
        this._fillEncodeTable(0, 0, skipEncodeChars);

        // Add more encoding pairs when needed.
        if (codecOptions.encodeAdd) {
          for (var uChar in codecOptions.encodeAdd) {
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
          }
        }
        this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

        // Load & create GB18030 tables when needed.
        if (typeof codecOptions.gb18030 === 'function') {
          this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

          // Add GB18030 decode tables.
          var thirdByteNodeIdx = this.decodeTables.length;
          var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
          var fourthByteNodeIdx = this.decodeTables.length;
          var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
          for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++) {
              secondByteNode[j] = NODE_START - thirdByteNodeIdx;
            }
          }
          for (var i = 0x81; i <= 0xFE; i++) {
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
          }
          for (var i = 0x30; i <= 0x39; i++) {
            fourthByteNode[i] = GB18030_CODE;
          }
        }
      }
      DBCSCodec.prototype.encoder = DBCSEncoder;
      DBCSCodec.prototype.decoder = DBCSDecoder;

      // Decoder helpers
      DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
        var bytes = [];
        for (; addr > 0; addr >>= 8) {
          bytes.push(addr & 0xFF);
        }
        if (bytes.length == 0) bytes.push(0);
        var node = this.decodeTables[0];
        for (var i = bytes.length - 1; i > 0; i--) {
          // Traverse nodes deeper into the trie.
          var val = node[bytes[i]];
          if (val == UNASSIGNED) {
            // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
          } else if (val <= NODE_START) {
            // Existing node.
            node = this.decodeTables[NODE_START - val];
          } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
        }
        return node;
      };
      DBCSCodec.prototype._addDecodeChunk = function (chunk) {
        // First element of chunk is the hex mbcs code where we start.
        var curAddr = parseInt(chunk[0], 16);

        // Choose the decoding node where we'll write our chars.
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 0xFF;

        // Write all other elements of the chunk to the table.
        for (var k = 1; k < chunk.length; k++) {
          var part = chunk[k];
          if (typeof part === "string") {
            // String, write as-is.
            for (var l = 0; l < part.length;) {
              var code = part.charCodeAt(l++);
              if (0xD800 <= code && code < 0xDC00) {
                // Decode surrogate
                var codeTrail = part.charCodeAt(l++);
                if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
              } else if (0x0FF0 < code && code <= 0x0FFF) {
                // Character sequence (our own encoding used)
                var len = 0xFFF - code + 2;
                var seq = [];
                for (var m = 0; m < len; m++) {
                  seq.push(part.charCodeAt(l++));
                } // Simple variation: don't support surrogates or subsequences in seq.

                writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                this.decodeTableSeq.push(seq);
              } else writeTable[curAddr++] = code; // Basic char
            }
          } else if (typeof part === "number") {
            // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++) {
              writeTable[curAddr++] = charCode++;
            }
          } else throw new Error("Incorrect type '" + _typeof(part) + "' given in " + this.encodingName + " at chunk " + chunk[0]);
        }
        if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
      };

      // Encoder helpers
      DBCSCodec.prototype._getEncodeBucket = function (uCode) {
        var high = uCode >> 8; // This could be > 0xFF because of astral characters.
        if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
        return this.encodeTable[high];
      };
      DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
        if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
        else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
      };
      DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
        // Get the root of character tree according to first character of the sequence.
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
        var node;
        if (bucket[low] <= SEQ_START) {
          // There's already a sequence with  - use it.
          node = this.encodeTableSeq[SEQ_START - bucket[low]];
        } else {
          // There was no sequence object - allocate a new one.
          node = {};
          if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
          bucket[low] = SEQ_START - this.encodeTableSeq.length;
          this.encodeTableSeq.push(node);
        }

        // Traverse the character tree, allocating new nodes as needed.
        for (var j = 1; j < seq.length - 1; j++) {
          var oldVal = node[uCode];
          if (_typeof(oldVal) === 'object') node = oldVal;else {
            node = node[uCode] = {};
            if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
          }
        }

        // Set the leaf to given dbcsCode.
        uCode = seq[seq.length - 1];
        node[uCode] = dbcsCode;
      };
      DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
        var node = this.decodeTables[nodeIdx];
        for (var i = 0; i < 0x100; i++) {
          var uCode = node[i];
          var mbCode = prefix + i;
          if (skipEncodeChars[mbCode]) continue;
          if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        }
      };

      // == Encoder ==================================================================

      function DBCSEncoder(options, codec) {
        // Encoder state
        this.leadSurrogate = -1;
        this.seqObj = undefined;

        // Static data
        this.encodeTable = codec.encodeTable;
        this.encodeTableSeq = codec.encodeTableSeq;
        this.defaultCharSingleByte = codec.defCharSB;
        this.gb18030 = codec.gb18030;
      }
      DBCSEncoder.prototype.write = function (str) {
        var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
          leadSurrogate = this.leadSurrogate,
          seqObj = this.seqObj,
          nextChar = -1,
          i = 0,
          j = 0;
        while (true) {
          // 0. Get next character.
          if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
          } else {
            var uCode = nextChar;
            nextChar = -1;
          }

          // 1. Handle surrogates.
          if (0xD800 <= uCode && uCode < 0xE000) {
            // Char is one of surrogates.
            if (uCode < 0xDC00) {
              // We've got lead surrogate.
              if (leadSurrogate === -1) {
                leadSurrogate = uCode;
                continue;
              } else {
                leadSurrogate = uCode;
                // Double lead surrogate found.
                uCode = UNASSIGNED;
              }
            } else {
              // We've got trail surrogate.
              if (leadSurrogate !== -1) {
                uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                leadSurrogate = -1;
              } else {
                // Incomplete surrogate pair - only trail surrogate found.
                uCode = UNASSIGNED;
              }
            }
          } else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode;
            uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
          }

          // 2. Convert uCode character.
          var dbcsCode = UNASSIGNED;
          if (seqObj !== undefined && uCode != UNASSIGNED) {
            // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (_typeof(resCode) === 'object') {
              // Sequence continues.
              seqObj = resCode;
              continue;
            } else if (typeof resCode == 'number') {
              // Sequence finished. Write it.
              dbcsCode = resCode;
            } else if (resCode == undefined) {
              // Current character is not part of the sequence.

              // Try default character for this sequence
              resCode = seqObj[DEF_CHAR];
              if (resCode !== undefined) {
                dbcsCode = resCode; // Found. Write it.
                nextChar = uCode; // Current character will be written too in the next iteration.
              } else {
                // TODO: What if we have no default? (resCode == undefined)
                // Then, we should write first char of the sequence as-is and try the rest recursively.
                // Didn't do it for now because no encoding has this situation yet.
                // Currently, just skip the sequence and write current char.
              }
            }
            seqObj = undefined;
          } else if (uCode >= 0) {
            // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
            if (dbcsCode <= SEQ_START) {
              // Sequence start
              seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
              continue;
            }
            if (dbcsCode == UNASSIGNED && this.gb18030) {
              // Use GB18030 algorithm to find character(s) to write.
              var idx = findIdx(this.gb18030.uChars, uCode);
              if (idx != -1) {
                var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
                dbcsCode = dbcsCode % 12600;
                newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
                dbcsCode = dbcsCode % 1260;
                newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
                dbcsCode = dbcsCode % 10;
                newBuf[j++] = 0x30 + dbcsCode;
                continue;
              }
            }
          }

          // 3. Write dbcsCode character.
          if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
          if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
          } else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8; // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
          } else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = dbcsCode >> 8 & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
          }
        }
        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
      };
      DBCSEncoder.prototype.end = function () {
        if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

        var newBuf = Buffer.alloc(10),
          j = 0;
        if (this.seqObj) {
          // We're in the sequence.
          var dbcsCode = this.seqObj[DEF_CHAR];
          if (dbcsCode !== undefined) {
            // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
              newBuf[j++] = dbcsCode;
            } else {
              newBuf[j++] = dbcsCode >> 8; // high byte
              newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
          } else {
            // See todo above.
          }
          this.seqObj = undefined;
        }
        if (this.leadSurrogate !== -1) {
          // Incomplete surrogate pair - only lead surrogate found.
          newBuf[j++] = this.defaultCharSingleByte;
          this.leadSurrogate = -1;
        }
        return newBuf.slice(0, j);
      };

      // Export for testing
      DBCSEncoder.prototype.findIdx = findIdx;

      // == Decoder ==================================================================

      function DBCSDecoder(options, codec) {
        // Decoder state
        this.nodeIdx = 0;
        this.prevBuf = Buffer.alloc(0);

        // Static data
        this.decodeTables = codec.decodeTables;
        this.decodeTableSeq = codec.decodeTableSeq;
        this.defaultCharUnicode = codec.defaultCharUnicode;
        this.gb18030 = codec.gb18030;
      }
      DBCSDecoder.prototype.write = function (buf) {
        var newBuf = Buffer.alloc(buf.length * 2),
          nodeIdx = this.nodeIdx,
          prevBuf = this.prevBuf,
          prevBufOffset = this.prevBuf.length,
          seqStart = -this.prevBuf.length,
          // idx of the start of current parsed sequence.
          uCode;
        if (prevBufOffset > 0)
          // Make prev buf overlap a little to make it easier to slice later.
          prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
        for (var i = 0, j = 0; i < buf.length; i++) {
          var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];

          // Lookup in current trie node.
          var uCode = this.decodeTables[nodeIdx][curByte];
          if (uCode >= 0) {
            // Normal character, just use it.
          } else if (uCode === UNASSIGNED) {
            // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
          } else if (uCode === GB18030_CODE) {
            var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
            var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
          } else if (uCode <= NODE_START) {
            // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
          } else if (uCode <= SEQ_START) {
            // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
              uCode = seq[k];
              newBuf[j++] = uCode & 0xFF;
              newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length - 1];
          } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

          // Write the character to buffer, handling higher planes using surrogate pair.
          if (uCode > 0xFFFF) {
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;
            uCode = 0xDC00 + uCode % 0x400;
          }
          newBuf[j++] = uCode & 0xFF;
          newBuf[j++] = uCode >> 8;

          // Reset trie node.
          nodeIdx = 0;
          seqStart = i + 1;
        }
        this.nodeIdx = nodeIdx;
        this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
        return newBuf.slice(0, j).toString('ucs2');
      };
      DBCSDecoder.prototype.end = function () {
        var ret = '';

        // Try to parse all remaining chars.
        while (this.prevBuf.length > 0) {
          // Skip 1 character in the buffer.
          ret += this.defaultCharUnicode;
          var buf = this.prevBuf.slice(1);

          // Parse remaining as usual.
          this.prevBuf = Buffer.alloc(0);
          this.nodeIdx = 0;
          if (buf.length > 0) ret += this.write(buf);
        }
        this.nodeIdx = 0;
        return ret;
      };

      // Binary search for GB18030. Returns largest i such that table[i] <= val.
      function findIdx(table, val) {
        if (table[0] > val) return -1;
        var l = 0,
          r = table.length;
        while (l < r - 1) {
          // always table[l] <= val < table[r]
          var mid = l + Math.floor((r - l + 1) / 2);
          if (table[mid] <= val) l = mid;else r = mid;
        }
        return l;
      }
    }, {
      "safer-buffer": 56
    }],
    13: [function (require, module, exports) {
      "use strict";

      // Description of supported double byte encodings and aliases.
      // Tables are not require()-d until they are needed to speed up library load.
      // require()-s are direct to support Browserify.
      module.exports = {
        // == Japanese/ShiftJIS ====================================================
        // All japanese encodings are based on JIS X set of standards:
        // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
        // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
        //              Has several variations in 1978, 1983, 1990 and 1997.
        // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
        // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
        //              2 planes, first is superset of 0208, second - revised 0212.
        //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

        // Byte encodings are:
        //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
        //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
        //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
        //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
        //               0x00-0x7F       - lower part of 0201
        //               0x8E, 0xA1-0xDF - upper part of 0201
        //               (0xA1-0xFE)x2   - 0208 plane (94x94).
        //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
        //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
        //               Used as-is in ISO2022 family.
        //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
        //                0201-1976 Roman, 0208-1978, 0208-1983.
        //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
        //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
        //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
        //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
        //
        // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
        //
        // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

        'shiftjis': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/shiftjis.json');
          },
          encodeAdd: {
            "\xA5": 0x5C,
            "\u203E": 0x7E
          },
          encodeSkipVals: [{
            from: 0xED40,
            to: 0xF940
          }]
        },
        'csshiftjis': 'shiftjis',
        'mskanji': 'shiftjis',
        'sjis': 'shiftjis',
        'windows31j': 'shiftjis',
        'ms31j': 'shiftjis',
        'xsjis': 'shiftjis',
        'windows932': 'shiftjis',
        'ms932': 'shiftjis',
        '932': 'shiftjis',
        'cp932': 'shiftjis',
        'eucjp': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/eucjp.json');
          },
          encodeAdd: {
            "\xA5": 0x5C,
            "\u203E": 0x7E
          }
        },
        // TODO: KDDI extension to Shift_JIS
        // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
        // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

        // == Chinese/GBK ==========================================================
        // http://en.wikipedia.org/wiki/GBK
        // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

        // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
        'gb2312': 'cp936',
        'gb231280': 'cp936',
        'gb23121980': 'cp936',
        'csgb2312': 'cp936',
        'csiso58gb231280': 'cp936',
        'euccn': 'cp936',
        // Microsoft's CP936 is a subset and approximation of GBK.
        'windows936': 'cp936',
        'ms936': 'cp936',
        '936': 'cp936',
        'cp936': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp936.json');
          }
        },
        // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
        'gbk': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp936.json').concat(require('./tables/gbk-added.json'));
          }
        },
        'xgbk': 'gbk',
        'isoir58': 'gbk',
        // GB18030 is an algorithmic extension of GBK.
        // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
        // http://icu-project.org/docs/papers/gb18030.html
        // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
        // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
        'gb18030': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp936.json').concat(require('./tables/gbk-added.json'));
          },
          gb18030: function gb18030() {
            return require('./tables/gb18030-ranges.json');
          },
          encodeSkipVals: [0x80],
          encodeAdd: {
            '': 0xA2E3
          }
        },
        'chinese': 'gb18030',
        // == Korean ===============================================================
        // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
        'windows949': 'cp949',
        'ms949': 'cp949',
        '949': 'cp949',
        'cp949': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp949.json');
          }
        },
        'cseuckr': 'cp949',
        'csksc56011987': 'cp949',
        'euckr': 'cp949',
        'isoir149': 'cp949',
        'korean': 'cp949',
        'ksc56011987': 'cp949',
        'ksc56011989': 'cp949',
        'ksc5601': 'cp949',
        // == Big5/Taiwan/Hong Kong ================================================
        // There are lots of tables for Big5 and cp950. Please see the following links for history:
        // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
        // Variations, in roughly number of defined chars:
        //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
        //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
        //  * Big5-2003 (Taiwan standard) almost superset of cp950.
        //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
        //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
        //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
        //    Plus, it has 4 combining sequences.
        //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
        //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
        //    Implementations are not consistent within browsers; sometimes labeled as just big5.
        //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
        //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
        //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
        //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
        //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
        // 
        // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
        // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

        'windows950': 'cp950',
        'ms950': 'cp950',
        '950': 'cp950',
        'cp950': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp950.json');
          }
        },
        // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
        'big5': 'big5hkscs',
        'big5hkscs': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp950.json').concat(require('./tables/big5-added.json'));
          },
          encodeSkipVals: [0xa2cc]
        },
        'cnbig5': 'big5hkscs',
        'csbig5': 'big5hkscs',
        'xxbig5': 'big5hkscs'
      };
    }, {
      "./tables/big5-added.json": 19,
      "./tables/cp936.json": 20,
      "./tables/cp949.json": 21,
      "./tables/cp950.json": 22,
      "./tables/eucjp.json": 23,
      "./tables/gb18030-ranges.json": 24,
      "./tables/gbk-added.json": 25,
      "./tables/shiftjis.json": 26
    }],
    14: [function (require, module, exports) {
      "use strict";

      // Update this array if you add/rename/remove files in this directory.
      // We support Browserify by skipping automatic module discovery and requiring modules directly.
      var modules = [require("./internal"), require("./utf32"), require("./utf16"), require("./utf7"), require("./sbcs-codec"), require("./sbcs-data"), require("./sbcs-data-generated"), require("./dbcs-codec"), require("./dbcs-data")];

      // Put all encoding/alias/codec definitions to single object and export it.
      for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module) {
          if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
        }
      }
    }, {
      "./dbcs-codec": 12,
      "./dbcs-data": 13,
      "./internal": 15,
      "./sbcs-codec": 16,
      "./sbcs-data": 18,
      "./sbcs-data-generated": 17,
      "./utf16": 27,
      "./utf32": 28,
      "./utf7": 29
    }],
    15: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Export Node.js internal encodings.

      module.exports = {
        // Encodings
        utf8: {
          type: "_internal",
          bomAware: true
        },
        cesu8: {
          type: "_internal",
          bomAware: true
        },
        unicode11utf8: "utf8",
        ucs2: {
          type: "_internal",
          bomAware: true
        },
        utf16le: "ucs2",
        binary: {
          type: "_internal"
        },
        base64: {
          type: "_internal"
        },
        hex: {
          type: "_internal"
        },
        // Codec.
        _internal: InternalCodec
      };

      //------------------------------------------------------------------------------

      function InternalCodec(codecOptions, iconv) {
        this.enc = codecOptions.encodingName;
        this.bomAware = codecOptions.bomAware;
        if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
          this.enc = "utf8"; // Use utf8 for decoding.
          this.encoder = InternalEncoderCesu8;

          // Add decoder for versions of Node not supporting CESU-8
          if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
          }
        }
      }
      InternalCodec.prototype.encoder = InternalEncoder;
      InternalCodec.prototype.decoder = InternalDecoder;

      //------------------------------------------------------------------------------

      // We use node.js internal decoder. Its signature is the same as ours.
      var StringDecoder = require('string_decoder').StringDecoder;
      if (!StringDecoder.prototype.end)
        // Node v0.8 doesn't have this method.
        StringDecoder.prototype.end = function () {};
      function InternalDecoder(options, codec) {
        StringDecoder.call(this, codec.enc);
      }
      InternalDecoder.prototype = StringDecoder.prototype;

      //------------------------------------------------------------------------------
      // Encoder is mostly trivial

      function InternalEncoder(options, codec) {
        this.enc = codec.enc;
      }
      InternalEncoder.prototype.write = function (str) {
        return Buffer.from(str, this.enc);
      };
      InternalEncoder.prototype.end = function () {};

      //------------------------------------------------------------------------------
      // Except base64 encoder, which must keep its state.

      function InternalEncoderBase64(options, codec) {
        this.prevStr = '';
      }
      InternalEncoderBase64.prototype.write = function (str) {
        str = this.prevStr + str;
        var completeQuads = str.length - str.length % 4;
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);
        return Buffer.from(str, "base64");
      };
      InternalEncoderBase64.prototype.end = function () {
        return Buffer.from(this.prevStr, "base64");
      };

      //------------------------------------------------------------------------------
      // CESU-8 encoder is also special.

      function InternalEncoderCesu8(options, codec) {}
      InternalEncoderCesu8.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length * 3),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var charCode = str.charCodeAt(i);
          // Naive implementation, but it works because CESU-8 is especially easy
          // to convert from UTF-16 (which all JS strings are encoded in).
          if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
          } else {
            // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
          }
        }
        return buf.slice(0, bufIdx);
      };
      InternalEncoderCesu8.prototype.end = function () {};

      //------------------------------------------------------------------------------
      // CESU-8 decoder is not implemented in Node v4.0+

      function InternalDecoderCesu8(options, codec) {
        this.acc = 0;
        this.contBytes = 0;
        this.accBytes = 0;
        this.defaultCharUnicode = codec.defaultCharUnicode;
      }
      InternalDecoderCesu8.prototype.write = function (buf) {
        var acc = this.acc,
          contBytes = this.contBytes,
          accBytes = this.accBytes,
          res = '';
        for (var i = 0; i < buf.length; i++) {
          var curByte = buf[i];
          if ((curByte & 0xC0) !== 0x80) {
            // Leading byte
            if (contBytes > 0) {
              // Previous code is invalid
              res += this.defaultCharUnicode;
              contBytes = 0;
            }
            if (curByte < 0x80) {
              // Single-byte code
              res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) {
              // Two-byte code
              acc = curByte & 0x1F;
              contBytes = 1;
              accBytes = 1;
            } else if (curByte < 0xF0) {
              // Three-byte code
              acc = curByte & 0x0F;
              contBytes = 2;
              accBytes = 1;
            } else {
              // Four or more are not supported for CESU-8.
              res += this.defaultCharUnicode;
            }
          } else {
            // Continuation byte
            if (contBytes > 0) {
              // We're waiting for it.
              acc = acc << 6 | curByte & 0x3f;
              contBytes--;
              accBytes++;
              if (contBytes === 0) {
                // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
                  // Actually add character.
                  res += String.fromCharCode(acc);
              }
            } else {
              // Unexpected continuation byte
              res += this.defaultCharUnicode;
            }
          }
        }
        this.acc = acc;
        this.contBytes = contBytes;
        this.accBytes = accBytes;
        return res;
      };
      InternalDecoderCesu8.prototype.end = function () {
        var res = 0;
        if (this.contBytes > 0) res += this.defaultCharUnicode;
        return res;
      };
    }, {
      "safer-buffer": 56,
      "string_decoder": 72
    }],
    16: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
      // correspond to encoded bytes (if 128 - then lower half is ASCII). 

      exports._sbcs = SBCSCodec;
      function SBCSCodec(codecOptions, iconv) {
        if (!codecOptions) throw new Error("SBCS codec is called without the data.");

        // Prepare char buffer for decoding.
        if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
        if (codecOptions.chars.length === 128) {
          var asciiString = "";
          for (var i = 0; i < 128; i++) {
            asciiString += String.fromCharCode(i);
          }
          codecOptions.chars = asciiString + codecOptions.chars;
        }
        this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');

        // Encoding buffer.
        var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
        for (var i = 0; i < codecOptions.chars.length; i++) {
          encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
        }
        this.encodeBuf = encodeBuf;
      }
      SBCSCodec.prototype.encoder = SBCSEncoder;
      SBCSCodec.prototype.decoder = SBCSDecoder;
      function SBCSEncoder(options, codec) {
        this.encodeBuf = codec.encodeBuf;
      }
      SBCSEncoder.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length);
        for (var i = 0; i < str.length; i++) {
          buf[i] = this.encodeBuf[str.charCodeAt(i)];
        }
        return buf;
      };
      SBCSEncoder.prototype.end = function () {};
      function SBCSDecoder(options, codec) {
        this.decodeBuf = codec.decodeBuf;
      }
      SBCSDecoder.prototype.write = function (buf) {
        // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
        var decodeBuf = this.decodeBuf;
        var newBuf = Buffer.alloc(buf.length * 2);
        var idx1 = 0,
          idx2 = 0;
        for (var i = 0; i < buf.length; i++) {
          idx1 = buf[i] * 2;
          idx2 = i * 2;
          newBuf[idx2] = decodeBuf[idx1];
          newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
        }
        return newBuf.toString('ucs2');
      };
      SBCSDecoder.prototype.end = function () {};
    }, {
      "safer-buffer": 56
    }],
    17: [function (require, module, exports) {
      "use strict";

      // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
      module.exports = {
        "437": "cp437",
        "737": "cp737",
        "775": "cp775",
        "850": "cp850",
        "852": "cp852",
        "855": "cp855",
        "856": "cp856",
        "857": "cp857",
        "858": "cp858",
        "860": "cp860",
        "861": "cp861",
        "862": "cp862",
        "863": "cp863",
        "864": "cp864",
        "865": "cp865",
        "866": "cp866",
        "869": "cp869",
        "874": "windows874",
        "922": "cp922",
        "1046": "cp1046",
        "1124": "cp1124",
        "1125": "cp1125",
        "1129": "cp1129",
        "1133": "cp1133",
        "1161": "cp1161",
        "1162": "cp1162",
        "1163": "cp1163",
        "1250": "windows1250",
        "1251": "windows1251",
        "1252": "windows1252",
        "1253": "windows1253",
        "1254": "windows1254",
        "1255": "windows1255",
        "1256": "windows1256",
        "1257": "windows1257",
        "1258": "windows1258",
        "28591": "iso88591",
        "28592": "iso88592",
        "28593": "iso88593",
        "28594": "iso88594",
        "28595": "iso88595",
        "28596": "iso88596",
        "28597": "iso88597",
        "28598": "iso88598",
        "28599": "iso88599",
        "28600": "iso885910",
        "28601": "iso885911",
        "28603": "iso885913",
        "28604": "iso885914",
        "28605": "iso885915",
        "28606": "iso885916",
        "windows874": {
          "type": "_sbcs",
          "chars": ""
        },
        "win874": "windows874",
        "cp874": "windows874",
        "windows1250": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1250": "windows1250",
        "cp1250": "windows1250",
        "windows1251": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1251": "windows1251",
        "cp1251": "windows1251",
        "windows1252": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1252": "windows1252",
        "cp1252": "windows1252",
        "windows1253": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1253": "windows1253",
        "cp1253": "windows1253",
        "windows1254": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1254": "windows1254",
        "cp1254": "windows1254",
        "windows1255": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1255": "windows1255",
        "cp1255": "windows1255",
        "windows1256": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1256": "windows1256",
        "cp1256": "windows1256",
        "windows1257": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1257": "windows1257",
        "cp1257": "windows1257",
        "windows1258": {
          "type": "_sbcs",
          "chars": ""
        },
        "win1258": "windows1258",
        "cp1258": "windows1258",
        "iso88591": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28591": "iso88591",
        "iso88592": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28592": "iso88592",
        "iso88593": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28593": "iso88593",
        "iso88594": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28594": "iso88594",
        "iso88595": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28595": "iso88595",
        "iso88596": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28596": "iso88596",
        "iso88597": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28597": "iso88597",
        "iso88598": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28598": "iso88598",
        "iso88599": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28599": "iso88599",
        "iso885910": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28600": "iso885910",
        "iso885911": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28601": "iso885911",
        "iso885913": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28603": "iso885913",
        "iso885914": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28604": "iso885914",
        "iso885915": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28605": "iso885915",
        "iso885916": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp28606": "iso885916",
        "cp437": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm437": "cp437",
        "csibm437": "cp437",
        "cp737": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm737": "cp737",
        "csibm737": "cp737",
        "cp775": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm775": "cp775",
        "csibm775": "cp775",
        "cp850": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm850": "cp850",
        "csibm850": "cp850",
        "cp852": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm852": "cp852",
        "csibm852": "cp852",
        "cp855": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm855": "cp855",
        "csibm855": "cp855",
        "cp856": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm856": "cp856",
        "csibm856": "cp856",
        "cp857": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm857": "cp857",
        "csibm857": "cp857",
        "cp858": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm858": "cp858",
        "csibm858": "cp858",
        "cp860": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm860": "cp860",
        "csibm860": "cp860",
        "cp861": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm861": "cp861",
        "csibm861": "cp861",
        "cp862": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm862": "cp862",
        "csibm862": "cp862",
        "cp863": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm863": "cp863",
        "csibm863": "cp863",
        "cp864": {
          "type": "_sbcs",
          "chars": "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
        },
        "ibm864": "cp864",
        "csibm864": "cp864",
        "cp865": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm865": "cp865",
        "csibm865": "cp865",
        "cp866": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm866": "cp866",
        "csibm866": "cp866",
        "cp869": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm869": "cp869",
        "csibm869": "cp869",
        "cp922": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm922": "cp922",
        "csibm922": "cp922",
        "cp1046": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1046": "cp1046",
        "csibm1046": "cp1046",
        "cp1124": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1124": "cp1124",
        "csibm1124": "cp1124",
        "cp1125": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1125": "cp1125",
        "csibm1125": "cp1125",
        "cp1129": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1129": "cp1129",
        "csibm1129": "cp1129",
        "cp1133": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1133": "cp1133",
        "csibm1133": "cp1133",
        "cp1161": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1161": "cp1161",
        "csibm1161": "cp1161",
        "cp1162": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1162": "cp1162",
        "csibm1162": "cp1162",
        "cp1163": {
          "type": "_sbcs",
          "chars": ""
        },
        "ibm1163": "cp1163",
        "csibm1163": "cp1163",
        "maccroatian": {
          "type": "_sbcs",
          "chars": ""
        },
        "maccyrillic": {
          "type": "_sbcs",
          "chars": ""
        },
        "macgreek": {
          "type": "_sbcs",
          "chars": ""
        },
        "maciceland": {
          "type": "_sbcs",
          "chars": ""
        },
        "macroman": {
          "type": "_sbcs",
          "chars": ""
        },
        "macromania": {
          "type": "_sbcs",
          "chars": ""
        },
        "macthai": {
          "type": "_sbcs",
          "chars": ""
        },
        "macturkish": {
          "type": "_sbcs",
          "chars": ""
        },
        "macukraine": {
          "type": "_sbcs",
          "chars": ""
        },
        "koi8r": {
          "type": "_sbcs",
          "chars": ""
        },
        "koi8u": {
          "type": "_sbcs",
          "chars": ""
        },
        "koi8ru": {
          "type": "_sbcs",
          "chars": ""
        },
        "koi8t": {
          "type": "_sbcs",
          "chars": ""
        },
        "armscii8": {
          "type": "_sbcs",
          "chars": ")(.,-"
        },
        "rk1048": {
          "type": "_sbcs",
          "chars": ""
        },
        "tcvn": {
          "type": "_sbcs",
          "chars": "\0\xDA\u1EE4\x03\u1EEA\u1EEC\u1EEE\x07\b\t\n\x0B\f\r\x0E\x0F\x10\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
        },
        "georgianacademy": {
          "type": "_sbcs",
          "chars": ""
        },
        "georgianps": {
          "type": "_sbcs",
          "chars": ""
        },
        "pt154": {
          "type": "_sbcs",
          "chars": ""
        },
        "viscii": {
          "type": "_sbcs",
          "chars": "\0\x01\u1EB2\x03\x04\u1EB4\u1EAA\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\u1EF6\x15\x16\x17\x18\u1EF8\x1A\x1B\x1C\x1D\u1EF4\x1F !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
        },
        "iso646cn": {
          "type": "_sbcs",
          "chars": "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
        },
        "iso646jp": {
          "type": "_sbcs",
          "chars": "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
        },
        "hproman8": {
          "type": "_sbcs",
          "chars": ""
        },
        "macintosh": {
          "type": "_sbcs",
          "chars": ""
        },
        "ascii": {
          "type": "_sbcs",
          "chars": ""
        },
        "tis620": {
          "type": "_sbcs",
          "chars": ""
        }
      };
    }, {}],
    18: [function (require, module, exports) {
      "use strict";

      // Manually added data to be used by sbcs codec in addition to generated one.
      module.exports = {
        // Not supported by iconv, not sure why.
        "10029": "maccenteuro",
        "maccenteuro": {
          "type": "_sbcs",
          "chars": ""
        },
        "808": "cp808",
        "ibm808": "cp808",
        "cp808": {
          "type": "_sbcs",
          "chars": ""
        },
        "mik": {
          "type": "_sbcs",
          "chars": ""
        },
        "cp720": {
          "type": "_sbcs",
          "chars": "\x80\x81\xE9\xE2\x84\xE0\x86\xE7\xEA\xEB\xE8\xEF\xEE\x8D\x8E\x8F\x90\u0651\u0652\xF4\xA4\u0640\xFB\xF9\u0621\u0622\u0623\u0624\xA3\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0636\u0637\u0638\u0639\u063A\u0641\xB5\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u2261\u064B\u064C\u064D\u064E\u064F\u0650\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
        },
        // Aliases of generated encodings.
        "ascii8bit": "ascii",
        "usascii": "ascii",
        "ansix34": "ascii",
        "ansix341968": "ascii",
        "ansix341986": "ascii",
        "csascii": "ascii",
        "cp367": "ascii",
        "ibm367": "ascii",
        "isoir6": "ascii",
        "iso646us": "ascii",
        "iso646irv": "ascii",
        "us": "ascii",
        "latin1": "iso88591",
        "latin2": "iso88592",
        "latin3": "iso88593",
        "latin4": "iso88594",
        "latin5": "iso88599",
        "latin6": "iso885910",
        "latin7": "iso885913",
        "latin8": "iso885914",
        "latin9": "iso885915",
        "latin10": "iso885916",
        "csisolatin1": "iso88591",
        "csisolatin2": "iso88592",
        "csisolatin3": "iso88593",
        "csisolatin4": "iso88594",
        "csisolatincyrillic": "iso88595",
        "csisolatinarabic": "iso88596",
        "csisolatingreek": "iso88597",
        "csisolatinhebrew": "iso88598",
        "csisolatin5": "iso88599",
        "csisolatin6": "iso885910",
        "l1": "iso88591",
        "l2": "iso88592",
        "l3": "iso88593",
        "l4": "iso88594",
        "l5": "iso88599",
        "l6": "iso885910",
        "l7": "iso885913",
        "l8": "iso885914",
        "l9": "iso885915",
        "l10": "iso885916",
        "isoir14": "iso646jp",
        "isoir57": "iso646cn",
        "isoir100": "iso88591",
        "isoir101": "iso88592",
        "isoir109": "iso88593",
        "isoir110": "iso88594",
        "isoir144": "iso88595",
        "isoir127": "iso88596",
        "isoir126": "iso88597",
        "isoir138": "iso88598",
        "isoir148": "iso88599",
        "isoir157": "iso885910",
        "isoir166": "tis620",
        "isoir179": "iso885913",
        "isoir199": "iso885914",
        "isoir203": "iso885915",
        "isoir226": "iso885916",
        "cp819": "iso88591",
        "ibm819": "iso88591",
        "cyrillic": "iso88595",
        "arabic": "iso88596",
        "arabic8": "iso88596",
        "ecma114": "iso88596",
        "asmo708": "iso88596",
        "greek": "iso88597",
        "greek8": "iso88597",
        "ecma118": "iso88597",
        "elot928": "iso88597",
        "hebrew": "iso88598",
        "hebrew8": "iso88598",
        "turkish": "iso88599",
        "turkish8": "iso88599",
        "thai": "iso885911",
        "thai8": "iso885911",
        "celtic": "iso885914",
        "celtic8": "iso885914",
        "isoceltic": "iso885914",
        "tis6200": "tis620",
        "tis62025291": "tis620",
        "tis62025330": "tis620",
        "10000": "macroman",
        "10006": "macgreek",
        "10007": "maccyrillic",
        "10079": "maciceland",
        "10081": "macturkish",
        "cspc8codepage437": "cp437",
        "cspc775baltic": "cp775",
        "cspc850multilingual": "cp850",
        "cspcp852": "cp852",
        "cspc862latinhebrew": "cp862",
        "cpgr": "cp869",
        "msee": "cp1250",
        "mscyrl": "cp1251",
        "msansi": "cp1252",
        "msgreek": "cp1253",
        "msturk": "cp1254",
        "mshebr": "cp1255",
        "msarab": "cp1256",
        "winbaltrim": "cp1257",
        "cp20866": "koi8r",
        "20866": "koi8r",
        "ibm878": "koi8r",
        "cskoi8r": "koi8r",
        "cp21866": "koi8u",
        "21866": "koi8u",
        "ibm1168": "koi8u",
        "strk10482002": "rk1048",
        "tcvn5712": "tcvn",
        "tcvn57121": "tcvn",
        "gb198880": "iso646cn",
        "cn": "iso646cn",
        "csiso14jisc6220ro": "iso646jp",
        "jisc62201969ro": "iso646jp",
        "jp": "iso646jp",
        "cshproman8": "hproman8",
        "r8": "hproman8",
        "roman8": "hproman8",
        "xroman8": "hproman8",
        "ibm1051": "hproman8",
        "mac": "macintosh",
        "csmacintosh": "macintosh"
      };
    }, {}],
    19: [function (require, module, exports) {
      module.exports = [["8740", ""], ["8767", ""], ["87a1", ""], ["8840", "", 4, ""], ["88a1", ""], ["8940", ""], ["8943", ""], ["8946", ""], ["894c", ""], ["89a1", ""], ["89ab", ""], ["89b0", ""], ["89b5", ""], ["89c1", ""], ["89c5", ""], ["8a40", ""], ["8a43", ""], ["8a64", ""], ["8a76", ""], ["8aa1", ""], ["8aac", ""], ["8ab2", ""], ["8abb", ""], ["8ac9", ""], ["8ace", ""], ["8adf", ""], ["8af6", ""], ["8b40", ""], ["8b55", ""], ["8ba1", ""], ["8bde", ""], ["8c40", ""], ["8ca1", ""], ["8ca7", ""], ["8cc9", ""], ["8cce", ""], ["8ce6", ""], ["8d40", ""], ["8d42", ""], ["8da1", ""], ["8e40", ""], ["8ea1", ""], ["8f40", ""], ["8fa1", ""], ["9040", ""], ["90a1", ""], ["9140", ""], ["91a1", ""], ["9240", ""], ["92a1", ""], ["9340", ""], ["93a1", ""], ["9440", ""], ["94a1", ""], ["9540", ""], ["95a1", ""], ["9640", ""], ["96a1", ""], ["9740", ""], ["97a1", ""], ["9840", ""], ["98a1", ""], ["9940", ""], ["99a1", ""], ["9a40", ""], ["9aa1", ""], ["9b40", ""], ["9b62", ""], ["9ba1", ""], ["9c40", ""], ["9ca1", ""], ["9d40", ""], ["9da1", ""], ["9e40", ""], ["9ea1", ""], ["9ead", ""], ["9ec5", ""], ["9ef5", ""], ["9f40", ""], ["9f4f", ""], ["9fa1", ""], ["9fae", ""], ["9fb2", ""], ["9fc1", ""], ["9fc9", ""], ["9fdb", ""], ["9fe7", ""], ["9feb", ""], ["9ff0", ""], ["a040", ""], ["a055", ""], ["a058", ""], ["a05b", ""], ["a063", ""], ["a073", ""], ["a0a1", ""], ["a0a6", ""], ["a0ae", ""], ["a0b0", ""], ["a0d4", ""], ["a0e2", ""], ["a3c0", "", 31, ""], ["c6a1", "", 9, "", 9, "", 9, "", 23], ["c740", "", 58, ""], ["c7a1", "", 81, "", 5, "", 4], ["c840", "", 26, "", 25, ""], ["c8a1", ""], ["c8cd", ""], ["c8f5", ""], ["f9fe", ""], ["fa40", ""], ["faa1", ""], ["fb40", ""], ["fba1", ""], ["fc40", ""], ["fca1", ""], ["fd40", ""], ["fda1", ""], ["fe40", ""], ["fea1", ""]];
    }, {}],
    20: [function (require, module, exports) {
      module.exports = [["0", "\0", 127, ""], ["8140", "", 5, "", 9, "", 6, ""], ["8180", "", 6, "", 4, "", 4, "", 5, ""], ["8240", "", 4, "", 8, "", 4, "", 11], ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""], ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""], ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5], ["8440", "", 5, "", 5, ""], ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""], ["8540", "", 9, ""], ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""], ["8640", "", 4, "", 5, "", 4, "", 5, ""], ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""], ["8740", "", 7, "", 11, "", 4, "", 4], ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6], ["8840", "", 9, "", 4, "", 4, ""], ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7], ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""], ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""], ["8a40", "", 4, "", 12, ""], ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5], ["8b40", "", 8, "", 17, "", 6, "", 13, ""], ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6], ["8c40", "", 7, ""], ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4], ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4], ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""], ["8e40", "", 21, "", 12, "", 6, "", 12, ""], ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6], ["8f40", "", 5, "", 11, "", 8, ""], ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""], ["9040", "", 4, "", 4, "", 6, ""], ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6], ["9140", "", 6, "", 6, "", 18, "", 4, ""], ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""], ["9240", "", 6, "", 5, ""], ["9280", "", 5, "", 7, "", 6, ""], ["9340", "", 6, "", 4, "", 4, "", 5, ""], ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""], ["9440", "", 24, "", 7, "", 7, "", 4, "", 8], ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""], ["9540", "", 4, "", 4, "", 6, ""], ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""], ["9640", "", 5, "", 4, ""], ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5], ["9740", "", 7, "", 8, "", 7, "", 9, ""], ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""], ["9840", "", 4, "", 5, "", 9, ""], ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""], ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5], ["9980", "", 114, "", 6], ["9a40", "", 11, "", 7, "", 13, ""], ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""], ["9b40", "", 4, ""], ["9b80", "", 5, "", 4, "", 4, "", 5, ""], ["9c40", "", 7, ""], ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5], ["9d40", "", 7, "", 4, "", 9, "", 6, ""], ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""], ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6], ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""], ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""], ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4], ["a040", "", 9, "", 5, "", 9, "", 11, "", 19], ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""], ["a1a1", "", 7, ""], ["a2a1", "", 9], ["a2b1", "", 19, "", 19, "", 9], ["a2e5", "", 9], ["a2f1", "", 11], ["a3a1", "", 88, ""], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a6e0", ""], ["a6ee", ""], ["a6f4", ""], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a840", "", 35, "", 6], ["a880", "", 7, ""], ["a8a1", ""], ["a8bd", ""], ["a8c0", ""], ["a8c5", "", 36], ["a940", "", 8, ""], ["a959", ""], ["a95c", ""], ["a960", "", 9, "", 8], ["a980", "", 4, ""], ["a996", ""], ["a9a4", "", 75], ["aa40", "", 5, "", 5, "", 8], ["aa80", "", 7, "", 10, ""], ["ab40", "", 11, "", 4, "", 5, "", 4], ["ab80", "", 6, "", 4], ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11], ["ac80", "", 6, "", 12, "", 4, ""], ["ad40", "", 10, "", 7, "", 15, "", 12], ["ad80", "", 9, "", 8, "", 6, ""], ["ae40", "", 6, "", 7, "", 4, ""], ["ae80", "", 7, "", 6, "", 4, ""], ["af40", "", 4, ""], ["af80", ""], ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""], ["b080", "", 7, "", 8, "", 9, ""], ["b140", "", 4, "", 7, "", 10, ""], ["b180", "", 4, "", 7, "", 7, ""], ["b240", "", 11, "", 5, "", 11, "", 4], ["b280", "", 12, "", 8, "", 4, ""], ["b340", "", 5, ""], ["b380", "", 11, "", 7, "", 6, ""], ["b440", "", 7, "", 9], ["b480", "", 4, "", 5, "", 6, ""], ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""], ["b580", "", 6, "", 4, ""], ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""], ["b680", "", 6, "", 4, ""], ["b740", "", 14, "", 5, "", 9, "", 4, "", 16], ["b780", "", 6, ""], ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""], ["b880", "", 4, ""], ["b940", "", 5, "", 10, "", 6, ""], ["b980", "", 7, ""], ["ba40", "", 4, "", 4, "", 7, "", 5, ""], ["ba80", "", 4, "", 5, "", 12, "", 5, ""], ["bb40", "", 9, "", 36, "", 5, "", 9], ["bb80", "", 6, "", 4, ""], ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5], ["bc80", "", 14, "", 6, ""], ["bd40", "", 54, "", 7], ["bd80", "", 32, ""], ["be40", "", 12, "", 6, "", 42], ["be80", "", 32, ""], ["bf40", "", 62], ["bf80", "", 4, "", 4, "", 21, ""], ["c040", "", 35, "", 23, ""], ["c080", "", 6, "", 9, ""], ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""], ["c180", "", 4, "", 4, "", 5, ""], ["c240", "", 6, "", 5, ""], ["c280", "", 13, "", 5, "", 11, ""], ["c340", "", 5, "", 4, "", 6, ""], ["c380", "", 12, "", 4, ""], ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""], ["c480", "", 7, "", 5, "", 6, ""], ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""], ["c580", "", 7, "", 7, ""], ["c640", ""], ["c680", "", 4, "", 9, ""], ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""], ["c780", ""], ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""], ["c880", "", 6, "", 4, "", 4, ""], ["c940", "", 4, "", 7, "", 12, ""], ["c980", "", 4, "", 4, "", 10, ""], ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10], ["ca80", "", 4, "", 8, ""], ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""], ["cb80", "", 5, "", 6, "", 14, ""], ["cc40", "", 4, "", 10, "", 15, "", 13, ""], ["cc80", "", 11, "", 4, "", 7, ""], ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""], ["cd80", ""], ["ce40", "", 6, "", 5, "", 7, ""], ["ce80", "", 4, "", 6, "", 4, ""], ["cf40", "", 4, "", 4, "", 6, "", 9], ["cf80", "", 5, "", 7, "", 4, ""], ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""], ["d080", "", 4, "", 4, "", 5, ""], ["d140", "", 4, "", 4, "", 6, "", 5], ["d180", "", 4, "", 4, "", 4, ""], ["d240", "", 8, "", 24, "", 5, "", 19, ""], ["d280", "", 26, ""], ["d340", "", 30, "", 6], ["d380", "", 4, "", 5, "", 21, ""], ["d440", "", 31, "", 8, "", 21], ["d480", "", 25, "", 6, ""], ["d540", "", 7, "", 7, "", 46], ["d580", "", 32, ""], ["d640", "", 34, "", 27], ["d680", "", 30, ""], ["d740", "", 31, "", 4, "", 25], ["d780", "", 24, ""], ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""], ["d880", "", 6, "", 20, ""], ["d940", "", 62], ["d980", "", 32, ""], ["da40", "", 14, "", 8, "", 4, "", 9, ""], ["da80", "", 12, ""], ["db40", "", 6, "", 7, "", 4, ""], ["db80", "", 4, "", 5, "", 11, ""], ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7], ["dc80", "", 10, "", 21, ""], ["dd40", "", 62], ["dd80", "", 32, ""], ["de40", "", 32, ""], ["de80", "", 4, ""], ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""], ["df80", "", 4, ""], ["e040", "", 19, ""], ["e080", "", 10, "", 6, "", 8, ""], ["e140", "", 4, "", 6, "", 5, "", 5, ""], ["e180", "", 10, "", 9, "", 8, ""], ["e240", "", 62], ["e280", "", 32, "", 5, ""], ["e340", "", 45, "", 16], ["e380", "", 7, "", 24, ""], ["e440", "", 5, "", 24, "", 31], ["e480", "", 32, ""], ["e540", "", 51, "", 10], ["e580", "", 31, ""], ["e640", "", 34, "", 27], ["e680", "", 29, ""], ["e740", "", 7, "", 54], ["e780", "", 32, "", 6, "", 4, ""], ["e840", "", 14, "", 43, ""], ["e880", "", 20, ""], ["e940", "", 7, "", 42], ["e980", "", 32, ""], ["ea40", "", 27, "", 6, ""], ["ea80", "", 4, "", 12, ""], ["eb40", "", 9, "", 7, "", 9, "", 6, ""], ["eb80", "", 4, ""], ["ec40", "", 8, "", 4, "", 18, "", 7], ["ec80", "", 4, "", 7, "", 4, "", 4, ""], ["ed40", "", 6, "", 46], ["ed80", "", 4, "", 23, ""], ["ee40", "", 62], ["ee80", "", 32, "", 4, "", 6, ""], ["ef40", "", 5, "", 37, "", 4], ["ef80", "", 30, "", 4, "", 8, ""], ["f040", "", 4, "", 28, "", 26], ["f080", "", 9, "", 12, "", 4, "", 6, ""], ["f140", "", 10, "", 47], ["f180", "", 32, ""], ["f240", "", 62], ["f280", "", 32, ""], ["f340", "", 17, "", 6, "", 4, ""], ["f380", "", 8, "", 6, ""], ["f440", "", 5, "", 10, "", 10, "", 7, "", 5], ["f480", "", 32, ""], ["f540", "", 62], ["f580", "", 32, ""], ["f640", "", 62], ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""], ["f740", "", 62], ["f780", "", 4, "", 4, ""], ["f840", "", 62], ["f880", "", 32], ["f940", "", 62], ["f980", "", 32], ["fa40", "", 62], ["fa80", "", 32], ["fb40", "", 27, "", 9, ""], ["fb80", "", 5, "", 8, "", 5, ""], ["fc40", "", 8, "", 4, "", 8, "", 6], ["fc80", "", 4, "", 5, "", 8, ""], ["fd40", "", 4, "", 4, "", 10, "", 38], ["fd80", "", 5, "", 11, "", 4, ""], ["fe40", ""]];
    }, {}],
    21: [function (require, module, exports) {
      module.exports = [["0", "\0", 127], ["8141", "", 4, "", 6, ""], ["8161", "", 9, "", 5, ""], ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""], ["8241", "", 7, "", 5], ["8261", "", 6, "", 5, ""], ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18], ["8341", "", 5, "", 5, "", 7], ["8361", "", 18, ""], ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8], ["8441", "", 5, "", 8], ["8461", "", 18], ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""], ["8541", "", 5, "", 4, "", 6, "", 4], ["8561", "", 5, "", 5, "", 6, ""], ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""], ["8641", "", 6, "", 5, ""], ["8661", "", 6, "", 10], ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""], ["8741", "", 9, "", 15], ["8761", "", 18, ""], ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4], ["8841", "", 4, "", 5, "", 6, "", 4], ["8861", "", 4, ""], ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""], ["8941", "", 6, "", 5, ""], ["8961", "", 10, "", 5, ""], ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15], ["8a41", "", 10, "", 6, ""], ["8a61", "", 4, "", 18, ""], ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""], ["8b41", "", 5, "", 4, "", 6, ""], ["8b61", "", 6, "", 8], ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18], ["8c41", "", 15, "", 4], ["8c61", "", 6, "", 5, "", 6, "", 5], ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16], ["8d41", "", 16, "", 8], ["8d61", "", 17, ""], ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""], ["8e41", "", 6, "", 5, "", 8], ["8e61", "", 4, "", 19], ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7], ["8f41", "", 7, "", 17], ["8f61", "", 7, "", 6, "", 4], ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5], ["9041", "", 6, "", 5, ""], ["9061", "", 5, "", 15], ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""], ["9141", "", 6, "", 5], ["9161", "", 9, "", 5], ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6], ["9241", "", 7, "", 4, ""], ["9261", "", 7, "", 7, "", 4], ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""], ["9341", "", 4, ""], ["9361", "", 6, "", 8], ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""], ["9441", "", 5, "", 5, "", 8], ["9461", "", 5, "", 6, "", 12], ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24], ["9541", "", 11, "", 5, ""], ["9561", "", 6, "", 5, ""], ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14], ["9641", "", 23, ""], ["9661", "", 6, "", 5, "", 8], ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44], ["9741", "", 16, "", 8], ["9761", "", 17, "", 7], ["9781", "", 11, "", 5, "", 6, "", 89, ""], ["9841", "", 16, "", 5, ""], ["9861", "", 6, "", 15], ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""], ["9941", "", 6, "", 5, ""], ["9961", "", 6, "", 5, ""], ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""], ["9a41", "", 16], ["9a61", "", 6, "", 6, ""], ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""], ["9b41", "", 6, "", 8], ["9b61", "", 17, "", 7], ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""], ["9c41", "", 4, "", 5, "", 5], ["9c61", "", 8, "", 6, "", 9], ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12], ["9d41", "", 13, "", 8], ["9d61", "", 25], ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""], ["9e41", "", 7, "", 9, ""], ["9e61", "", 4, "", 6, ""], ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""], ["9f41", "", 5, "", 4, "", 5, ""], ["9f61", "", 6, "", 5, ""], ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""], ["a041", "", 5, "", 6, ""], ["a061", "", 5, "", 13], ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""], ["a141", "", 18, ""], ["a161", "", 6, "", 5, ""], ["a181", "", 14, "", 5, "", 4, "", 9, ""], ["a241", "", 5, "", 18], ["a261", "", 6, "", 18], ["a281", "", 7, "", 6, "", 7, ""], ["a341", "", 6, "", 10, ""], ["a361", "", 6, "", 16], ["a381", "", 16, "", 4, "", 58, "", 32, ""], ["a441", "", 5, ""], ["a461", "", 5, "", 12], ["a481", "", 28, "", 93], ["a541", "", 4, "", 6, "", 5, ""], ["a561", "", 17, "", 5, ""], ["a581", "", 16, "", 14, "", 9], ["a5b0", "", 9], ["a5c1", "", 16, "", 6], ["a5e1", "", 16, "", 6], ["a641", "", 19, ""], ["a661", "", 5, "", 5, "", 6], ["a681", "", 6, "", 18, "", 7], ["a741", "", 4, "", 6, "", 7], ["a761", "", 22, ""], ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""], ["a841", "", 10, "", 14], ["a861", "", 18, "", 6], ["a881", "", 19, "", 11, ""], ["a8a6", ""], ["a8a8", ""], ["a8b1", "", 27, "", 25, "", 14, ""], ["a941", "", 14, "", 10], ["a961", "", 18], ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""], ["aa41", "", 6, "", 4, ""], ["aa61", "", 4, "", 5, "", 6, ""], ["aa81", "", 29, "", 82], ["ab41", "", 6, "", 5, ""], ["ab61", "", 6, "", 5, "", 5], ["ab81", "", 8, "", 6, "", 12, "", 85], ["ac41", "", 5, "", 6, ""], ["ac61", "", 11, "", 4], ["ac81", "", 28, "", 5, "", 25], ["acd1", "", 5, "", 25], ["ad41", "", 6, "", 5, "", 7], ["ad61", "", 6, "", 10, ""], ["ad81", "", 5, "", 18, ""], ["ae41", "", 5, "", 16], ["ae61", "", 5, "", 6, "", 4], ["ae81", "", 6, "", 5, ""], ["af41", "", 19], ["af61", "", 13, "", 5, ""], ["af81", "", 5, "", 6, "", 5, ""], ["b041", "", 5, "", 5, "", 12], ["b061", "", 5, "", 19], ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""], ["b141", "", 6, "", 5, ""], ["b161", "", 6, "", 5, "", 11], ["b181", "", 14, "", 6, ""], ["b241", "", 6, "", 5, ""], ["b261", "", 18, "", 5, ""], ["b281", "", 5, "", 18, "", 6, ""], ["b341", "", 19, ""], ["b361", "", 5, "", 5, "", 5], ["b381", "", 5, "", 5, "", 19, "", 4, ""], ["b441", "", 5, "", 6, "", 5], ["b461", "", 6, "", 10, ""], ["b481", "", 6, "", 18, "", 4, "", 4, ""], ["b541", "", 14, "", 5], ["b561", "", 5, "", 5, "", 4], ["b581", "", 6, "", 5, "", 11, ""], ["b641", "", 7, "", 17], ["b661", "", 15, ""], ["b681", "", 5, "", 6, "", 5, ""], ["b741", "", 13, "", 6, ""], ["b761", "", 20, ""], ["b781", "", 6, "", 14, ""], ["b841", "", 7, "", 17], ["b861", "", 8, "", 13], ["b881", "", 5, "", 24, "", 4, ""], ["b941", "", 6, "", 5, ""], ["b961", "", 14, "", 6, ""], ["b981", "", 22, "", 4, "", 4, ""], ["ba41", "", 5, "", 6, ""], ["ba61", "", 5, "", 4, "", 5], ["ba81", "", 6, "", 9, ""], ["bb41", "", 4, "", 5, "", 4, ""], ["bb61", "", 6, "", 5, ""], ["bb81", "", 31, ""], ["bc41", "", 17, ""], ["bc61", "", 5, "", 6, ""], ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""], ["bd41", "", 7, "", 7, ""], ["bd61", "", 5, "", 13], ["bd81", "", 5, "", 25, ""], ["be41", "", 7, "", 14], ["be61", "", 7, "", 7, ""], ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""], ["bf41", "", 10, "", 14], ["bf61", "", 18, ""], ["bf81", "", 5, "", 7, "", 6, "", 5, ""], ["c041", "", 5, "", 6, "", 5], ["c061", "", 25], ["c081", "", 6, "", 5, "", 7, ""], ["c141", "", 5, "", 6, ""], ["c161", "", 19, ""], ["c181", "", 31, ""], ["c241", "", 4, "", 5, ""], ["c261", "", 4, "", 5, "", 6, ""], ["c281", "", 5, "", 7, "", 9, ""], ["c341", "", 4], ["c361", "", 4, "", 5, "", 11], ["c381", "", 5, "", 7, "", 5, ""], ["c441", "", 7, "", 7, ""], ["c461", "", 5, "", 4], ["c481", "", 5, "", 11, ""], ["c541", "", 6, "", 5, ""], ["c561", "", 6, "", 5, "", 4], ["c581", "", 6, "", 5, ""], ["c641", "", 6, "", 5], ["c6a1", ""], ["c7a1", ""], ["c8a1", ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", "", 5, "", 4, ""], ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f5a1", ""], ["f6a1", ""], ["f7a1", ""], ["f8a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fda1", ""]];
    }, {}],
    22: [function (require, module, exports) {
      module.exports = [["0", "\0", 127], ["a140", ""], ["a1a1", "", 4, ""], ["a240", "", 7, ""], ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21], ["a340", "", 16, "", 6, "", 16, "", 6, "", 10], ["a3a1", "", 25, ""], ["a3e1", ""], ["a440", ""], ["a4a1", ""], ["a540", ""], ["a5a1", ""], ["a640", ""], ["a6a1", ""], ["a740", ""], ["a7a1", ""], ["a840", ""], ["a8a1", ""], ["a940", ""], ["a9a1", ""], ["aa40", ""], ["aaa1", ""], ["ab40", ""], ["aba1", ""], ["ac40", ""], ["aca1", ""], ["ad40", ""], ["ada1", ""], ["ae40", ""], ["aea1", ""], ["af40", ""], ["afa1", ""], ["b040", ""], ["b0a1", ""], ["b140", ""], ["b1a1", ""], ["b240", ""], ["b2a1", ""], ["b340", ""], ["b3a1", ""], ["b440", ""], ["b4a1", ""], ["b540", ""], ["b5a1", ""], ["b640", ""], ["b6a1", ""], ["b740", ""], ["b7a1", ""], ["b840", ""], ["b8a1", ""], ["b940", ""], ["b9a1", ""], ["ba40", ""], ["baa1", ""], ["bb40", ""], ["bba1", ""], ["bc40", ""], ["bca1", ""], ["bd40", ""], ["bda1", ""], ["be40", ""], ["bea1", ""], ["bf40", ""], ["bfa1", ""], ["c040", ""], ["c0a1", ""], ["c140", ""], ["c1a1", ""], ["c240", ""], ["c2a1", ""], ["c340", ""], ["c3a1", ""], ["c440", ""], ["c4a1", ""], ["c540", ""], ["c5a1", ""], ["c640", ""], ["c940", ""], ["c9a1", ""], ["ca40", ""], ["caa1", ""], ["cb40", ""], ["cba1", ""], ["cc40", ""], ["cca1", ""], ["cd40", ""], ["cda1", ""], ["ce40", ""], ["cea1", ""], ["cf40", ""], ["cfa1", ""], ["d040", ""], ["d0a1", ""], ["d140", ""], ["d1a1", ""], ["d240", ""], ["d2a1", ""], ["d340", ""], ["d3a1", ""], ["d440", ""], ["d4a1", ""], ["d540", ""], ["d5a1", ""], ["d640", ""], ["d6a1", ""], ["d740", ""], ["d7a1", ""], ["d840", ""], ["d8a1", ""], ["d940", ""], ["d9a1", ""], ["da40", ""], ["daa1", ""], ["db40", ""], ["dba1", ""], ["dc40", ""], ["dca1", ""], ["dd40", ""], ["dda1", ""], ["de40", ""], ["dea1", ""], ["df40", ""], ["dfa1", ""], ["e040", ""], ["e0a1", ""], ["e140", ""], ["e1a1", ""], ["e240", ""], ["e2a1", ""], ["e340", ""], ["e3a1", ""], ["e440", ""], ["e4a1", ""], ["e540", ""], ["e5a1", ""], ["e640", ""], ["e6a1", ""], ["e740", ""], ["e7a1", ""], ["e840", ""], ["e8a1", ""], ["e940", ""], ["e9a1", ""], ["ea40", ""], ["eaa1", ""], ["eb40", ""], ["eba1", ""], ["ec40", ""], ["eca1", ""], ["ed40", ""], ["eda1", ""], ["ee40", ""], ["eea1", ""], ["ef40", ""], ["efa1", ""], ["f040", ""], ["f0a1", ""], ["f140", ""], ["f1a1", ""], ["f240", ""], ["f2a1", ""], ["f340", ""], ["f3a1", ""], ["f440", ""], ["f4a1", ""], ["f540", ""], ["f5a1", ""], ["f640", ""], ["f6a1", ""], ["f740", ""], ["f7a1", ""], ["f840", ""], ["f8a1", ""], ["f940", ""], ["f9a1", ""]];
    }, {}],
    23: [function (require, module, exports) {
      module.exports = [["0", "\0", 127], ["8ea1", "", 62], ["a1a1", "", 9, ""], ["a2a1", ""], ["a2ba", ""], ["a2ca", ""], ["a2dc", ""], ["a2f2", ""], ["a2fe", ""], ["a3b0", "", 9], ["a3c1", "", 25], ["a3e1", "", 25], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a8a1", ""], ["ada1", "", 19, "", 9], ["adc0", ""], ["addf", "", 4, ""], ["b0a1", ""], ["b1a1", ""], ["b2a1", ""], ["b3a1", ""], ["b4a1", ""], ["b5a1", ""], ["b6a1", ""], ["b7a1", ""], ["b8a1", ""], ["b9a1", ""], ["baa1", ""], ["bba1", ""], ["bca1", ""], ["bda1", ""], ["bea1", ""], ["bfa1", ""], ["c0a1", ""], ["c1a1", ""], ["c2a1", ""], ["c3a1", ""], ["c4a1", ""], ["c5a1", ""], ["c6a1", ""], ["c7a1", ""], ["c8a1", ""], ["c9a1", ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", ""], ["d2a1", ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fcf1", "", 9, ""], ["8fa2af", ""], ["8fa2c2", ""], ["8fa2eb", ""], ["8fa6e1", ""], ["8fa6e7", ""], ["8fa6e9", ""], ["8fa6ec", ""], ["8fa6f1", ""], ["8fa7c2", "", 10, ""], ["8fa7f2", "", 10, ""], ["8fa9a1", ""], ["8fa9a4", ""], ["8fa9a6", ""], ["8fa9a8", ""], ["8fa9ab", ""], ["8fa9af", ""], ["8fa9c1", ""], ["8faaa1", ""], ["8faaba", ""], ["8faba1", ""], ["8fabbd", ""], ["8fabc5", ""], ["8fb0a1", ""], ["8fb1a1", ""], ["8fb2a1", "", 4, ""], ["8fb3a1", ""], ["8fb4a1", ""], ["8fb5a1", ""], ["8fb6a1", "", 5, "", 4, ""], ["8fb7a1", "", 4, ""], ["8fb8a1", ""], ["8fb9a1", ""], ["8fbaa1", "", 4, ""], ["8fbba1", ""], ["8fbca1", "", 4, ""], ["8fbda1", "", 4, ""], ["8fbea1", "", 4, ""], ["8fbfa1", ""], ["8fc0a1", ""], ["8fc1a1", ""], ["8fc2a1", ""], ["8fc3a1", "", 4, ""], ["8fc4a1", ""], ["8fc5a1", ""], ["8fc6a1", ""], ["8fc7a1", ""], ["8fc8a1", ""], ["8fc9a1", "", 4, "", 4, ""], ["8fcaa1", ""], ["8fcba1", ""], ["8fcca1", "", 9, ""], ["8fcda1", "", 5, ""], ["8fcea1", "", 6, ""], ["8fcfa1", ""], ["8fd0a1", ""], ["8fd1a1", ""], ["8fd2a1", "", 5], ["8fd3a1", ""], ["8fd4a1", "", 4, ""], ["8fd5a1", ""], ["8fd6a1", ""], ["8fd7a1", ""], ["8fd8a1", ""], ["8fd9a1", "", 4, "", 6, ""], ["8fdaa1", "", 4, ""], ["8fdba1", "", 6, ""], ["8fdca1", "", 4, ""], ["8fdda1", "", 4, ""], ["8fdea1", "", 4, ""], ["8fdfa1", ""], ["8fe0a1", ""], ["8fe1a1", "", 4, ""], ["8fe2a1", ""], ["8fe3a1", "", 5, "", 4, ""], ["8fe4a1", "", 4, ""], ["8fe5a1", "", 4, ""], ["8fe6a1", ""], ["8fe7a1", ""], ["8fe8a1", "", 4, ""], ["8fe9a1", "", 4], ["8feaa1", "", 4, ""], ["8feba1", "", 4, ""], ["8feca1", ""], ["8feda1", "", 4, "", 4, ""]];
    }, {}],
    24: [function (require, module, exports) {
      module.exports = {
        "uChars": [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536],
        "gbChars": [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000]
      };
    }, {}],
    25: [function (require, module, exports) {
      module.exports = [["a140", "", 62], ["a180", "", 32], ["a240", "", 62], ["a280", "", 32], ["a2ab", "", 5], ["a2e3", ""], ["a2ef", ""], ["a2fd", ""], ["a340", "", 62], ["a380", "", 31, ""], ["a440", "", 62], ["a480", "", 32], ["a4f4", "", 10], ["a540", "", 62], ["a580", "", 32], ["a5f7", "", 7], ["a640", "", 62], ["a680", "", 32], ["a6b9", "", 7], ["a6d9", "", 6], ["a6ec", ""], ["a6f3", ""], ["a6f6", "", 8], ["a740", "", 62], ["a780", "", 32], ["a7c2", "", 14], ["a7f2", "", 12], ["a896", "", 10], ["a8bc", ""], ["a8bf", ""], ["a8c1", ""], ["a8ea", "", 20], ["a958", ""], ["a95b", ""], ["a95d", ""], ["a989", "", 11], ["a997", "", 12], ["a9f0", "", 14], ["aaa1", "", 93], ["aba1", "", 93], ["aca1", "", 93], ["ada1", "", 93], ["aea1", "", 93], ["afa1", "", 93], ["d7fa", "", 4], ["f8a1", "", 93], ["f9a1", "", 93], ["faa1", "", 93], ["fba1", "", 93], ["fca1", "", 93], ["fda1", "", 93], ["fe50", ""], ["fe80", "", 6, "", 93]];
    }, {}],
    26: [function (require, module, exports) {
      module.exports = [["0", "\0", 128], ["a1", "", 62], ["8140", "", 9, ""], ["8180", ""], ["81b8", ""], ["81c8", ""], ["81da", ""], ["81f0", ""], ["81fc", ""], ["824f", "", 9], ["8260", "", 25], ["8281", "", 25], ["829f", "", 82], ["8340", "", 62], ["8380", "", 22], ["839f", "", 16, "", 6], ["83bf", "", 16, "", 6], ["8440", "", 5, "", 25], ["8470", "", 5, "", 7], ["8480", "", 17], ["849f", ""], ["8740", "", 19, "", 9], ["875f", ""], ["877e", ""], ["8780", "", 4, ""], ["889f", ""], ["8940", ""], ["8980", ""], ["8a40", ""], ["8a80", ""], ["8b40", ""], ["8b80", ""], ["8c40", ""], ["8c80", ""], ["8d40", ""], ["8d80", ""], ["8e40", ""], ["8e80", ""], ["8f40", ""], ["8f80", ""], ["9040", ""], ["9080", ""], ["9140", ""], ["9180", ""], ["9240", ""], ["9280", ""], ["9340", ""], ["9380", ""], ["9440", ""], ["9480", ""], ["9540", ""], ["9580", ""], ["9640", ""], ["9680", ""], ["9740", ""], ["9780", ""], ["9840", ""], ["989f", ""], ["9940", ""], ["9980", ""], ["9a40", ""], ["9a80", ""], ["9b40", ""], ["9b80", ""], ["9c40", ""], ["9c80", ""], ["9d40", ""], ["9d80", ""], ["9e40", ""], ["9e80", ""], ["9f40", ""], ["9f80", ""], ["e040", ""], ["e080", ""], ["e140", ""], ["e180", ""], ["e240", ""], ["e280", ""], ["e340", ""], ["e380", ""], ["e440", ""], ["e480", ""], ["e540", ""], ["e580", ""], ["e640", ""], ["e680", ""], ["e740", ""], ["e780", ""], ["e840", ""], ["e880", ""], ["e940", ""], ["e980", ""], ["ea40", ""], ["ea80", ""], ["ed40", ""], ["ed80", ""], ["ee40", ""], ["ee80", ""], ["eeef", "", 9, ""], ["f040", "", 62], ["f080", "", 124], ["f140", "", 62], ["f180", "", 124], ["f240", "", 62], ["f280", "", 124], ["f340", "", 62], ["f380", "", 124], ["f440", "", 62], ["f480", "", 124], ["f540", "", 62], ["f580", "", 124], ["f640", "", 62], ["f680", "", 124], ["f740", "", 62], ["f780", "", 124], ["f840", "", 62], ["f880", "", 124], ["f940", ""], ["fa40", "", 9, "", 9, ""], ["fa80", ""], ["fb40", ""], ["fb80", ""], ["fc40", ""]];
    }, {}],
    27: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

      // == UTF16-BE codec. ==========================================================

      exports.utf16be = Utf16BECodec;
      function Utf16BECodec() {}
      Utf16BECodec.prototype.encoder = Utf16BEEncoder;
      Utf16BECodec.prototype.decoder = Utf16BEDecoder;
      Utf16BECodec.prototype.bomAware = true;

      // -- Encoding

      function Utf16BEEncoder() {}
      Utf16BEEncoder.prototype.write = function (str) {
        var buf = Buffer.from(str, 'ucs2');
        for (var i = 0; i < buf.length; i += 2) {
          var tmp = buf[i];
          buf[i] = buf[i + 1];
          buf[i + 1] = tmp;
        }
        return buf;
      };
      Utf16BEEncoder.prototype.end = function () {};

      // -- Decoding

      function Utf16BEDecoder() {
        this.overflowByte = -1;
      }
      Utf16BEDecoder.prototype.write = function (buf) {
        if (buf.length == 0) return '';
        var buf2 = Buffer.alloc(buf.length + 1),
          i = 0,
          j = 0;
        if (this.overflowByte !== -1) {
          buf2[0] = buf[0];
          buf2[1] = this.overflowByte;
          i = 1;
          j = 2;
        }
        for (; i < buf.length - 1; i += 2, j += 2) {
          buf2[j] = buf[i + 1];
          buf2[j + 1] = buf[i];
        }
        this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
        return buf2.slice(0, j).toString('ucs2');
      };
      Utf16BEDecoder.prototype.end = function () {};

      // == UTF-16 codec =============================================================
      // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
      // Defaults to UTF-16LE, as it's prevalent and default in Node.
      // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
      // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

      // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

      exports.utf16 = Utf16Codec;
      function Utf16Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf16Codec.prototype.encoder = Utf16Encoder;
      Utf16Codec.prototype.decoder = Utf16Decoder;

      // -- Encoding (pass-through)

      function Utf16Encoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder('utf-16le', options);
      }
      Utf16Encoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf16Encoder.prototype.end = function () {
        return this.encoder.end();
      };

      // -- Decoding

      function Utf16Decoder(options, codec) {
        this.decoder = null;
        this.initialBytes = [];
        this.initialBytesLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf16Decoder.prototype.write = function (buf) {
        if (!this.decoder) {
          // Codec is not chosen yet. Accumulate initial bytes.
          this.initialBytes.push(buf);
          this.initialBytesLen += buf.length;
          if (this.initialBytesLen < 16)
            // We need more bytes to use space heuristic (see below)
            return '';

          // We have enough bytes -> detect endianness.
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          this.initialBytes.length = this.initialBytesLen = 0;
        }
        return this.decoder.write(buf);
      };
      Utf16Decoder.prototype.end = function () {
        if (!this.decoder) {
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var res = this.decoder.write(buf),
            trail = this.decoder.end();
          return trail ? res + trail : res;
        }
        return this.decoder.end();
      };
      function detectEncoding(buf, defaultEncoding) {
        var enc = defaultEncoding || 'utf-16le';
        if (buf.length >= 2) {
          // Check BOM.
          if (buf[0] == 0xFE && buf[1] == 0xFF)
            // UTF-16BE BOM
            enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE)
            // UTF-16LE BOM
            enc = 'utf-16le';else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0,
              asciiCharsBE = 0,
              // Counts of chars in both positions
              _len = Math.min(buf.length - buf.length % 2, 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
              if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
              if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
            }
            if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
          }
        }
        return enc;
      }
    }, {
      "safer-buffer": 56
    }],
    28: [function (require, module, exports) {
      'use strict';

      var Buffer = require('safer-buffer').Buffer;

      // == UTF32-LE/BE codec. ==========================================================

      exports._utf32 = Utf32Codec;
      function Utf32Codec(codecOptions, iconv) {
        this.iconv = iconv;
        this.bomAware = true;
        this.isLE = codecOptions.isLE;
      }
      exports.utf32le = {
        type: '_utf32',
        isLE: true
      };
      exports.utf32be = {
        type: '_utf32',
        isLE: false
      };

      // Aliases
      exports.ucs4le = 'utf32le';
      exports.ucs4be = 'utf32be';
      Utf32Codec.prototype.encoder = Utf32Encoder;
      Utf32Codec.prototype.decoder = Utf32Decoder;

      // -- Encoding

      function Utf32Encoder(options, codec) {
        this.isLE = codec.isLE;
        this.highSurrogate = 0;
      }
      Utf32Encoder.prototype.write = function (str) {
        var src = Buffer.from(str, 'ucs2');
        var dst = Buffer.alloc(src.length * 2);
        var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
        var offset = 0;
        for (var i = 0; i < src.length; i += 2) {
          var code = src.readUInt16LE(i);
          var isHighSurrogate = 0xD800 <= code && code < 0xDC00;
          var isLowSurrogate = 0xDC00 <= code && code < 0xE000;
          if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
              // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
              // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
              // (technically wrong, but expected by some applications, like Windows file names).
              write32.call(dst, this.highSurrogate, offset);
              offset += 4;
            } else {
              // Create 32-bit value from high and low surrogates;
              var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;
              write32.call(dst, codepoint, offset);
              offset += 4;
              this.highSurrogate = 0;
              continue;
            }
          }
          if (isHighSurrogate) this.highSurrogate = code;else {
            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
            // unpaired high surrogates.
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
          }
        }
        if (offset < dst.length) dst = dst.slice(0, offset);
        return dst;
      };
      Utf32Encoder.prototype.end = function () {
        // Treat any leftover high surrogate as a semi-valid independent character.
        if (!this.highSurrogate) return;
        var buf = Buffer.alloc(4);
        if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);
        this.highSurrogate = 0;
        return buf;
      };

      // -- Decoding

      function Utf32Decoder(options, codec) {
        this.isLE = codec.isLE;
        this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
        this.overflow = null;
      }
      Utf32Decoder.prototype.write = function (src) {
        if (src.length === 0) return '';
        if (this.overflow) src = Buffer.concat([this.overflow, src]);
        var goodLength = src.length - src.length % 4;
        if (src.length !== goodLength) {
          this.overflow = src.slice(goodLength);
          src = src.slice(0, goodLength);
        } else this.overflow = null;
        var dst = Buffer.alloc(goodLength);
        var offset = 0;
        for (var i = 0; i < goodLength; i += 4) {
          var codepoint = this.isLE ? src.readUInt32LE(i) : src.readUInt32BE(i);
          if (codepoint < 0x10000) {
            // Simple 16-bit character
            dst.writeUInt16LE(codepoint, offset);
            offset += 2;
          } else {
            if (codepoint > 0x10FFFF) {
              // Not a valid Unicode codepoint
              dst.writeUInt16LE(this.badChar, offset);
              offset += 2;
            } else {
              // Create high and low surrogates.
              codepoint -= 0x10000;
              var high = 0xD800 | codepoint >> 10;
              var low = 0xDC00 + (codepoint & 0x3FF);
              dst.writeUInt16LE(high, offset);
              offset += 2;
              dst.writeUInt16LE(low, offset);
              offset += 2;
            }
          }
        }
        return dst.slice(0, offset).toString('ucs2');
      };
      Utf32Decoder.prototype.end = function () {
        this.overflow = null;
      };

      // == UTF-32 Auto codec =============================================================
      // Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
      // Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
      // Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

      // Encoder prepends BOM (which can be overridden with (addBOM: false}).

      exports.utf32 = Utf32AutoCodec;
      exports.ucs4 = Utf32AutoCodec;
      function Utf32AutoCodec(options, iconv) {
        this.iconv = iconv;
      }
      Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
      Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

      // -- Encoding

      function Utf32AutoEncoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
      }
      Utf32AutoEncoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf32AutoEncoder.prototype.end = function () {
        return this.encoder.end();
      };

      // -- Decoding

      function Utf32AutoDecoder(options, codec) {
        this.decoder = null;
        this.initialBytes = [];
        this.initialBytesLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf32AutoDecoder.prototype.write = function (buf) {
        if (!this.decoder) {
          // Codec is not chosen yet. Accumulate initial bytes.
          this.initialBytes.push(buf);
          this.initialBytesLen += buf.length;
          if (this.initialBytesLen < 32)
            // We need more bytes to use space heuristic (see below)
            return '';

          // We have enough bytes -> detect endianness.
          var buf2 = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf2, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          this.initialBytes.length = this.initialBytesLen = 0;
        }
        return this.decoder.write(buf);
      };
      Utf32AutoDecoder.prototype.end = function () {
        if (!this.decoder) {
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var res = this.decoder.write(buf),
            trail = this.decoder.end();
          return trail ? res + trail : res;
        }
        return this.decoder.end();
      };
      function detectEncoding(buf, defaultEncoding) {
        var enc = defaultEncoding || 'utf-32le';
        if (buf.length >= 4) {
          // Check BOM.
          if (buf.readUInt32BE(0) === 0xFEFF)
            // UTF-32LE BOM
            enc = 'utf-32be';else if (buf.readUInt32LE(0) === 0xFEFF)
            // UTF-32LE BOM
            enc = 'utf-32le';else {
            // No BOM found. Try to deduce encoding from initial content.
            // Using the wrong endian-ism for UTF-32 will very often result in codepoints that are beyond
            // the valid Unicode limit of 0x10FFFF. That will be used as the primary determinant.
            //
            // Further, we can suppose the content is mostly plain ASCII chars (U+00**).
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var invalidLE = 0,
              invalidBE = 0;
            var asciiCharsLE = 0,
              asciiCharsBE = 0,
              // Counts of chars in both positions
              _len = Math.min(buf.length - buf.length % 4, 128); // Len is always even.

            for (var i = 0; i < _len; i += 4) {
              var b0 = buf[i],
                b1 = buf[i + 1],
                b2 = buf[i + 2],
                b3 = buf[i + 3];
              if (b0 !== 0 || b1 > 0x10) ++invalidBE;
              if (b3 !== 0 || b2 > 0x10) ++invalidLE;
              if (b0 === 0 && b1 === 0 && b2 === 0 && b3 !== 0) asciiCharsBE++;
              if (b0 !== 0 && b1 === 0 && b2 === 0 && b3 === 0) asciiCharsLE++;
            }
            if (invalidBE < invalidLE) enc = 'utf-32be';else if (invalidLE < invalidBE) enc = 'utf-32le';
            if (asciiCharsBE > asciiCharsLE) enc = 'utf-32be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-32le';
          }
        }
        return enc;
      }
    }, {
      "safer-buffer": 56
    }],
    29: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
      // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

      exports.utf7 = Utf7Codec;
      exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
      function Utf7Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      ;
      Utf7Codec.prototype.encoder = Utf7Encoder;
      Utf7Codec.prototype.decoder = Utf7Decoder;
      Utf7Codec.prototype.bomAware = true;

      // -- Encoding

      var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
      function Utf7Encoder(options, codec) {
        this.iconv = codec.iconv;
      }
      Utf7Encoder.prototype.write = function (str) {
        // Naive implementation.
        // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
        return Buffer.from(str.replace(nonDirectChars, function (chunk) {
          return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
        }.bind(this)));
      };
      Utf7Encoder.prototype.end = function () {};

      // -- Decoding

      function Utf7Decoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = '';
      }
      var base64Regex = /[A-Za-z0-9\/+]/;
      var base64Chars = [];
      for (var i = 0; i < 256; i++) {
        base64Chars[i] = base64Regex.test(String.fromCharCode(i));
      }
      var plusChar = '+'.charCodeAt(0),
        minusChar = '-'.charCodeAt(0),
        andChar = '&'.charCodeAt(0);
      Utf7Decoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.

        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            // We decode base64.
            if (!base64Chars[buf[i]]) {
              // Base64 ended.
              if (i == lastI && buf[i] == minusChar) {
                // "+-" -> "+"
                res += "+";
              } else {
                var b64str = base64Accum + buf.slice(lastI, i).toString();
                res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
              }
              if (buf[i] != minusChar)
                // Minus is absorbed after base64.
                i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = '';
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
          var b64str = base64Accum + buf.slice(lastI).toString();
          var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
          base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7Decoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
      };

      // UTF-7-IMAP codec.
      // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
      // Differences:
      //  * Base64 part is started by "&" instead of "+"
      //  * Direct characters are 0x20-0x7E, except "&" (0x26)
      //  * In Base64, "," is used instead of "/"
      //  * Base64 must not be used to represent direct characters.
      //  * No implicit shift back from Base64 (should always end with '-')
      //  * String must end in non-shifted position.
      //  * "-&" while in base64 is not allowed.

      exports.utf7imap = Utf7IMAPCodec;
      function Utf7IMAPCodec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      ;
      Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
      Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
      Utf7IMAPCodec.prototype.bomAware = true;

      // -- Encoding

      function Utf7IMAPEncoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = Buffer.alloc(6);
        this.base64AccumIdx = 0;
      }
      Utf7IMAPEncoder.prototype.write = function (str) {
        var inBase64 = this.inBase64,
          base64Accum = this.base64Accum,
          base64AccumIdx = this.base64AccumIdx,
          buf = Buffer.alloc(str.length * 5 + 10),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var uChar = str.charCodeAt(i);
          if (0x20 <= uChar && uChar <= 0x7E) {
            // Direct character or '&'.
            if (inBase64) {
              if (base64AccumIdx > 0) {
                bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                base64AccumIdx = 0;
              }
              buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
              inBase64 = false;
            }
            if (!inBase64) {
              buf[bufIdx++] = uChar; // Write direct character

              if (uChar === andChar)
                // Ampersand -> '&-'
                buf[bufIdx++] = minusChar;
            }
          } else {
            // Non-direct character
            if (!inBase64) {
              buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
              inBase64 = true;
            }
            if (inBase64) {
              base64Accum[base64AccumIdx++] = uChar >> 8;
              base64Accum[base64AccumIdx++] = uChar & 0xFF;
              if (base64AccumIdx == base64Accum.length) {
                bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                base64AccumIdx = 0;
              }
            }
          }
        }
        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;
        return buf.slice(0, bufIdx);
      };
      Utf7IMAPEncoder.prototype.end = function () {
        var buf = Buffer.alloc(10),
          bufIdx = 0;
        if (this.inBase64) {
          if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
          this.inBase64 = false;
        }
        return buf.slice(0, bufIdx);
      };

      // -- Decoding

      function Utf7IMAPDecoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = '';
      }
      var base64IMAPChars = base64Chars.slice();
      base64IMAPChars[','.charCodeAt(0)] = true;
      Utf7IMAPDecoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.
        // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            // We decode base64.
            if (!base64IMAPChars[buf[i]]) {
              // Base64 ended.
              if (i == lastI && buf[i] == minusChar) {
                // "&-" -> "&"
                res += "&";
              } else {
                var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
              }
              if (buf[i] != minusChar)
                // Minus may be absorbed after base64.
                i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = '';
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
          var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
          var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
          base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7IMAPDecoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
      };
    }, {
      "safer-buffer": 56
    }],
    30: [function (require, module, exports) {
      "use strict";

      var BOMChar = "\uFEFF";
      exports.PrependBOM = PrependBOMWrapper;
      function PrependBOMWrapper(encoder, options) {
        this.encoder = encoder;
        this.addBOM = true;
      }
      PrependBOMWrapper.prototype.write = function (str) {
        if (this.addBOM) {
          str = BOMChar + str;
          this.addBOM = false;
        }
        return this.encoder.write(str);
      };
      PrependBOMWrapper.prototype.end = function () {
        return this.encoder.end();
      };

      //------------------------------------------------------------------------------

      exports.StripBOM = StripBOMWrapper;
      function StripBOMWrapper(decoder, options) {
        this.decoder = decoder;
        this.pass = false;
        this.options = options || {};
      }
      StripBOMWrapper.prototype.write = function (buf) {
        var res = this.decoder.write(buf);
        if (this.pass || !res) return res;
        if (res[0] === BOMChar) {
          res = res.slice(1);
          if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
        }
        this.pass = true;
        return res;
      };
      StripBOMWrapper.prototype.end = function () {
        return this.decoder.end();
      };
    }, {}],
    31: [function (require, module, exports) {
      (function (process) {
        (function () {
          "use strict";

          // Some environments don't have global Buffer (e.g. React Native).
          // Solution would be installing npm modules "buffer" and "stream" explicitly.
          var Buffer = require("safer-buffer").Buffer;
          var bomHandling = require("./bom-handling"),
            iconv = module.exports;

          // All codecs and aliases are kept here, keyed by encoding name/alias.
          // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
          iconv.encodings = null;

          // Characters emitted in case of error.
          iconv.defaultCharUnicode = '';
          iconv.defaultCharSingleByte = '?';

          // Public API.
          iconv.encode = function encode(str, encoding, options) {
            str = "" + (str || ""); // Ensure string.

            var encoder = iconv.getEncoder(encoding, options);
            var res = encoder.write(str);
            var trail = encoder.end();
            return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
          };
          iconv.decode = function decode(buf, encoding, options) {
            if (typeof buf === 'string') {
              if (!iconv.skipDecodeWarning) {
                console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
                iconv.skipDecodeWarning = true;
              }
              buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
            }

            var decoder = iconv.getDecoder(encoding, options);
            var res = decoder.write(buf);
            var trail = decoder.end();
            return trail ? res + trail : res;
          };
          iconv.encodingExists = function encodingExists(enc) {
            try {
              iconv.getCodec(enc);
              return true;
            } catch (e) {
              return false;
            }
          };

          // Legacy aliases to convert functions
          iconv.toEncoding = iconv.encode;
          iconv.fromEncoding = iconv.decode;

          // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
          iconv._codecDataCache = {};
          iconv.getCodec = function getCodec(encoding) {
            if (!iconv.encodings) iconv.encodings = require("../encodings"); // Lazy load all encoding definitions.

            // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
            var enc = iconv._canonicalizeEncoding(encoding);

            // Traverse iconv.encodings to find actual codec.
            var codecOptions = {};
            while (true) {
              var codec = iconv._codecDataCache[enc];
              if (codec) return codec;
              var codecDef = iconv.encodings[enc];
              switch (_typeof(codecDef)) {
                case "string":
                  // Direct alias to other encoding.
                  enc = codecDef;
                  break;
                case "object":
                  // Alias with options. Can be layered.
                  for (var key in codecDef) {
                    codecOptions[key] = codecDef[key];
                  }
                  if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                  enc = codecDef.type;
                  break;
                case "function":
                  // Codec itself.
                  if (!codecOptions.encodingName) codecOptions.encodingName = enc;

                  // The codec function must load all tables and return object with .encoder and .decoder methods.
                  // It'll be called only once (for each different options object).
                  codec = new codecDef(codecOptions, iconv);
                  iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                  return codec;
                default:
                  throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
              }
            }
          };
          iconv._canonicalizeEncoding = function (encoding) {
            // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
            return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
          };
          iconv.getEncoder = function getEncoder(encoding, options) {
            var codec = iconv.getCodec(encoding),
              encoder = new codec.encoder(options, codec);
            if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
            return encoder;
          };
          iconv.getDecoder = function getDecoder(encoding, options) {
            var codec = iconv.getCodec(encoding),
              decoder = new codec.decoder(options, codec);
            if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
            return decoder;
          };

          // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
          var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
          if (nodeVer) {
            // Load streaming support in Node v0.10+
            var nodeVerArr = nodeVer.split(".").map(Number);
            if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
              require("./streams")(iconv);
            }

            // Load Node primitive extensions.
            require("./extend-node")(iconv);
          }
          if ("" != "\u0100") {
            console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
          }
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "../encodings": 14,
      "./bom-handling": 30,
      "./extend-node": 5,
      "./streams": 5,
      "_process": 36,
      "safer-buffer": 56
    }],
    32: [function (require, module, exports) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128;
      };
    }, {}],
    33: [function (require, module, exports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function TempCtor() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }, {}],
    34: [function (require, module, exports) {
      //! moment.js
      //! version : 2.29.4
      //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
      //! license : MIT
      //! momentjs.com

      ;
      (function (global, factory) {
        _typeof(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
      })(this, function () {
        'use strict';

        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
        }
        function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
        }
        function map(arr, fn) {
          var res = [],
            i,
            arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
        }
        function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function some(fun) {
            var t = Object(this),
              len = t.length >>> 0,
              i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m),
              parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
              }),
              isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = hooks.momentProperties = [],
          updateInProgress = false;
        function copyConfig(to, from) {
          var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
            to._i = from._i;
          }
          if (!isUndefined(from._f)) {
            to._f = from._f;
          }
          if (!isUndefined(from._l)) {
            to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
            to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
            to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
            to._locale = from._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from[prop];
              if (!isUndefined(val)) {
                to[prop] = val;
              }
            }
          }
          return to;
        }

        // Moment prototype object
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function () {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [],
                arg,
                i,
                key,
                argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = '';
                if (_typeof(arguments[i]) === 'object') {
                  arg += '\n[' + i + '] ';
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ': ' + arguments[0][key] + ', ';
                    }
                  }
                  arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
        }
        function set(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this['_' + i] = prop;
              }
            }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
            prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function keys(obj) {
            var i,
              res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        };
        function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
          return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
            func = function func() {
              return this[callback]();
            };
          }
          if (token) {
            formatTokenFunctions[token] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(func.apply(this, arguments), token);
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
        }
        function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
            i,
            length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function (mom) {
            var output = '',
              i;
            for (i = 0; i < length; i++) {
              output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
          };
        }

        // format date using native date object
        function formatMoment(m, format) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
          return formatFunctions[format](m);
        }
        function expandFormat(format, locale) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format;
        }
        var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        };
        function longDateFormat(key) {
          var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format || !formatUpper) {
            return format;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
            if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
              return tok.slice(1);
            }
            return tok;
          }).join('');
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = 'Invalid date';
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace('%d', number);
        }
        var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
            normalizedProp,
            prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [],
            u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({
                unit: u,
                priority: priorities[u]
              });
            }
          }
          units.sort(function (a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
            value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function (value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
          }
        }

        // MOMENTS

        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (_typeof(units) === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
              i,
              prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/,
          //       0 - 9
          match2 = /\d\d/,
          //      00 - 99
          match3 = /\d{3}/,
          //     000 - 999
          match4 = /\d{4}/,
          //    0000 - 9999
          match6 = /[+-]?\d{6}/,
          // -999999 - 999999
          match1to2 = /\d\d?/,
          //       0 - 99
          match3to4 = /\d\d\d\d?/,
          //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/,
          //   99999 - 999999
          match1to3 = /\d{1,3}/,
          //       0 - 999
          match1to4 = /\d{1,4}/,
          //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/,
          // -999999 - 999999
          matchUnsigned = /\d+/,
          //       0 - inf
          matchSigned = /[+-]?\d+/,
          //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi,
          // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
          // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
          // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          regexes;
        regexes = {};
        function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
          }
          return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }
        var tokens = {};
        function addParseToken(token, callback) {
          var i,
            func = callback,
            tokenLen;
          if (typeof token === 'string') {
            token = [token];
          }
          if (isNumber(callback)) {
            func = function func(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
          }
        }
        function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
          });
        }
        function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
          }
        }
        var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function indexOf(o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
        });
        addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
        });
        addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
        });
        addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
          defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;
        function localeMonths(m, format) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months['standalone'];
          }
          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
        }
        function localeMonthsShort(m, format) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
        }
        function handleStrictParse(monthName, format, strict) {
          var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
              this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
              regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            // No op
            return mom;
          }
          if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              // TODO: Another silent failure?
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, 'Month');
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });
        addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
        });
        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);
        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
          var
            // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);
        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');
        addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
        });
        addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
        });
        addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
        });
        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
        });
        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format, strict) {
          var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
              this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
              this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
              regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);
        addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }
        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
        }
        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);
        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);
        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);
        function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'pm' : 'PM';
          } else {
            return isLower ? 'am' : 'AM';
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };

        // internal storage for locale config files
        var locales = {},
          localeFamilies = {},
          globalLocale;
        function commonPrefix(arr1, arr2) {
          var i,
            minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
          var i = 0,
            j,
            next,
            locale,
            split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));
              if (locale) {
                return locale;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          // Prevent names that look like filesystem paths, i.e contain '/' or '\'
          return name.match('^[^/\\\\]*$') != null;
        }
        function loadLocale(name) {
          var oldLocale = null,
            aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (locales[name] === undefined && typeof module !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = require;
              aliasedRequire('./locale/' + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              // mark as not found to avoid repeating expensive file require call causing high CPU
              // when trying to find en-US, en_US, en-us for every format call
              locales[name] = null; // null means not found
            }
          }

          return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
            } else {
              if (typeof console !== 'undefined' && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn('Locale ' + key + ' not found. Did you forget to load it?');
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale,
              parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                  parentConfig = locale._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
              });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            // useful for testing
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale,
              tmpLocale,
              parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              // Update existing child locale in-place to avoid memory-leaks
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                // updateLocale is called for creating a new locale
                // Set abbr so it will have a name (getters return
                // undefined otherwise).
                config.abbr = name;
              }
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
          } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }

        // returns locale data
        function getLocale(key) {
          var locale;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
              return locale;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow,
            a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
          // iso time formats and regexes
          isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60
          };

        // date from iso format
        function configFromISO(config) {
          var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  // match[2] should be 'T' or space
                  timeFormat = (match[2] || ' ') + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2000 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s.replace(/\([^()]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
              weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
          } else {
            var hm = parseInt(numOffset, 10),
              m = hm % 100,
              h = (hm - m) / 100;
            return h * 60 + m;
          }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        });

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
          var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              // local weekday -- counting starts from beginning of week
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              // default to beginning of week
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;
          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens.length;
          for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token);
              }
              addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
            }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;
          if (meridiem == null) {
            // nothing to do
            return hour;
          }
          if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            // this is not supposed to happen
            return hour;
          }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
          var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i,
            format = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format === undefined && input === '') {
            return createInvalid({
              nullInput: true
            });
          }
          if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format)) {
            configFromStringAndArray(config);
          } else if (format) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};
          if (format === true || format === false) {
            strict = format;
            format = undefined;
          }
          if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
          }
          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
        }
        var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }),
          prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          });

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }

        // TODO: Use [].sort instead?
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isBefore', args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isAfter', args);
        }
        var now = function now() {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
        function isDurationValid(m) {
          var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
              }

              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds = +milliseconds + seconds * 1e3 +
          // 1000
          minutes * 6e4 +
          // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
              sign = '+';
            if (offset < 0) {
              offset = -offset;
              sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
          });
        }
        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);
          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
            localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, 'm');
            }
            if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== 'string') {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {},
            other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign,
              h: toInt(match[HOUR]) * sign,
              m: toInt(match[MINUTE]) * sign,
              s: toInt(match[SECOND]) * sign,
              ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign)
            };
          } else if (duration == null) {
            // checks for null or undefined
            duration = {};
          } else if (_typeof(duration) === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, 'M');
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return {
              milliseconds: 0,
              months: 0
            };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
          return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
          if (!mom.isValid()) {
            // No op
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days || months);
          }
        }
        var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');
        function isString(input) {
          return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
            i,
            property,
            propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input),
            dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function (item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
            i,
            property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        }
        function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = undefined;
              formats = undefined;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = undefined;
            }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case 'year':
              output = monthDiff(this, that) / 12;
              break;
            case 'month':
              output = monthDiff(this, that);
              break;
            case 'quarter':
              output = monthDiff(this, that) / 3;
              break;
            case 'second':
              output = (this - that) / 1e3;
              break;
            // 1000
            case 'minute':
              output = (this - that) / 6e4;
              break;
            // 1000 * 60
            case 'hour':
              output = (this - that) / 36e5;
              break;
            // 1000 * 60 * 60
            case 'day':
              output = (this - that - zoneDelta) / 864e5;
              break;
            // 1000 * 60 * 60 * 24, negate dst
            case 'week':
              output = (this - that - zoneDelta) / 6048e5;
              break;
            // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
        function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }
          if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
          }
          return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
          if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              to: this,
              from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              from: this,
              to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
          var newLocaleData;
          if (key === undefined) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
          if (key === undefined) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year(), 0, 1);
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
            case 'month':
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case 'hour':
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
            case 'minute':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case 'second':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case 'month':
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case 'hour':
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
            case 'minute':
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case 'second':
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1000);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');
        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);
        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
          var era = config._locale.erasParse(input, token, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);
        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format) {
          var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (_typeof(eras[i].since)) {
              case 'string':
                // truncate time
                date = hooks(eras[i].since).startOf('day');
                eras[i].since = date.valueOf();
                break;
            }
            switch (_typeof(eras[i].until)) {
              case 'undefined':
                eras[i].until = +Infinity;
                break;
              case 'string':
                // truncate time
                date = hooks(eras[i].until).startOf('day').valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format, strict) {
          var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format) {
                case 'N':
                case 'NN':
                case 'NNN':
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNN':
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNNN':
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return '';
        }
        function getEraNarrow() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return '';
        }
        function getEraAbbr() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return '';
        }
        function getEraYear() {
          var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
        }
        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);
        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);
        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }
        for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
        }
        function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
        proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
        proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
        proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
        proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
        function createUnix(input) {
          return createLocal(input * 1000);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format, index, field, setter) {
          var locale = getLocale(),
            utc = createUTC().set(setter, index);
          return locale[field](utc, format);
        }
        function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || '';
          if (index != null) {
            return get$1(format, index, field, 'month');
          }
          var i,
            out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
          }
          return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          }
          var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];
          if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
        }
        function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
        }
        function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
        }
        function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }
        function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }
        function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }
        getSetGlobalLocale('en', {
          eras: [{
            since: '0001-01-01',
            until: +Infinity,
            offset: 1,
            name: 'Anno Domini',
            narrow: 'AD',
            abbr: 'AD'
          }, {
            since: '0000-12-31',
            until: -Infinity,
            offset: 1,
            name: 'Before Christ',
            narrow: 'BC',
            abbr: 'BC'
          }],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function ordinal(number) {
            var b = number % 10,
              output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
          }
        });

        // Side effect imports

        hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
        hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;
          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;
          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;
          hours = absFloor(minutes / 60);
          data.hours = hours % 24;
          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;
          data.days = days;
          data.months = months;
          data.years = years;
          return this;
        }
        function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
        }
        function monthsToDays(months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days,
            months,
            milliseconds = this._milliseconds;
          units = normalizeUnits(units);
          if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
              case 'month':
                return months;
              case 'quarter':
                return months / 3;
              case 'year':
                return months / 12;
            }
          } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case 'week':
                return days / 7 + milliseconds / 6048e5;
              case 'day':
                return days + milliseconds / 864e5;
              case 'hour':
                return days * 24 + milliseconds / 36e5;
              case 'minute':
                return days * 1440 + milliseconds / 6e4;
              case 'second':
                return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here
              case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;
              default:
                throw new Error('Unknown unit ' + units);
            }
          }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function () {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y');
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
        }
        function makeGetter(name) {
          return function () {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round,
          thresholds = {
            ss: 44,
            // a few seconds to seconds
            s: 45,
            // seconds to minute
            m: 45,
            // minutes to hour
            h: 22,
            // hours to day
            d: 26,
            // days to month/week
            w: null,
            // weeks to month
            M: 11 // months to year
          };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];
          if (thresholds.w != null) {
            a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
          }
          a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
            return round;
          }
          if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
          }
          return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
            return false;
          }
          if (limit === undefined) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false,
            th = thresholds,
            locale,
            output;
          if (_typeof(argWithSuffix) === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
          }
          if (_typeof(argThresholds) === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);
          if (withSuffix) {
            output = locale.pastFuture(+this, output);
          }
          return locale.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;
          if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
          return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.4';
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
          // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD',
          // <input type="date" />
          TIME: 'HH:mm',
          // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss',
          // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS',
          // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW',
          // <input type="week" />
          MONTH: 'YYYY-MM' // <input type="month" />
        };

        return hooks;
      });
    }, {}],
    35: [function (require, module, exports) {
      (function (process) {
        (function () {
          // 'path' module extracted from Node.js v8.11.1 (only the posix part)
          // transplited with Babel

          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          'use strict';

          function assertPath(path) {
            if (typeof path !== 'string') {
              throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
            }
          }

          // Resolves . and .. elements in a path with directory names
          function normalizeStringPosix(path, allowAboveRoot) {
            var res = '';
            var lastSegmentLength = 0;
            var lastSlash = -1;
            var dots = 0;
            var code;
            for (var i = 0; i <= path.length; ++i) {
              if (i < path.length) code = path.charCodeAt(i);else if (code === 47 /*/*/) break;else code = 47 /*/*/;
              if (code === 47 /*/*/) {
                if (lastSlash === i - 1 || dots === 1) {
                  // NOOP
                } else if (lastSlash !== i - 1 && dots === 2) {
                  if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
                    if (res.length > 2) {
                      var lastSlashIndex = res.lastIndexOf('/');
                      if (lastSlashIndex !== res.length - 1) {
                        if (lastSlashIndex === -1) {
                          res = '';
                          lastSegmentLength = 0;
                        } else {
                          res = res.slice(0, lastSlashIndex);
                          lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                      }
                    } else if (res.length === 2 || res.length === 1) {
                      res = '';
                      lastSegmentLength = 0;
                      lastSlash = i;
                      dots = 0;
                      continue;
                    }
                  }
                  if (allowAboveRoot) {
                    if (res.length > 0) res += '/..';else res = '..';
                    lastSegmentLength = 2;
                  }
                } else {
                  if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
                  lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
              } else if (code === 46 /*.*/ && dots !== -1) {
                ++dots;
              } else {
                dots = -1;
              }
            }
            return res;
          }
          function _format(sep, pathObject) {
            var dir = pathObject.dir || pathObject.root;
            var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
            if (!dir) {
              return base;
            }
            if (dir === pathObject.root) {
              return dir + base;
            }
            return dir + sep + base;
          }
          var posix = {
            // path.resolve([from ...], to)
            resolve: function resolve() {
              var resolvedPath = '';
              var resolvedAbsolute = false;
              var cwd;
              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path;
                if (i >= 0) path = arguments[i];else {
                  if (cwd === undefined) cwd = process.cwd();
                  path = cwd;
                }
                assertPath(path);

                // Skip empty entries
                if (path.length === 0) {
                  continue;
                }
                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
              if (resolvedAbsolute) {
                if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
              } else if (resolvedPath.length > 0) {
                return resolvedPath;
              } else {
                return '.';
              }
            },
            normalize: function normalize(path) {
              assertPath(path);
              if (path.length === 0) return '.';
              var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
              var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

              // Normalize the path
              path = normalizeStringPosix(path, !isAbsolute);
              if (path.length === 0 && !isAbsolute) path = '.';
              if (path.length > 0 && trailingSeparator) path += '/';
              if (isAbsolute) return '/' + path;
              return path;
            },
            isAbsolute: function isAbsolute(path) {
              assertPath(path);
              return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
            },

            join: function join() {
              if (arguments.length === 0) return '.';
              var joined;
              for (var i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                assertPath(arg);
                if (arg.length > 0) {
                  if (joined === undefined) joined = arg;else joined += '/' + arg;
                }
              }
              if (joined === undefined) return '.';
              return posix.normalize(joined);
            },
            relative: function relative(from, to) {
              assertPath(from);
              assertPath(to);
              if (from === to) return '';
              from = posix.resolve(from);
              to = posix.resolve(to);
              if (from === to) return '';

              // Trim any leading backslashes
              var fromStart = 1;
              for (; fromStart < from.length; ++fromStart) {
                if (from.charCodeAt(fromStart) !== 47 /*/*/) break;
              }
              var fromEnd = from.length;
              var fromLen = fromEnd - fromStart;

              // Trim any leading backslashes
              var toStart = 1;
              for (; toStart < to.length; ++toStart) {
                if (to.charCodeAt(toStart) !== 47 /*/*/) break;
              }
              var toEnd = to.length;
              var toLen = toEnd - toStart;

              // Compare paths to find the longest common path from root
              var length = fromLen < toLen ? fromLen : toLen;
              var lastCommonSep = -1;
              var i = 0;
              for (; i <= length; ++i) {
                if (i === length) {
                  if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                      // We get here if `from` is the exact base path for `to`.
                      // For example: from='/foo/bar'; to='/foo/bar/baz'
                      return to.slice(toStart + i + 1);
                    } else if (i === 0) {
                      // We get here if `from` is the root
                      // For example: from='/'; to='/foo'
                      return to.slice(toStart + i);
                    }
                  } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                      // We get here if `to` is the exact base path for `from`.
                      // For example: from='/foo/bar/baz'; to='/foo/bar'
                      lastCommonSep = i;
                    } else if (i === 0) {
                      // We get here if `to` is the root.
                      // For example: from='/foo'; to='/'
                      lastCommonSep = 0;
                    }
                  }
                  break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                var toCode = to.charCodeAt(toStart + i);
                if (fromCode !== toCode) break;else if (fromCode === 47 /*/*/) lastCommonSep = i;
              }
              var out = '';
              // Generate the relative path based on the path difference between `to`
              // and `from`
              for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
                  if (out.length === 0) out += '..';else out += '/..';
                }
              }

              // Lastly, append the rest of the destination (`to`) path that comes after
              // the common path parts
              if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
                toStart += lastCommonSep;
                if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;
                return to.slice(toStart);
              }
            },
            _makeLong: function _makeLong(path) {
              return path;
            },
            dirname: function dirname(path) {
              assertPath(path);
              if (path.length === 0) return '.';
              var code = path.charCodeAt(0);
              var hasRoot = code === 47 /*/*/;
              var end = -1;
              var matchedSlash = true;
              for (var i = path.length - 1; i >= 1; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                  if (!matchedSlash) {
                    end = i;
                    break;
                  }
                } else {
                  // We saw the first non-path separator
                  matchedSlash = false;
                }
              }
              if (end === -1) return hasRoot ? '/' : '.';
              if (hasRoot && end === 1) return '//';
              return path.slice(0, end);
            },
            basename: function basename(path, ext) {
              if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
              assertPath(path);
              var start = 0;
              var end = -1;
              var matchedSlash = true;
              var i;
              if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path) return '';
                var extIdx = ext.length - 1;
                var firstNonSlashEnd = -1;
                for (i = path.length - 1; i >= 0; --i) {
                  var code = path.charCodeAt(i);
                  if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      start = i + 1;
                      break;
                    }
                  } else {
                    if (firstNonSlashEnd === -1) {
                      // We saw the first non-path separator, remember this index in case
                      // we need it if the extension ends up not matching
                      matchedSlash = false;
                      firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                      // Try to match the explicit extension
                      if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                          // We matched the extension, so mark this as the end of our path
                          // component
                          end = i;
                        }
                      } else {
                        // Extension does not match, so our result is the entire path
                        // component
                        extIdx = -1;
                        end = firstNonSlashEnd;
                      }
                    }
                  }
                }
                if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
                return path.slice(start, end);
              } else {
                for (i = path.length - 1; i >= 0; --i) {
                  if (path.charCodeAt(i) === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      start = i + 1;
                      break;
                    }
                  } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                  }
                }
                if (end === -1) return '';
                return path.slice(start, end);
              }
            },
            extname: function extname(path) {
              assertPath(path);
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;
              for (var i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                  // If we reached a path separator that was not part of a set of path
                  // separators at the end of the string, stop now
                  if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                  }
                  continue;
                }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                  // If this is our first dot, mark it as the start of our extension
                  if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
                } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }
              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                return '';
              }
              return path.slice(startDot, end);
            },
            format: function format(pathObject) {
              if (pathObject === null || _typeof(pathObject) !== 'object') {
                throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + _typeof(pathObject));
              }
              return _format('/', pathObject);
            },
            parse: function parse(path) {
              assertPath(path);
              var ret = {
                root: '',
                dir: '',
                base: '',
                ext: '',
                name: ''
              };
              if (path.length === 0) return ret;
              var code = path.charCodeAt(0);
              var isAbsolute = code === 47 /*/*/;
              var start;
              if (isAbsolute) {
                ret.root = '/';
                start = 1;
              } else {
                start = 0;
              }
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              var i = path.length - 1;

              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;

              // Get non-dir info
              for (; i >= start; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                  // If we reached a path separator that was not part of a set of path
                  // separators at the end of the string, stop now
                  if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                  }
                  continue;
                }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                  // If this is our first dot, mark it as the start of our extension
                  if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
                } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }
              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                if (end !== -1) {
                  if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
                }
              } else {
                if (startPart === 0 && isAbsolute) {
                  ret.name = path.slice(1, startDot);
                  ret.base = path.slice(1, end);
                } else {
                  ret.name = path.slice(startPart, startDot);
                  ret.base = path.slice(startPart, end);
                }
                ret.ext = path.slice(startDot, end);
              }
              if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
              return ret;
            },
            sep: '/',
            delimiter: ':',
            win32: null,
            posix: null
          };
          posix.posix = posix;
          module.exports = posix;
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "_process": 36
    }],
    36: [function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};
      function noop() {}
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function (name) {
        return [];
      };
      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };
      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };
    }, {}],
    37: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ProcessTokens = exports.procTokensDefaultOptions = void 0;
          var stream_1 = require("stream");
          var decode_1 = require("./decode");
          var utils_1 = require("./utils");
          var defaultStringDecoder = function defaultStringDecoder(buf, enc) {
            return buf.toString(enc);
          };
          var defaultStringEncoder = function defaultStringEncoder(str, enc) {
            return Buffer.from(str, enc);
          };
          exports.procTokensDefaultOptions = {
            decode: defaultStringDecoder,
            encode: defaultStringEncoder,
            outputMode: 'string',
            replaceSymbolFontChars: false,
            warn: console.warn
          };
          var knownSymbolFontNames = {
            Wingdings: true,
            'Wingdings 2': true,
            'Wingdings 3': true,
            Webdings: true,
            Symbol: true
          };
          function isKnownSymbolFont(thisFont) {
            return !!thisFont && (thisFont.fcharsetCpg === 42 || thisFont.cpg === 42 || knownSymbolFontNames[thisFont.fontName || ''] === true);
          }
          var ProcessTokens = /*#__PURE__*/function (_stream_1$Transform) {
            _inherits(ProcessTokens, _stream_1$Transform);
            var _super2 = _createSuper(ProcessTokens);
            function ProcessTokens(options) {
              var _this3;
              _classCallCheck2(this, ProcessTokens);
              _this3 = _super2.call(this, {
                writableObjectMode: true,
                readableObjectMode: true
              });
              _this3._rootState = {
                uc: 1,
                groupDepth: 0,
                destDepth: 0,
                destGroupDepth: 0
              };
              _this3._state = _this3._rootState;
              _this3._cpg = 1252;
              _this3._count = 0;
              _this3._lastLastToken = null;
              _this3._lastToken = null;
              _this3._currToken = null;
              _this3._done = false;
              _this3._ansicpg = false;
              _this3._skip = 0;
              _this3._options = Object.assign(Object.assign({}, exports.procTokensDefaultOptions), options);
              _this3._pushOutput = _this3._pushOutput.bind(_assertThisInitialized(_this3));
              return _this3;
            }
            _createClass2(ProcessTokens, [{
              key: "defaultCodepage",
              get: function get() {
                return this._cpg;
              }
            }, {
              key: "_getOutputAsString",
              value: function _getOutputAsString(data, font) {
                var outStr;
                var areSymbolFontCodepoints = false;
                if (font && isKnownSymbolFont(font)) {
                  var chunks = [];
                  if (utils_1.isStr(data)) {
                    var _iterator = _createForOfIteratorHelper(data),
                      _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var c = _step.value;
                        var codepoint = c.codePointAt(0);
                        if (codepoint >= 0 && codepoint <= 0xFF || codepoint >= 0xF000 && codepoint <= 0xF0FF) {
                          chunks.push(String.fromCodePoint(codepoint % 0xF000));
                        } else {
                          chunks.push(String.fromCodePoint(codepoint));
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  } else {
                    chunks.push(data.toString('latin1'));
                  }
                  var str1 = chunks.join('');
                  var fontname = font.fontName;
                  if (fontname && (this._options.replaceSymbolFontChars === true || this._options.replaceSymbolFontChars && this._options.replaceSymbolFontChars[fontname])) {
                    var str2 = decode_1.recodeSymbolFontText(str1, fontname, 'keep');
                    outStr = str2 || '';
                  } else {
                    outStr = str1;
                    areSymbolFontCodepoints = true;
                  }
                } else if (utils_1.isStr(data)) {
                  outStr = data;
                } else {
                  var cpg = font ? font.cpg || font.fcharsetCpg || this._cpg : this._cpg;
                  if (cpg === 20127 || cpg === 65001) {
                    outStr = data.toString('utf8');
                  } else if (cpg === 1200) {
                    throw new Error('Decoding 1200');
                    outStr = data.toString('utf16le');
                  } else if (cpg) {
                    outStr = this._options.decode(data, 'cp' + cpg);
                  } else {
                    console.log('HELP1!');
                    throw new Error('text with no codepage');
                  }
                }
                return [outStr, areSymbolFontCodepoints];
              }
            }, {
              key: "_pushOutputData",
              value: function _pushOutputData(outStr, areSymbolFontCodepoints) {
                if (this._options.outputMode === 'buffer-utf8') {
                  this.push(Buffer.from(outStr, 'utf8'));
                } else if (this._options.outputMode === 'buffer-default-cpg' && this._options.encode) {
                  if (this._cpg === 20127 || this._cpg === 65001) {
                    this.push(Buffer.from(outStr, 'utf8'));
                  } else if (this._cpg === 1200) {
                    this.push(Buffer.from(outStr, 'utf16le'));
                  } else if (areSymbolFontCodepoints) {
                    var bytes = [];
                    var _iterator2 = _createForOfIteratorHelper(outStr),
                      _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var c = _step2.value;
                        var codepoint = c.charCodeAt(0);
                        if (codepoint > 0xFF) {
                          bytes.push(0x20);
                        } else {
                          bytes.push(codepoint);
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    this.push(Buffer.from(bytes));
                  } else {
                    try {
                      var buf = this._options.encode(outStr, 'cp' + this._cpg);
                      this.push(buf);
                    } catch (err) {
                      this._options.warn('Unable to encode to cp' + this._cpg);
                    }
                  }
                } else {
                  this.push(outStr);
                }
              }
            }, {
              key: "_getCurrentFont",
              value: function _getCurrentFont() {
                var state = this._state;
                var f = state.font || this._deff || '';
                var finfo = this._fonttbl && this._fonttbl[f];
                return finfo;
              }
            }, {
              key: "_pushOutput",
              value: function _pushOutput(data) {
                var _iterator3 = _createForOfIteratorHelper(this._featureHandlers),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var feature = _step3.value;
                    if (feature.outputDataFilter) {
                      var handled = feature.outputDataFilter(this, data);
                      if (handled) {
                        return;
                      }
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
                var font = this._getCurrentFont();
                var _this$_getOutputAsStr = this._getOutputAsString(data, font),
                  _this$_getOutputAsStr2 = _slicedToArray(_this$_getOutputAsStr, 2),
                  outStr = _this$_getOutputAsStr2[0],
                  areSymbolFontCodepoints = _this$_getOutputAsStr2[1];
                this._pushOutputData(outStr, areSymbolFontCodepoints);
              }
            }, {
              key: "_handleToken",
              value: function _handleToken(token) {
                try {
                  var _iterator4 = _createForOfIteratorHelper(this._featureHandlers),
                    _step4;
                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      var _feature = _step4.value;
                      if (_feature.allTokenHandler) {
                        var _result = _feature.allTokenHandler(this, token);
                        if (_result) {
                          return;
                        }
                      }
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                  var _iterator5 = _createForOfIteratorHelper(this._featureHandlers),
                    _step5;
                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                      var _feature2 = _step5.value;
                      if (_feature2.tokenHandlers) {
                        var tokenHandler = _feature2.tokenHandlers[token.type];
                        if (tokenHandler) {
                          var _result2 = tokenHandler(this, token);
                          if (_result2) {
                            return;
                          }
                        }
                      }
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                  if (token.type === 2) {
                    var _iterator6 = _createForOfIteratorHelper(this._featureHandlers),
                      _step6;
                    try {
                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                        var feature = _step6.value;
                        if (feature.controlHandlers && feature.controlHandlers[token.word]) {
                          var result = feature.controlHandlers[token.word](this, token);
                          if (result) {
                            return;
                          }
                        }
                      }
                    } catch (err) {
                      _iterator6.e(err);
                    } finally {
                      _iterator6.f();
                    }
                  }
                } catch (err) {
                  return err;
                }
              }
            }, {
              key: "_transform",
              value: function _transform(token, encoding, cb) {
                var error = this._handleToken(token);
                cb(error);
              }
            }, {
              key: "_flush",
              value: function _flush(cb) {
                var error;
                try {
                  var _iterator7 = _createForOfIteratorHelper(this._featureHandlers),
                    _step7;
                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                      var feature = _step7.value;
                      if (feature.preStreamFlushHandler) {
                        feature.preStreamFlushHandler(this);
                      }
                    }
                  } catch (err) {
                    _iterator7.e(err);
                  } finally {
                    _iterator7.f();
                  }
                } catch (err) {
                  error = err;
                }
                cb(error);
              }
            }]);
            return ProcessTokens;
          }(stream_1.Transform);
          exports.ProcessTokens = ProcessTokens;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "./decode": 39,
      "./utils": 53,
      "buffer": 7,
      "stream": 57
    }],
    38: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DeEncapsulate = void 0;
      var checkVersion_1 = require("./features/checkVersion");
      var countTokens_1 = require("./features/countTokens");
      var handleCharacterSet_1 = require("./features/handleCharacterSet");
      var handleControlsAndDestinations_1 = require("./features/handleControlsAndDestinations");
      var handleDeEncapsulation_1 = require("./features/handleDeEncapsulation");
      var handleFonts_1 = require("./features/handleFonts");
      var handleGroupState_1 = require("./features/handleGroupState");
      var handleOutput_1 = require("./features/handleOutput");
      var handleUnicodeSkip_1 = require("./features/handleUnicodeSkip");
      var textEscapes_1 = require("./features/textEscapes");
      var ProcessTokens_1 = require("./ProcessTokens");
      var deEncExtraDefaultOptions = {
        htmlEncodeNonAscii: false,
        htmlFixContentType: false,
        htmlPreserveSpaces: false,
        mode: 'either',
        prefix: false,
        outlookQuirksMode: false
      };
      function htmlEntityEncode(str) {
        var pieces = [];
        var ascii = true;
        var _iterator8 = _createForOfIteratorHelper(str),
          _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var char = _step8.value;
            var codepoint = char.codePointAt(0);
            if (codepoint === 0xA0) {
              ascii = false;
              pieces.push('&nbsp;');
            } else if (codepoint > 0x7F) {
              ascii = false;
              pieces.push('&#x' + codepoint.toString(16) + ';');
            } else {
              pieces.push(char);
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
        var out = ascii ? str : pieces.join('');
        return out;
      }
      var rxCharset = /(\bcharset=)([\w-]+)(")/i;
      var DeEncapsulate = /*#__PURE__*/function (_ProcessTokens_1$Proc) {
        _inherits(DeEncapsulate, _ProcessTokens_1$Proc);
        var _super3 = _createSuper(DeEncapsulate);
        function DeEncapsulate(options) {
          var _this4;
          _classCallCheck2(this, DeEncapsulate);
          _this4 = _super3.call(this, options);
          _this4._featureHandlers = [countTokens_1.countTokens, checkVersion_1.checkVersion, handleGroupState_1.handleGroupState, handleUnicodeSkip_1.handleUnicodeSkip, handleControlsAndDestinations_1.handleControlsAndDestinations, handleCharacterSet_1.handleCharacterSet, handleFonts_1.handleFonts, handleDeEncapsulation_1.handleDeEncapsulation, handleOutput_1.handleOutput, textEscapes_1.handleTextEscapes];
          _this4._rootState = {
            uc: 1,
            groupDepth: 0,
            destDepth: 0,
            destGroupDepth: 0
          };
          _this4._state = _this4._rootState;
          _this4._fromhtml = false;
          _this4._fromtext = false;
          _this4._didHtmlCharsetReplace = false;
          _this4._options = Object.assign(Object.assign(Object.assign({}, ProcessTokens_1.procTokensDefaultOptions), deEncExtraDefaultOptions), options);
          return _this4;
        }
        _createClass2(DeEncapsulate, [{
          key: "isHtml",
          get: function get() {
            return this._fromhtml;
          }
        }, {
          key: "isText",
          get: function get() {
            return this._fromtext;
          }
        }, {
          key: "originalHtmlCharset",
          get: function get() {
            return this._originalHtmlCharset;
          }
        }, {
          key: "_getOutputAsString",
          value: function _getOutputAsString(data, font) {
            var _this5 = this;
            var _a;
            var _get$call = _get(_getPrototypeOf(DeEncapsulate.prototype), "_getOutputAsString", this).call(this, data, font),
              _get$call2 = _slicedToArray(_get$call, 2),
              outStr = _get$call2[0],
              areSymbolFontCodepoints = _get$call2[1];
            if (this._fromhtml) {
              var insideHtmltag = !!((_a = this._state.allDestinations) === null || _a === void 0 ? void 0 : _a['htmltag']);
              if (insideHtmltag) {
                if (this._options.htmlFixContentType && !this._didHtmlCharsetReplace) {
                  outStr = outStr.replace(rxCharset, function (match, pre, charset, post) {
                    _this5._didHtmlCharsetReplace = true;
                    _this5._originalHtmlCharset = charset;
                    return pre + 'UTF-8' + post;
                  });
                }
              } else {
                outStr = outStr.replace(/<|>/g, function (match) {
                  return match === '<' ? '&lt;' : '&gt;';
                });
                if (this._options.htmlPreserveSpaces) {
                  if (outStr === ' ') {
                    outStr = "\xA0";
                  } else {
                    outStr = outStr.replace(/  +/g, function (match) {
                      return ' ' + "\xA0".repeat(match.length - 1);
                    }).replace(/^ +/, function (match) {
                      return "\xA0".repeat(match.length);
                    }).replace(/ +$/, function (match) {
                      return "\xA0".repeat(match.length);
                    });
                  }
                }
                if (this._options.htmlEncodeNonAscii) {
                  outStr = htmlEntityEncode(outStr);
                }
              }
            }
            return [outStr, areSymbolFontCodepoints];
          }
        }, {
          key: "_getCurrentFont",
          value: function _getCurrentFont() {
            var allDests = this._state.allDestinations || {};
            var insideHtmltag = !!allDests['htmltag'];
            return insideHtmltag ? undefined : _get(_getPrototypeOf(DeEncapsulate.prototype), "_getCurrentFont", this).call(this);
          }
        }]);
        return DeEncapsulate;
      }(ProcessTokens_1.ProcessTokens);
      exports.DeEncapsulate = DeEncapsulate;
      exports.default = DeEncapsulate;
    }, {
      "./ProcessTokens": 37,
      "./features/checkVersion": 40,
      "./features/countTokens": 41,
      "./features/handleCharacterSet": 42,
      "./features/handleControlsAndDestinations": 43,
      "./features/handleDeEncapsulation": 44,
      "./features/handleFonts": 45,
      "./features/handleGroupState": 46,
      "./features/handleOutput": 47,
      "./features/handleUnicodeSkip": 48,
      "./features/textEscapes": 49
    }],
    39: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.recodeSymbolFontText = exports.fontToUnicode = void 0;
      var utils_1 = require("./utils");
      exports.fontToUnicode = {
        Wingdings: [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x1F589, 0x02702, 0x02701, 0x1F453, 0x1F56D, 0x1F56E, 0x1F56F, 0x1F57F, 0x02706, 0x1F582, 0x1F583, 0x1F4EA, 0x1F4EB, 0x1F4EC, 0x1F4ED, 0x1F4C1, 0x1F4C2, 0x1F4C4, 0x1F5CF, 0x1F5D0, 0x1F5C4, 0x0231B, 0x1F5AE, 0x1F5B0, 0x1F5B2, 0x1F5B3, 0x1F5B4, 0x1F5AB, 0x1F5AC, 0x02707, 0x0270D, 0x1F58E, 0x0270C, 0x1F44C, 0x1F44D, 0x1F44E, 0x0261C, 0x0261E, 0x0261D, 0x0261F, 0x1F590, 0x0263A, 0x1F610, 0x02639, 0x1F4A3, 0x02620, 0x1F3F3, 0x1F3F1, 0x02708, 0x0263C, 0x1F4A7, 0x02744, 0x1F546, 0x0271E, 0x1F548, 0x02720, 0x02721, 0x0262A, 0x0262F, 0x00950, 0x02638, 0x02648, 0x02649, 0x0264A, 0x0264B, 0x0264C, 0x0264D, 0x0264E, 0x0264F, 0x02650, 0x02651, 0x02652, 0x02653, 0x1F670, 0x1F675, 0x025CF, 0x1F53E, 0x025A0, 0x025A1, 0x1F790, 0x02751, 0x02752, 0x02B27, 0x029EB, 0x025C6, 0x02756, 0x02B25, 0x02327, 0x02BB9, 0x02318, 0x1F3F5, 0x1F3F6, 0x1F676, 0x1F677, 0x00020, 0x024EA, 0x02460, 0x02461, 0x02462, 0x02463, 0x02464, 0x02465, 0x02466, 0x02467, 0x02468, 0x02469, 0x024FF, 0x02776, 0x02777, 0x02778, 0x02779, 0x0277A, 0x0277B, 0x0277C, 0x0277D, 0x0277E, 0x0277F, 0x1F662, 0x1F660, 0x1F661, 0x1F663, 0x1F65E, 0x1F65C, 0x1F65D, 0x1F65F, 0x000B7, 0x02022, 0x025AA, 0x026AA, 0x1F786, 0x1F788, 0x025C9, 0x025CE, 0x1F53F, 0x025AA, 0x025FB, 0x1F7C2, 0x02726, 0x02605, 0x02736, 0x02734, 0x02739, 0x02735, 0x02BD0, 0x02316, 0x027E1, 0x02311, 0x02BD1, 0x0272A, 0x02730, 0x1F550, 0x1F551, 0x1F552, 0x1F553, 0x1F554, 0x1F555, 0x1F556, 0x1F557, 0x1F558, 0x1F559, 0x1F55A, 0x1F55B, 0x02BB0, 0x02BB1, 0x02BB2, 0x02BB3, 0x02BB4, 0x02BB5, 0x02BB6, 0x02BB7, 0x1F66A, 0x1F66B, 0x1F655, 0x1F654, 0x1F657, 0x1F656, 0x1F650, 0x1F651, 0x1F652, 0x1F653, 0x0232B, 0x02326, 0x02B98, 0x02B9A, 0x02B99, 0x02B9B, 0x02B88, 0x02B8A, 0x02B89, 0x02B8B, 0x1F868, 0x1F86A, 0x1F869, 0x1F86B, 0x1F86C, 0x1F86D, 0x1F86F, 0x1F86E, 0x1F878, 0x1F87A, 0x1F879, 0x1F87B, 0x1F87C, 0x1F87D, 0x1F87F, 0x1F87E, 0x021E6, 0x021E8, 0x021E7, 0x021E9, 0x02B04, 0x021F3, 0x02B00, 0x02B01, 0x02B03, 0x02B02, 0x1F8AC, 0x1F8AD, 0x1F5F6, 0x02714, 0x1F5F7, 0x1F5F9, 0x0229E],
        'Wingdings 2': [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x1F58A, 0x1F58B, 0x1F58C, 0x1F58D, 0x02704, 0x02700, 0x1F57E, 0x1F57D, 0x1F5C5, 0x1F5C6, 0x1F5C7, 0x1F5C8, 0x1F5C9, 0x1F5CA, 0x1F5CB, 0x1F5CC, 0x1F5CD, 0x1F4CB, 0x1F5D1, 0x1F5D4, 0x1F5B5, 0x1F5B6, 0x1F5B7, 0x1F5B8, 0x1F5AD, 0x1F5AF, 0x1F5B1, 0x1F592, 0x1F593, 0x1F598, 0x1F599, 0x1F59A, 0x1F59B, 0x1F448, 0x1F449, 0x1F59C, 0x1F59D, 0x1F59E, 0x1F59F, 0x1F5A0, 0x1F5A1, 0x1F446, 0x1F447, 0x1F5A2, 0x1F5A3, 0x1F591, 0x1F5F4, 0x02713, 0x1F5F5, 0x02611, 0x02612, 0x02612, 0x02BBE, 0x02BBF, 0x029B8, 0x029B8, 0x1F671, 0x1F674, 0x1F672, 0x1F673, 0x0203D, 0x1F679, 0x1F67A, 0x1F67B, 0x1F666, 0x1F664, 0x1F665, 0x1F667, 0x1F65A, 0x1F658, 0x1F659, 0x1F65B, 0x024EA, 0x02460, 0x02461, 0x02462, 0x02463, 0x02464, 0x02465, 0x02466, 0x02467, 0x02468, 0x02469, 0x024FF, 0x02776, 0x02777, 0x02778, 0x02779, 0x0277A, 0x0277B, 0x0277C, 0x0277D, 0x0277E, 0x0277F, 0x00020, 0x02609, 0x1F315, 0x0263D, 0x0263E, 0x02E3F, 0x0271D, 0x1F547, 0x1F55C, 0x1F55D, 0x1F55E, 0x1F55F, 0x1F560, 0x1F561, 0x1F562, 0x1F563, 0x1F564, 0x1F565, 0x1F566, 0x1F567, 0x1F668, 0x1F669, 0x02022, 0x025CF, 0x026AB, 0x02B24, 0x1F785, 0x1F786, 0x1F787, 0x1F788, 0x1F78A, 0x029BF, 0x025FE, 0x025A0, 0x025FC, 0x02B1B, 0x02B1C, 0x1F791, 0x1F792, 0x1F793, 0x1F794, 0x025A3, 0x1F795, 0x1F796, 0x1F797, 0x02B29, 0x02B25, 0x025C6, 0x025C7, 0x1F79A, 0x025C8, 0x1F79B, 0x1F79C, 0x1F79D, 0x02B2A, 0x02B27, 0x029EB, 0x025CA, 0x1F7A0, 0x025D6, 0x025D7, 0x02BCA, 0x02BCB, 0x025FC, 0x02B25, 0x02B1F, 0x02BC2, 0x02B23, 0x02B22, 0x02BC3, 0x02BC4, 0x1F7A1, 0x1F7A2, 0x1F7A3, 0x1F7A4, 0x1F7A5, 0x1F7A6, 0x1F7A7, 0x1F7A8, 0x1F7A9, 0x1F7AA, 0x1F7AB, 0x1F7AC, 0x1F7AD, 0x1F7AE, 0x1F7AF, 0x1F7B0, 0x1F7B1, 0x1F7B2, 0x1F7B3, 0x1F7B4, 0x1F7B5, 0x1F7B6, 0x1F7B7, 0x1F7B8, 0x1F7B9, 0x1F7BA, 0x1F7BB, 0x1F7BC, 0x1F7BD, 0x1F7BE, 0x1F7BF, 0x1F7C0, 0x1F7C2, 0x1F7C4, 0x02726, 0x1F7C9, 0x02605, 0x02736, 0x1F7CB, 0x02737, 0x1F7CF, 0x1F7D2, 0x02739, 0x1F7C3, 0x1F7C7, 0x0272F, 0x1F7CD, 0x1F7D4, 0x02BCC, 0x02BCD, 0x0203B, 0x02042, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020],
        'Wingdings 3': [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x02B60, 0x02B62, 0x02B61, 0x02B63, 0x02B66, 0x02B67, 0x02B69, 0x02B68, 0x02B70, 0x02B72, 0x02B71, 0x02B73, 0x02B76, 0x02B78, 0x02B7B, 0x02B7D, 0x02B64, 0x02B65, 0x02B6A, 0x02B6C, 0x02B6B, 0x02B6D, 0x02B4D, 0x02BA0, 0x02BA1, 0x02BA2, 0x02BA3, 0x02BA4, 0x02BA5, 0x02BA6, 0x02BA7, 0x02B90, 0x02B91, 0x02B92, 0x02B93, 0x02B80, 0x02B83, 0x02B7E, 0x02B7F, 0x02B84, 0x02B86, 0x02B85, 0x02B87, 0x02B8F, 0x02B8D, 0x02B8E, 0x02B8C, 0x02B6E, 0x02B6F, 0x0238B, 0x02324, 0x02303, 0x02325, 0x023B5, 0x0237D, 0x021EA, 0x02BB8, 0x1F8A0, 0x1F8A1, 0x1F8A2, 0x1F8A3, 0x1F8A4, 0x1F8A5, 0x1F8A6, 0x1F8A7, 0x1F8A8, 0x1F8A9, 0x1F8AA, 0x1F8AB, 0x02190, 0x02192, 0x02191, 0x02193, 0x02196, 0x02197, 0x02199, 0x02198, 0x1F858, 0x1F859, 0x025B2, 0x025BC, 0x025B3, 0x025BD, 0x025C4, 0x025BA, 0x025C1, 0x025B7, 0x025E3, 0x025E2, 0x025E4, 0x025E5, 0x1F780, 0x1F782, 0x1F781, 0x00020, 0x1F783, 0x025B2, 0x025BC, 0x025C0, 0x025B6, 0x02B9C, 0x02B9E, 0x02B9D, 0x02B9F, 0x1F810, 0x1F812, 0x1F811, 0x1F813, 0x1F814, 0x1F816, 0x1F815, 0x1F817, 0x1F818, 0x1F81A, 0x1F819, 0x1F81B, 0x1F81C, 0x1F81E, 0x1F81D, 0x1F81F, 0x1F800, 0x1F802, 0x1F801, 0x1F803, 0x1F804, 0x1F806, 0x1F805, 0x1F807, 0x1F808, 0x1F80A, 0x1F809, 0x1F80B, 0x1F820, 0x1F822, 0x1F824, 0x1F826, 0x1F828, 0x1F82A, 0x1F82C, 0x1F89C, 0x1F89D, 0x1F89E, 0x1F89F, 0x1F82E, 0x1F830, 0x1F832, 0x1F834, 0x1F836, 0x1F838, 0x1F83A, 0x1F839, 0x1F83B, 0x1F898, 0x1F89A, 0x1F899, 0x1F89B, 0x1F83C, 0x1F83E, 0x1F83D, 0x1F83F, 0x1F840, 0x1F842, 0x1F841, 0x1F843, 0x1F844, 0x1F846, 0x1F845, 0x1F847, 0x02BA8, 0x02BA9, 0x02BAA, 0x02BAB, 0x02BAC, 0x02BAD, 0x02BAE, 0x02BAF, 0x1F860, 0x1F862, 0x1F861, 0x1F863, 0x1F864, 0x1F865, 0x1F867, 0x1F866, 0x1F870, 0x1F872, 0x1F871, 0x1F873, 0x1F874, 0x1F875, 0x1F877, 0x1F876, 0x1F880, 0x1F882, 0x1F881, 0x1F883, 0x1F884, 0x1F885, 0x1F887, 0x1F886, 0x1F890, 0x1F892, 0x1F891, 0x1F893, 0x1F894, 0x1F896, 0x1F895, 0x1F897, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020],
        Webdings: [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x1F577, 0x1F578, 0x1F572, 0x1F576, 0x1F3C6, 0x1F396, 0x1F587, 0x1F5E8, 0x1F5E9, 0x1F5F0, 0x1F5F1, 0x1F336, 0x1F397, 0x1F67E, 0x1F67C, 0x1F5D5, 0x1F5D6, 0x1F5D7, 0x023F4, 0x023F5, 0x023F6, 0x023F7, 0x023EA, 0x023E9, 0x023EE, 0x023ED, 0x023F8, 0x023F9, 0x023FA, 0x1F5DA, 0x1F5F3, 0x1F6E0, 0x1F3D7, 0x1F3D8, 0x1F3D9, 0x1F3DA, 0x1F3DC, 0x1F3ED, 0x1F3DB, 0x1F3E0, 0x1F3D6, 0x1F3DD, 0x1F6E3, 0x1F50D, 0x1F3D4, 0x1F441, 0x1F442, 0x1F3DE, 0x1F3D5, 0x1F6E4, 0x1F3DF, 0x1F6F3, 0x1F56C, 0x1F56B, 0x1F568, 0x1F508, 0x1F394, 0x1F395, 0x1F5EC, 0x1F67D, 0x1F5ED, 0x1F5EA, 0x1F5EB, 0x02B94, 0x02714, 0x1F6B2, 0x02B1C, 0x1F6E1, 0x1F381, 0x1F6F1, 0x02B1B, 0x1F691, 0x1F6C8, 0x1F6E9, 0x1F6F0, 0x1F7C8, 0x1F574, 0x02B24, 0x1F6E5, 0x1F694, 0x1F5D8, 0x1F5D9, 0x02753, 0x1F6F2, 0x1F687, 0x1F68D, 0x1F6A9, 0x029B8, 0x02296, 0x1F6AD, 0x1F5EE, 0x023D0, 0x1F5EF, 0x1F5F2, 0x025AF, 0x1F6B9, 0x1F6BA, 0x1F6C9, 0x1F6CA, 0x1F6BC, 0x1F47D, 0x1F3CB, 0x026F7, 0x1F3C2, 0x1F3CC, 0x1F3CA, 0x1F3C4, 0x1F3CD, 0x1F3CE, 0x1F698, 0x1F4C8, 0x1F6E2, 0x1F4B0, 0x1F3F7, 0x1F4B3, 0x1F46A, 0x1F5E1, 0x1F5E2, 0x1F5E3, 0x0272F, 0x1F584, 0x1F585, 0x1F583, 0x1F586, 0x1F5B9, 0x1F5BA, 0x1F5BB, 0x1F575, 0x1F570, 0x1F5BD, 0x1F5BE, 0x1F4CB, 0x1F5D2, 0x1F5D3, 0x1F56E, 0x1F4DA, 0x1F5DE, 0x1F5DF, 0x1F5C3, 0x1F4C7, 0x1F5BC, 0x1F3AD, 0x1F39C, 0x1F398, 0x1F399, 0x1F3A7, 0x1F4BF, 0x1F39E, 0x1F4F7, 0x1F39F, 0x1F3AC, 0x1F4FD, 0x1F4F9, 0x1F4FE, 0x1F4FB, 0x1F39A, 0x1F39B, 0x1F4FA, 0x1F4BB, 0x1F5A5, 0x1F5A6, 0x1F5A7, 0x1F579, 0x1F3AE, 0x1F57B, 0x1F57C, 0x1F4DF, 0x1F581, 0x1F580, 0x1F5A8, 0x1F5A9, 0x1F5BF, 0x1F5AA, 0x1F5DC, 0x1F512, 0x1F513, 0x1F5DD, 0x1F4E5, 0x1F4E4, 0x1F573, 0x1F323, 0x1F324, 0x1F325, 0x1F326, 0x02601, 0x1F328, 0x1F327, 0x1F329, 0x1F32A, 0x1F32C, 0x1F32B, 0x1F31C, 0x1F321, 0x1F6CB, 0x1F6CF, 0x1F37D, 0x1F378, 0x1F6CE, 0x1F6CD, 0x024C5, 0x0267F, 0x1F6C6, 0x1F588, 0x1F393, 0x1F5E4, 0x1F5E5, 0x1F5E6, 0x1F5E7, 0x1F6EA, 0x1F43F, 0x1F426, 0x1F41F, 0x1F415, 0x1F408, 0x1F66C, 0x1F66E, 0x1F66D, 0x1F66F, 0x1F5FA, 0x1F30D, 0x1F30F, 0x1F30E, 0x1F54A],
        Symbol: '' + "        " + "        " + "        " + "        " + " !\u2200#\u2203%&\u220D" + "()\u2217+,\u2212./" + "01234567" + "89:;<=>?" + "\u2245\u0391\u0392\u03A7\u0394\u0395\u03A6\u0393" + "\u0397\u0399\u03D1\u039A\u039B\u039C\u039D\u039F" + "\u03A0\u0398\u03A1\u03A3\u03A4\u03A5\u03C2\u03A9" + "\u039E\u03A8\u0396[\u2234]\u22A5_" + "\u203E\u03B1\u03B2\u03C7\u03B4\u03B5\u03C6\u03B3" + "\u03B7\u03B9\u03D5\u03BA\u03BB\u03BC\u03BD\u03BF" + "\u03C0\u03B8\u03C1\u03C3\u03C4\u03C5\u03D6\u03C9" + "\u03BE\u03C8\u03B6{|}\u223C " + "        " + "        " + "        " + "        " + " \u03D2\u2032\u2264\u2044\u221E\u0192\u2663" + "\u2666\u2665\u2660\u2194\u2190\u2191\u2192\u2193" + "\xB0\xB1\u2033\u2265\xD7\u221D\u2202\u2022" + "\xF7\u2260\u2261\u2248\u2026\u23D0\u23AF\u21B5" + "\u2135\u2111\u211C\u2118\u2297\u2295\u2205\u2229" + "\u222A\u2283\u2287\u2284\u2282\u2286\u2208\u2209" + "\u2220\u2207\xAE\xA9\u2122\u220F\u221A\u22C5" + "\xAC\u2227\u2228\u21D4\u21D0\u21D1\u21D2\u21D3" + "\u25CA\u2329\xAE\xA9\u2122\u2211\u239B\u239C" + "\u239D\u23A1\u23A2\u23A3\u23A7\u23A8\u23A9\u23AA" + "\u20AC\u232A\u222B\u2320\u23AE\u2321\u239E\u239F" + "\u23A0\u23A4\u23A5\u23A6\u23AB\u23AC\u23AD "
      };
      function recodeSymbolFontText(input, font) {
        var unmapped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '?';
        var mapping = exports.fontToUnicode[font];
        if (mapping) {
          var parts = [];
          var _iterator9 = _createForOfIteratorHelper(input),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var c = _step9.value;
              var codepoint = c.codePointAt(0);
              var codepoint2 = mapping[codepoint];
              if (utils_1.isDef(codepoint2)) {
                parts.push(utils_1.isStr(codepoint2) ? codepoint2 : String.fromCodePoint(codepoint2));
              } else {
                if (unmapped === 'keep') {
                  parts.push(c);
                } else if (unmapped === '?') {
                  parts.push('?');
                }
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
          return parts.join('');
        }
      }
      exports.recodeSymbolFontText = recodeSymbolFontText;
    }, {
      "./utils": 53
    }],
    40: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.checkVersion = void 0;
      exports.checkVersion = {
        allTokenHandler: function allTokenHandler(global, token) {
          if (global._count === 1 && token.type !== 0) {
            throw new Error('File should start with "{"');
          }
          if (global._count === 2 && (token.word !== 'rtf' || token.param && token.param !== 1)) {
            throw new Error('File should start with "{\\rtf[0,1]"');
          }
        },
        preStreamFlushHandler: function preStreamFlushHandler(global) {
          if (global._count === 0) {
            throw new Error('File should start with "{"');
          } else if (global._count === 1) {
            throw new Error('File should start with "{\\rtf"');
          }
        }
      };
    }, {}],
    41: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.countTokens = void 0;
      exports.countTokens = {
        allTokenHandler: function allTokenHandler(global) {
          ++global._count;
        }
      };
    }, {}],
    42: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleCharacterSet = void 0;
      var utils_1 = require("../utils");
      var characterSetControlHandlers = {
        mac: function mac() {
          throw new Error('Unsupported character set \\mac');
        },
        pc: function pc() {
          throw new Error('Unsupported character set \\pc');
        },
        pca: function pca() {
          throw new Error('Unsupported character set \\pca');
        },
        ansicpg: function ansicpg(global, token) {
          if (global._state.destination === 'rtf' && global._state.destDepth > 1 && global._ansicpg) {
            return;
          }
          if (global._ansicpg) {
            global._options.warn('\\ansicpg already defined');
            return;
          }
          if (!utils_1.isNum(token.param)) {
            global._options.warn('\\ansicpg with no param');
            return;
          }
          global._ansicpg = true;
          global._cpg = token.param;
        }
      };
      exports.handleCharacterSet = {
        controlHandlers: characterSetControlHandlers
      };
    }, {
      "../utils": 53
    }],
    43: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleControlsAndDestinations = void 0;
      var words_1 = require("../words");
      function addDestination(state, destination) {
        state.destDepth = (state.destDepth || 0) + 1;
        state.destGroupDepth = state.groupDepth;
        if (!state.allDestinations) {
          state.allDestinations = {};
          state.allDestinations[destination] = true;
        } else if (!state.allDestinations[destination]) {
          state.allDestinations = Object.create(state.allDestinations);
          state.allDestinations[destination] = true;
        }
      }
      var destinationControlHandlers = _defineProperty2({}, 2, function _(global, token) {
        var _a;
        if (token.word === '*' && ((_a = global._lastToken) === null || _a === void 0 ? void 0 : _a.type) !== 0) {
          global._options.warn('Got control symbol "\\*" but not immediately after "{"');
        }
        var wordType = words_1.words[token.word] || 0;
        if (wordType === 5) {
          if (global._lastToken && global._lastToken.type === 0) {
            global._state.destination = token.word;
            global._state.destIgnorableImmediate = false;
            addDestination(global._state, token.word);
          } else if (global._lastToken && global._lastLastToken && global._lastToken.type === 2 && global._lastToken.word === '*' && global._lastLastToken.type === 0) {
            global._state.destination = token.word;
            global._state.destIgnorableImmediate = global._state.destIgnorable = true;
            addDestination(global._state, token.word);
          } else {
            global._options.warn('Got destination control word but not immediately after "{" or "{\\*": ' + token.word);
          }
        } else if (wordType === 0) {
          if (global._lastToken && global._lastLastToken && global._lastToken.type === 2 && global._lastToken.word === '*' && global._lastLastToken.type === 0) {
            global._state.destination = token.word;
            global._state.destIgnorableImmediate = global._state.destIgnorable = true;
            addDestination(global._state, token.word);
          }
        }
      });
      exports.handleControlsAndDestinations = {
        tokenHandlers: destinationControlHandlers,
        allTokenHandler: function allTokenHandler(global, token) {
          global._lastLastToken = global._lastToken;
          global._lastToken = global._currToken;
          global._currToken = token;
        }
      };
    }, {
      "../words": 54
    }],
    44: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleDeEncapsulation = void 0;
      function getModeError(global) {
        if (global._options.mode === 'html') {
          return new Error('Not encapsulated HTML file');
        } else if (global._options.mode === 'text') {
          return new Error('Not encapsulated text file');
        } else {
          return new Error('Not encapsulated HTML or text file');
        }
      }
      var allTokenHandler = function allTokenHandler(global, token) {
        if (global._count <= 10) {
          if (token.type === 3) {
            throw getModeError(global);
          }
        } else if (!global._fromhtml && !global._fromtext) {
          throw getModeError(global);
        }
        if (global._state.htmlrtf && global._options.outlookQuirksMode) {
          if (token.type !== 2 || token.word !== 'f' && token.word !== 'htmlrtf') {
            return true;
          }
        }
      };
      var deEncapsulationControlHandlers = {
        fromhtml: function fromhtml(global) {
          if (global._state.destination !== 'rtf') {
            throw new Error('\\fromhtml not at root group');
          }
          if (global._fromhtml !== false || global._fromtext !== false) {
            throw new Error('\\fromhtml or \\fromtext already defined');
          }
          if (global._options.mode !== 'html' && global._options.mode !== 'either') {
            throw getModeError(global);
          }
          global._fromhtml = true;
          if (global._options.prefix) {
            global._pushOutput('html:');
          }
          return true;
        },
        fromtext: function fromtext(global) {
          if (global._state.destination !== 'rtf') {
            throw new Error('\\fromtext not at root group');
          }
          if (global._fromhtml !== false || global._fromtext !== false) {
            throw new Error('\\fromhtml or \\fromtext already defined');
          }
          if (global._options.mode !== 'text' && global._options.mode !== 'either') {
            throw getModeError(global);
          }
          global._fromtext = true;
          if (global._options.prefix) {
            global._pushOutput('text:');
          }
          return true;
        },
        htmlrtf: function htmlrtf(global, token) {
          var on = token.param !== 0;
          global._state.htmlrtf = on;
        }
      };
      exports.handleDeEncapsulation = {
        allTokenHandler: allTokenHandler,
        controlHandlers: deEncapsulationControlHandlers,
        outputDataFilter: function outputDataFilter(global) {
          if (global._state.htmlrtf) {
            return true;
          }
          var allDests = global._state.allDestinations || {};
          var insideHtmltag = !!allDests['htmltag'];
          if (!insideHtmltag && global._state.destIgnorable) {
            return true;
          }
          if (!insideHtmltag && (allDests['fonttbl'] || allDests['colortbl'] || allDests['stylesheet'] || allDests['pntext'])) {
            return true;
          }
        },
        preStreamFlushHandler: function preStreamFlushHandler(global) {
          if (!global._fromhtml && !global._fromtext) {
            throw getModeError(global);
          }
        }
      };
    }, {}],
    45: [function (require, module, exports) {
      "use strict";

      var _fontTokenHandlers;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleFonts = void 0;
      var utils_1 = require("../utils");
      var charsetToCpg = {
        0: 1252,
        2: 42,
        77: 10000,
        78: 10001,
        79: 10003,
        80: 10008,
        81: 10002,
        83: 10005,
        84: 10004,
        85: 10006,
        86: 10081,
        87: 10021,
        88: 10029,
        89: 10007,
        128: 932,
        129: 949,
        130: 1361,
        134: 936,
        136: 950,
        161: 1253,
        162: 1254,
        163: 1258,
        177: 1255,
        178: 1256,
        186: 1257,
        204: 1251,
        222: 874,
        238: 1250,
        254: 437,
        255: 850
      };
      var codepages = {
        20127: true,
        28591: true
      };
      for (var charset in charsetToCpg) {
        var cpg = charsetToCpg[charset];
        codepages[cpg] = true;
      }
      var handleThemeFont = function handleThemeFont(global, cw) {
        if (global._constructingFontTableEntry) {
          global._constructingFontTableEntry.themeFont = cw.word.slice(1);
        }
      };
      var handleFontFamily = function handleFontFamily(global, cw) {
        if (global._constructingFontTableEntry) {
          global._constructingFontTableEntry.fontFamily = cw.word.slice(1);
        }
      };
      var fontTokenHandlers = (_fontTokenHandlers = {}, _defineProperty2(_fontTokenHandlers, 0, function _(global) {
        if (global._constructingFontTable && global._state.destination === 'fonttbl' && global._state.groupDepth === global._state.destGroupDepth + 1) {
          global._constructingFontTableEntry = {};
        }
      }), _defineProperty2(_fontTokenHandlers, 1, function _(global) {
        if (global._constructingFontTable && global._state.destination === 'fonttbl' && global._state.groupDepth === global._state.destGroupDepth) {
          if (!global._constructingFontTableEntry || !global._constructingFontTableKey) {
            throw new Error('Finished a font table group but no key?');
          }
          global._fonttbl[global._constructingFontTableKey] = global._constructingFontTableEntry;
          global._constructingFontTableEntry = undefined;
          global._constructingFontTableKey = undefined;
        }
        if (global._constructingFontTable && global._state.destGroupDepth === 1) {
          global._constructingFontTable = false;
        }
      }), _fontTokenHandlers);
      var fontControlHandlers = {
        deff: function deff(global, cw) {
          if (global._state.destination === 'rtf' && global._state.destDepth > 1 && typeof global._deff !== 'undefined') {
            return;
          }
          if (global._state.destination !== 'rtf' || global._state.destDepth !== 1) throw new Error('\\deff not at root group');
          if (typeof global._deff !== 'undefined') throw new Error('\\deff already defined');
          global._deff = cw.param + '';
        },
        fonttbl: function fonttbl(global) {
          if (global._fonttbl && global._state.destGroupDepth > 2) {
            global._options.warn('Got additional \\fonttbl');
            return;
          }
          if (global._fonttbl) {
            throw new Error('fonttbl already created');
          } else if (global._state.destDepth !== 2 || global._state.destGroupDepth !== 2) {
            throw new Error('fonttbl not in header');
          }
          global._constructingFontTable = true;
          global._fonttbl = {};
        },
        f: function f(global, cw) {
          if (typeof cw.param === 'undefined') {
            throw new Error('No param for \\f');
          }
          var f = cw.param + '';
          if (global._constructingFontTableEntry && global._constructingFontTableKey) {
            throw new Error('\\f control word in font group which already has \\f');
          } else if (global._constructingFontTableEntry) {
            global._constructingFontTableKey = f;
          } else {
            global._state.font = f;
          }
        },
        fcharset: function fcharset(global, cw) {
          if (!global._constructingFontTableEntry) {
            return;
          }
          if (!utils_1.isNum(cw.param)) {
            throw new Error('fcharset with no param');
          }
          if (cw.param !== 1) {
            var _cpg = charsetToCpg[cw.param];
            if (!utils_1.isNum(_cpg) && codepages[cw.param]) {
              _cpg = cw.param;
            }
            if (!utils_1.isNum(_cpg)) {
              global._options.warn('No codepage for charset ' + cw.param);
            } else {
              global._constructingFontTableEntry.fcharsetCpg = _cpg;
            }
          }
        },
        cpg: function cpg(global, cw) {
          if (!global._constructingFontTableEntry) {
            return;
          }
          var cpg = cw.param;
          if (!utils_1.isNum(cpg)) {
            global._options.warn('No codepage given');
          } else {
            global._constructingFontTableEntry.cpg = cpg;
          }
        },
        flomajor: handleThemeFont,
        fhimajor: handleThemeFont,
        fdbmajor: handleThemeFont,
        fbimajor: handleThemeFont,
        flominor: handleThemeFont,
        fhiminor: handleThemeFont,
        fdbminor: handleThemeFont,
        fbiminor: handleThemeFont,
        fnil: handleFontFamily,
        froman: handleFontFamily,
        fswiss: handleFontFamily,
        fmodern: handleFontFamily,
        fscript: handleFontFamily,
        fdecor: handleFontFamily,
        ftech: handleFontFamily,
        fbidi: handleFontFamily
      };
      var fontTextHandler = function fontTextHandler(global, data) {
        if (global._constructingFontTableEntry) {
          if (!utils_1.isStr(data)) {
            data = data.toString('latin1');
          }
          data = data.replace(/[^\x00-\x7F]/g, function (c) {
            var hex = c.charCodeAt(0).toString(16).toUpperCase();
            return "\\u" + '0000'.slice(0, 4 - hex.length) + hex;
          });
          var str = (global._constructingFontTableEntry.fontName || '') + data;
          if (str.endsWith(';')) {
            str = str.substr(0, str.length - 1);
            if (str.length > 2 && str.startsWith('"') && str.endsWith('"')) {
              str = str.substr(1, str.length - 2);
            }
          }
          global._constructingFontTableEntry.fontName = str;
          return true;
        }
      };
      exports.handleFonts = {
        tokenHandlers: fontTokenHandlers,
        controlHandlers: fontControlHandlers,
        outputDataFilter: fontTextHandler
      };
    }, {
      "../utils": 53
    }],
    46: [function (require, module, exports) {
      "use strict";

      var _groupTokenHandlers;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleGroupState = void 0;
      var allTokenhandler = function allTokenhandler(global, token) {
        if (global._done) {
          if (token.type === 3 && token.data.length === 1 && token.data[0] === 0) {} else {
            global._options.warn('Additional tokens after final closing bracket');
          }
          return true;
        }
      };
      var groupTokenHandlers = (_groupTokenHandlers = {}, _defineProperty2(_groupTokenHandlers, 0, function _(global) {
        var oldState = global._state;
        var newState = Object.create(oldState);
        ++newState.groupDepth;
        global._state = newState;
      }), _defineProperty2(_groupTokenHandlers, 1, function _(global) {
        global._state = Object.getPrototypeOf(global._state);
        if (global._state === global._rootState) {
          global._done = true;
        }
      }), _groupTokenHandlers);
      exports.handleGroupState = {
        allTokenHandler: allTokenhandler,
        tokenHandlers: groupTokenHandlers,
        preStreamFlushHandler: function preStreamFlushHandler(global) {
          if (global._state !== global._rootState) {
            global._options.warn('Not enough matching closing brackets');
          }
        }
      };
    }, {}],
    47: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.handleOutput = void 0;
          var utils_1 = require("../utils");
          function flushBuffers(global) {
            if (global._bufferedUnicodeOutput) {
              var str = global._bufferedUnicodeOutput.join('');
              global._pushOutput(str);
              delete global._bufferedUnicodeOutput;
            }
            if (global._bufferedBinaryOutput) {
              global._pushOutput(Buffer.concat(global._bufferedBinaryOutput));
              delete global._bufferedBinaryOutput;
            }
          }
          var allTokenHandler = function allTokenHandler(global, token) {
            if (global._bufferedUnicodeOutput && (token.type !== 2 || token.word !== 'uc' && token.word !== 'u')) {
              flushBuffers(global);
            } else if (global._bufferedBinaryOutput && (token.type !== 2 || token.word !== "'")) {
              flushBuffers(global);
            }
          };
          var tokenHandlers = _defineProperty2({}, 3, function _(globals, token) {
            flushBuffers(globals);
            globals._pushOutput(token.data);
          });
          var unicodeControlHandlers = {
            u: function u(global, token) {
              if (!utils_1.isNum(token.param)) {
                throw new Error('Unicode control word with no param');
              }
              var newCodeUnit = token.param < 0 ? String.fromCodePoint(token.param + 0x10000) : String.fromCodePoint(token.param);
              global._bufferedUnicodeOutput = global._bufferedUnicodeOutput || [];
              global._bufferedUnicodeOutput.push(newCodeUnit);
            },
            "'": function _(global, token) {
              global._bufferedBinaryOutput = global._bufferedBinaryOutput || [];
              global._bufferedBinaryOutput.push(token.data);
            }
          };
          exports.handleOutput = {
            allTokenHandler: allTokenHandler,
            tokenHandlers: tokenHandlers,
            controlHandlers: unicodeControlHandlers
          };
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "../utils": 53,
      "buffer": 7
    }],
    48: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleUnicodeSkip = void 0;
      var allTokenHandler = function allTokenHandler(globals, token) {
        switch (token.type) {
          case 0:
          case 1:
            globals._skip = 0;
            break;
          case 2:
            if (globals._skip > 0) {
              globals._skip--;
              return true;
            }
            break;
          case 3:
            if (globals._skip >= token.data.length) {
              globals._skip -= token.data.length;
              return true;
            }
            if (globals._skip > 0) {
              token.data = token.data.slice(globals._skip);
              globals._skip = 0;
            }
            break;
        }
      };
      var unicodeSkipControlHandlers = {
        uc: function uc(global, token) {
          global._state.uc = token.param || 0;
        },
        u: function u(global) {
          global._skip = global._state.uc;
        }
      };
      exports.handleUnicodeSkip = {
        allTokenHandler: allTokenHandler,
        controlHandlers: unicodeSkipControlHandlers
      };
    }, {}],
    49: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleTextEscapes = void 0;
      exports.handleTextEscapes = {
        controlHandlers: {
          par: function par(globals) {
            return globals._pushOutput('\r\n');
          },
          line: function line(globals) {
            return globals._pushOutput('\r\n');
          },
          tab: function tab(globals) {
            return globals._pushOutput('\t');
          },
          lquote: function lquote(globals) {
            return globals._pushOutput("\u2018");
          },
          rquote: function rquote(globals) {
            return globals._pushOutput("\u2019");
          },
          ldblquote: function ldblquote(globals) {
            return globals._pushOutput("\u201C");
          },
          rdblquote: function rdblquote(globals) {
            return globals._pushOutput("\u201D");
          },
          bullet: function bullet(globals) {
            return globals._pushOutput("\u2022");
          },
          endash: function endash(globals) {
            return globals._pushOutput("\u2013");
          },
          emdash: function emdash(globals) {
            return globals._pushOutput("\u2014");
          },
          '{': function _(globals) {
            return globals._pushOutput('{');
          },
          '}': function _(globals) {
            return globals._pushOutput('}');
          },
          '\\': function _(globals) {
            return globals._pushOutput('\\');
          },
          '~': function _(globals) {
            return globals._pushOutput("\xA0");
          },
          _: function _(globals) {
            return globals._pushOutput("\xAD");
          }
        }
      };
    }, {}],
    50: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function (resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          };
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.deEncapsulateStream = exports.deEncapsulateSync = exports.DeEncapsulate = exports.Tokenize = void 0;
          var de_encapsulate_1 = require("./de-encapsulate");
          Object.defineProperty(exports, "DeEncapsulate", {
            enumerable: true,
            get: function get() {
              return de_encapsulate_1.DeEncapsulate;
            }
          });
          var stream_flow_1 = require("./stream-flow");
          var tokenize_1 = require("./tokenize");
          Object.defineProperty(exports, "Tokenize", {
            enumerable: true,
            get: function get() {
              return tokenize_1.Tokenize;
            }
          });
          var utils_1 = require("./utils");
          function deEncapsulateSync(rtf, options) {
            var onError = function onError(err) {
              if (utils_1.isDef(err)) {
                throw err;
              }
            };
            var stream1 = new tokenize_1.Tokenize();
            var stream2 = new de_encapsulate_1.DeEncapsulate(options);
            stream1.push = function (token) {
              stream2._transform(token, '', onError);
              return true;
            };
            var chunks = [];
            stream2.push = function (piece) {
              chunks.push(piece);
              return true;
            };
            stream1._transform(rtf, undefined, onError);
            stream1._flush(onError);
            stream2._flush(onError);
            var result = !options || !options.outputMode || options.outputMode === 'string' ? chunks.join('') : Buffer.concat(chunks);
            return {
              mode: stream2.isHtml ? 'html' : 'text',
              text: result
            };
          }
          exports.deEncapsulateSync = deEncapsulateSync;
          function deEncapsulateStream(streamIn, options) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              var stream1, stream2, chunks, result;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      stream1 = new tokenize_1.Tokenize();
                      stream2 = new de_encapsulate_1.DeEncapsulate(options);
                      _context.next = 4;
                      return stream_flow_1.streamFlow(streamIn, stream1, stream2);
                    case 4:
                      chunks = _context.sent;
                      result = !options || !options.outputMode || options.outputMode === 'string' ? chunks.join('') : Buffer.concat(chunks);
                      return _context.abrupt("return", {
                        mode: stream2.isHtml ? 'html' : 'text',
                        text: result
                      });
                    case 7:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));
          }
          exports.deEncapsulateStream = deEncapsulateStream;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "./de-encapsulate": 38,
      "./stream-flow": 51,
      "./tokenize": 52,
      "./utils": 53,
      "buffer": 7
    }],
    51: [function (require, module, exports) {
      "use strict";

      var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.streamFlow = void 0;
      function streamFlow(stream1) {
        for (var _len2 = arguments.length, streams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          streams[_key2 - 1] = arguments[_key2];
        }
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", new Promise(function (resolve, _reject) {
                    var reject = function reject(err) {
                      stream1.unpipe();
                      for (var i = 1; i < streams.length; i++) {
                        streams[i - 1].unpipe();
                      }
                      _reject(err);
                    };
                    if (streams.length) {
                      stream1.pipe(streams[0]);
                    }
                    for (var i = 1; i < streams.length; i++) {
                      streams[i - 1].pipe(streams[i]);
                    }
                    stream1.on('error', reject);
                    for (var _i2 = 0; _i2 < streams.length; _i2++) {
                      streams[_i2].on('error', reject);
                    }
                    var sout = streams.length ? streams[streams.length - 1] : stream1;
                    var output = [];
                    sout.on('readable', function () {
                      while (true) {
                        var piece = sout.read();
                        if (piece === null) {
                          break;
                        }
                        output.push(piece);
                      }
                    });
                    sout.on('end', function () {
                      return resolve(output);
                    });
                  }));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
      }
      exports.streamFlow = streamFlow;
    }, {}],
    52: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Tokenize = void 0;
          var stream_1 = require("stream");
          var utils_1 = require("./utils");
          var isAlpha = function isAlpha(c) {
            return c > 64 && c < 91 || c > 96 && c < 123;
          };
          var isNumeric = function isNumeric(c) {
            return c > 47 && c < 58;
          };
          var Tokenize = /*#__PURE__*/function (_stream_1$Transform2) {
            _inherits(Tokenize, _stream_1$Transform2);
            var _super4 = _createSuper(Tokenize);
            function Tokenize() {
              var _this6;
              _classCallCheck2(this, Tokenize);
              _this6 = _super4.call(this, {
                readableObjectMode: true
              });
              _this6._expectedBinaryBytes = 0;
              _this6._readHexDigitsCount = 0;
              _this6._paramStr = '';
              _this6._mode = 0;
              return _this6;
            }
            _createClass2(Tokenize, [{
              key: "_flushToken",
              value: function _flushToken() {
                var token = this._token;
                if (token) {
                  if (this._paramStr) {
                    token.param = Number.parseInt(this._paramStr, 10);
                  }
                  var buf = token.data;
                  if (buf) {
                    if (buf.length > (token.length || 0)) {
                      token.data = buf.slice(0, token.length);
                    }
                    delete token.length;
                  }
                  this.push(token);
                }
                this._token = null;
                this._readHexDigitsCount = 0;
                this._paramStr = '';
                this._mode = 0;
              }
            }, {
              key: "_handleSpecialOrPush",
              value: function _handleSpecialOrPush() {
                var token = this._token;
                var param = parseInt(this._paramStr || '0', 10) || 0;
                if (token.type === 2 && token.word === 'bin' && param > 0) {
                  this._mode = 4;
                  token.data = Buffer.alloc(param);
                  token.length = 0;
                } else if (token.type === 2 && token.word === '\'') {
                  this._mode = 5;
                  token.data = Buffer.alloc(1);
                  token.length = 0;
                  this._readHexDigitsCount = 0;
                } else {
                  this._flushToken();
                }
              }
            }, {
              key: "_handleByte",
              value: function _handleByte(c) {
                switch (this._mode) {
                  case 4:
                    {
                      var token = this._token;
                      if (token.data && utils_1.isNum(token.length)) {
                        token.data[token.length++] = c;
                      }
                      if (!utils_1.isNum(token.length) || !token.data || token.length >= token.data.length) {
                        this._flushToken();
                      }
                      break;
                    }
                  case 5:
                    {
                      var _token = this._token;
                      var byte = parseInt(String.fromCharCode(c), 16);
                      if (isNaN(byte) || !_token.data) {
                        console.warn('Bad hex digit');
                      } else if (this._readHexDigitsCount === 0) {
                        _token.data[0] += byte * 16;
                      } else {
                        _token.data[0] += byte;
                      }
                      this._readHexDigitsCount++;
                      if (this._readHexDigitsCount === 2) {
                        _token.length = 1;
                        this._flushToken();
                      }
                      break;
                    }
                  case 1:
                    {
                      if (!isAlpha(c)) {
                        this._token = {
                          type: 2,
                          word: String.fromCharCode(c)
                        };
                        this._handleSpecialOrPush();
                      } else {
                        this._mode = 2;
                        this._token = {
                          type: 2,
                          word: String.fromCharCode(c)
                        };
                      }
                      break;
                    }
                  case 2:
                    {
                      var _token2 = this._token;
                      if (isAlpha(c)) {
                        _token2.word += String.fromCharCode(c);
                      } else if (isNumeric(c) || c === 45) {
                        this._mode = 3;
                        this._paramStr = String.fromCharCode(c);
                      } else {
                        this._handleSpecialOrPush();
                        if (c !== 32) this._handleByte(c);
                      }
                      break;
                    }
                  case 3:
                    {
                      if (isNumeric(c)) {
                        this._paramStr += String.fromCharCode(c);
                      } else {
                        this._handleSpecialOrPush();
                        if (c !== 32) this._handleByte(c);
                      }
                      break;
                    }
                  case 0:
                    {
                      switch (c) {
                        case 123:
                          this._flushToken();
                          this.push({
                            type: 0
                          });
                          break;
                        case 125:
                          this._flushToken();
                          this.push({
                            type: 1
                          });
                          break;
                        case 92:
                          this._flushToken();
                          this._mode = 1;
                          break;
                        case 13:
                        case 10:
                          break;
                        default:
                          {
                            var _token3 = this._token;
                            if (!_token3) {
                              this._token = {
                                type: 3,
                                data: Buffer.alloc(256),
                                length: 1
                              };
                              this._token.data[0] = c;
                            } else if (_token3 && _token3.type === 3) {
                              if (_token3.length >= _token3.data.length) {
                                _token3.data = Buffer.concat([_token3.data, Buffer.alloc(256)]);
                              }
                              _token3.data[_token3.length++] = c;
                            } else {
                              throw new Error('Unpushed token!');
                            }
                          }
                      }
                      break;
                    }
                  default:
                    throw new Error('Unknown state!');
                }
              }
            }, {
              key: "_transform",
              value: function _transform(chunk, encoding, cb) {
                try {
                  var buf = utils_1.isStr(chunk) ? Buffer.from(chunk, encoding) : chunk;
                  for (var i = 0; i < buf.length; i++) {
                    var c = buf[i];
                    this._handleByte(c);
                  }
                } catch (err) {
                  return cb(err);
                }
                cb();
              }
            }, {
              key: "_flush",
              value: function _flush(cb) {
                this._flushToken();
                cb();
              }
            }]);
            return Tokenize;
          }(stream_1.Transform);
          exports.Tokenize = Tokenize;
          exports.default = Tokenize;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "./utils": 53,
      "buffer": 7,
      "stream": 57
    }],
    53: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNum = exports.isStr = exports.isDef = void 0;
      function isDef(thing) {
        return typeof thing !== 'undefined';
      }
      exports.isDef = isDef;
      function isStr(thing) {
        return typeof thing === 'string';
      }
      exports.isStr = isStr;
      function isNum(thing) {
        return typeof thing === 'number';
      }
      exports.isNum = isNum;
    }, {}],
    54: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.words = void 0;
      exports.words = {
        "'": 1,
        "-": 1,
        "*": 1,
        ":": 1,
        "\\": 1,
        "_": 1,
        "{": 1,
        "|": 1,
        "}": 1,
        "~": 1,
        "ab": 2,
        "absh": 3,
        "abslock": 4,
        "absnoovrlp": 2,
        "absw": 3,
        "acaps": 2,
        "acccircle": 2,
        "acccomma": 2,
        "accdot": 2,
        "accnone": 2,
        "accunderdot": 2,
        "acf": 3,
        "adeff": 3,
        "additive": 4,
        "adeflang": 3,
        "adjustright": 4,
        "adn": 3,
        "aenddoc": 4,
        "aendnotes": 4,
        "aexpnd": 3,
        "af": 3,
        "afelev": 4,
        "afs": 3,
        "aftnbj": 4,
        "aftncn": 5,
        "aftnnalc": 4,
        "aftnnar": 4,
        "aftnnauc": 4,
        "aftnnchi": 4,
        "aftnnchosung": 4,
        "aftnncnum": 4,
        "aftnndbar": 4,
        "aftnndbnum": 4,
        "aftnndbnumd": 4,
        "aftnndbnumk": 4,
        "aftnndbnumt": 4,
        "aftnnganada": 4,
        "aftnngbnum": 4,
        "aftnngbnumd": 4,
        "aftnngbnumk": 4,
        "aftnngbnuml": 4,
        "aftnnrlc": 4,
        "aftnnruc": 4,
        "aftnnzodiac": 4,
        "aftnnzodiacd": 4,
        "aftnnzodiacl": 4,
        "aftnrestart": 4,
        "aftnrstcont": 4,
        "aftnsep": 5,
        "aftnsepc": 5,
        "aftnstart": 3,
        "aftntj": 4,
        "ai": 2,
        "alang": 3,
        "allowfieldendsel": 4,
        "allprot": 4,
        "alntblind": 4,
        "alt": 4,
        "animtext": 3,
        "annotation": 5,
        "annotprot": 4,
        "ansi": 4,
        "ansicpg": 3,
        "aoutl": 2,
        "ApplyBrkRules": 4,
        "ascaps": 2,
        "ashad": 2,
        "asianbrkrule": 4,
        "aspalpha": 2,
        "aspnum": 2,
        "astrike": 2,
        "atnauthor": 5,
        "atndate": 5,
        "atnicn": 5,
        "atnid": 5,
        "atnparent": 5,
        "atnref": 5,
        "atntime": 5,
        "atrfend": 5,
        "atrfstart": 5,
        "aul": 2,
        "auld": 2,
        "auldb": 2,
        "aulnone": 2,
        "aulw": 2,
        "aup": 3,
        "author": 5,
        "autofmtoverride": 4,
        "b": 2,
        "background": 5,
        "bdbfhdr": 4,
        "bdrrlswsix": 4,
        "bgbdiag": 4,
        "bgcross": 4,
        "bgdcross": 4,
        "bgdkbdiag": 4,
        "bgdkcross": 4,
        "bgdkdcross": 4,
        "bgdkfdiag": 4,
        "bgdkhoriz": 4,
        "bgdkvert": 4,
        "bgfdiag": 4,
        "bghoriz": 4,
        "bgvert": 4,
        "bin": 3,
        "binfsxn": 3,
        "binsxn": 3,
        "bkmkcolf": 3,
        "bkmkcoll": 3,
        "bkmkend": 5,
        "bkmkpub": 4,
        "bkmkstart": 5,
        "bliptag": 3,
        "blipuid": 5,
        "blipupi": 3,
        "blue": 3,
        "bookfold": 4,
        "bookfoldrev": 4,
        "bookfoldsheets": 3,
        "box": 4,
        "brdrart": 3,
        "brdrb": 4,
        "brdrbar": 4,
        "brdrbtw": 4,
        "brdrcf": 3,
        "brdrdash": 4,
        "brdrdashd": 4,
        "brdrdashdd": 4,
        "brdrdashdot": 4,
        "brdrdashdotdot": 4,
        "brdrdashdotstr": 4,
        "brdrdashsm": 4,
        "brdrdb": 4,
        "brdrdot": 4,
        "brdremboss": 4,
        "brdrengrave": 4,
        "brdrframe": 4,
        "brdrhair": 4,
        "brdrinset": 4,
        "brdrl": 4,
        "brdrnil": 4,
        "brdrnone": 4,
        "brdroutset": 4,
        "brdrr": 4,
        "brdrs": 4,
        "brdrsh": 4,
        "brdrt": 4,
        "brdrtbl": 4,
        "brdrth": 4,
        "brdrthtnlg": 4,
        "brdrthtnmg": 4,
        "brdrthtnsg": 4,
        "brdrtnthlg": 4,
        "brdrtnthmg": 4,
        "brdrtnthsg": 4,
        "brdrtnthtnlg": 4,
        "brdrtnthtnmg": 4,
        "brdrtnthtnsg": 4,
        "brdrtriple": 4,
        "brdrw": 3,
        "brdrwavy": 4,
        "brdrwavydb": 4,
        "brkfrm": 4,
        "brsp": 3,
        "bullet": 1,
        "buptim": 5,
        "bxe": 4,
        "caccentfive": 4,
        "caccentfour": 4,
        "caccentone": 4,
        "caccentsix": 4,
        "caccentthree": 4,
        "caccenttwo": 4,
        "cachedcolbal": 4,
        "caps": 2,
        "category": 5,
        "cb": 3,
        "cbackgroundone": 4,
        "cbackgroundtwo": 4,
        "cbpat": 3,
        "cchs": 3,
        "cell": 1,
        "cellx": 3,
        "cf": 3,
        "cfollowedhyperlink": 4,
        "cfpat": 3,
        "cgrid": 3,
        "charrsid": 3,
        "charscalex": 3,
        "chatn": 1,
        "chbgbdiag": 4,
        "chbgcross": 4,
        "chbgdcross": 4,
        "chbgdkbdiag": 4,
        "chbgdkcross": 4,
        "chbgdkdcross": 4,
        "chbgdkfdiag": 4,
        "chbgdkhoriz": 4,
        "chbgdkvert": 4,
        "chbgfdiag": 4,
        "chbghoriz": 4,
        "chbgvert": 4,
        "chbrdr": 4,
        "chcbpat": 3,
        "chcfpat": 3,
        "chdate": 1,
        "chdpa": 1,
        "chdpl": 1,
        "chftn": 1,
        "chftnsep": 1,
        "chftnsepc": 1,
        "chpgn": 1,
        "chhres": 3,
        "chshdng": 3,
        "chtime": 1,
        "chyperlink": 4,
        "clbgbdiag": 4,
        "clbgcross": 4,
        "clbgdcross": 4,
        "clbgdkbdiag": 4,
        "clbgdkcross": 4,
        "clbgdkdcross": 4,
        "clbgdkfdiag": 4,
        "clbgdkhor": 4,
        "clbgdkvert": 4,
        "clbgfdiag": 4,
        "clbghoriz": 4,
        "clbgvert": 4,
        "clbrdrb": 4,
        "clbrdrl": 4,
        "clbrdrr": 4,
        "clbrdrt": 4,
        "clcbpat": 3,
        "clcbpatraw": 3,
        "clcfpat": 3,
        "clcfpatraw": 3,
        "cldel": 4,
        "cldelauth": 3,
        "cldeldttm": 3,
        "cldgll": 4,
        "cldglu": 4,
        "clFitText": 4,
        "clftsWidth": 3,
        "clhidemark": 4,
        "clins": 4,
        "clinsauth": 3,
        "clinsdttm": 3,
        "clmgf": 4,
        "clmrg": 4,
        "clmrgd": 4,
        "clmrgdauth": 3,
        "clmrgddttm": 3,
        "clmrgdr": 4,
        "clNoWrap": 4,
        "clpadb": 3,
        "clpadfb": 3,
        "clpadfl": 3,
        "clpadfr": 3,
        "clpadft": 3,
        "clpadl": 3,
        "clpadr": 3,
        "clpadt": 3,
        "clspb": 3,
        "clspfb": 3,
        "clspfl": 3,
        "clspfr": 3,
        "clspft": 3,
        "clspl": 3,
        "clspr": 3,
        "clspt": 3,
        "clshdng": 3,
        "clshdngraw": 3,
        "clshdrawnil": 4,
        "clsplit": 4,
        "clsplitr": 4,
        "cltxbtlr": 4,
        "cltxlrtb": 4,
        "cltxlrtbv": 4,
        "cltxtbrl": 4,
        "cltxtbrlv": 4,
        "clvertalb": 4,
        "clvertalc": 4,
        "clvertalt": 4,
        "clvmgf": 4,
        "clvmrg": 4,
        "clwWidth": 3,
        "cmaindarkone": 4,
        "cmaindarktwo": 4,
        "cmainlightone": 4,
        "cmainlighttwo": 4,
        "collapsed": 4,
        "colno": 3,
        "colorschememapping": 5,
        "colortbl": 5,
        "cols": 3,
        "colsr": 3,
        "colsx": 3,
        "column": 1,
        "colw": 3,
        "comment": 5,
        "company": 5,
        "contextualspace": 4,
        "cpg": 3,
        "crauth": 3,
        "crdate": 3,
        "creatim": 5,
        "cs": 3,
        "cshade": 3,
        "ctextone": 4,
        "ctexttwo": 4,
        "ctint": 3,
        "ctrl": 4,
        "cts": 3,
        "cufi": 3,
        "culi": 3,
        "curi": 3,
        "cvmme": 4,
        "datafield": 5,
        "datastore": 5,
        "date": 4,
        "dbch": 4,
        "defchp": 5,
        "deff": 3,
        "defformat": 4,
        "deflang": 3,
        "deflangfe": 3,
        "defpap": 5,
        "defshp": 4,
        "deftab": 3,
        "deleted": 2,
        "delrsid": 3,
        "dfrauth": 3,
        "dfrdate": 3,
        "dfrmtxtx": 3,
        "dfrmtxty": 3,
        "dfrstart": 3,
        "dfrstop": 3,
        "dfrxst": 3,
        "dghorigin": 3,
        "dghshow": 3,
        "dghspace": 3,
        "dgmargin": 4,
        "dgsnap": 4,
        "dgvorigin": 3,
        "dgvshow": 3,
        "dgvspace": 3,
        "dibitmap": 3,
        "disabled": 2,
        "dn": 3,
        "dntblnsbdb": 4,
        "do": 5,
        "dobxcolumn": 4,
        "dobxmargin": 4,
        "dobxpage": 4,
        "dobymargin": 4,
        "dobypage": 4,
        "dobypara": 4,
        "doccomm": 5,
        "doctemp": 4,
        "doctype": 3,
        "docvar": 5,
        "dodhgt": 3,
        "dolock": 4,
        "donotembedlingdata": 3,
        "donotembedsysfont": 3,
        "donotshowcomments": 4,
        "donotshowinsdel": 4,
        "donotshowmarkup": 4,
        "donotshowprops": 4,
        "dpaendhol": 4,
        "dpaendl": 3,
        "dpaendsol": 4,
        "dpaendw": 3,
        "dparc": 4,
        "dparcflipx": 4,
        "dparcflipy": 4,
        "dpastarthol": 4,
        "dpastartl": 3,
        "dpastartsol": 4,
        "dpastartw": 3,
        "dpcallout": 4,
        "dpcoa": 3,
        "dpcoaccent": 4,
        "dpcobestfit": 4,
        "dpcoborder": 4,
        "dpcodabs": 4,
        "dpcodbottom": 4,
        "dpcodcenter": 4,
        "dpcodescent": 3,
        "dpcodtop": 4,
        "dpcolength": 3,
        "dpcominusx": 4,
        "dpcominusy": 4,
        "dpcooffset": 3,
        "dpcosmarta": 4,
        "dpcotdouble": 4,
        "dpcotright": 4,
        "dpcotsingle": 4,
        "dpcottriple": 4,
        "dpcount": 3,
        "dpellipse": 4,
        "dpendgroup": 4,
        "dpfillbgcb": 3,
        "dpfillbgcg": 3,
        "dpfillbgcr": 3,
        "dpfillbggray": 3,
        "dpfillbgpal": 4,
        "dpfillfgcb": 3,
        "dpfillfgcg": 3,
        "dpfillfgcr": 3,
        "dpfillfggray": 3,
        "dpfillfgpal": 4,
        "dpfillpat": 3,
        "dpgroup": 4,
        "dpline": 4,
        "dplinecob": 3,
        "dplinecog": 3,
        "dplinecor": 3,
        "dplinedado": 4,
        "dplinedadodo": 4,
        "dplinedash": 4,
        "dplinedot": 4,
        "dplinegray": 3,
        "dplinehollow": 4,
        "dplinepal": 4,
        "dplinesolid": 4,
        "dplinew": 3,
        "dppolycount": 3,
        "dppolygon": 4,
        "dppolyline": 4,
        "dpptx": 3,
        "dppty": 3,
        "dprect": 4,
        "dproundr": 4,
        "dpshadow": 4,
        "dpshadx": 3,
        "dpshady": 3,
        "dptxbtlr": 4,
        "dptxbx": 4,
        "dptxbxmar": 3,
        "dptxbxtext": 5,
        "dptxlrtb": 4,
        "dptxlrtbv": 4,
        "dptxtbrl": 4,
        "dptxtbrlv": 4,
        "dpx": 3,
        "dpxsize": 3,
        "dpy": 3,
        "dpysize": 3,
        "dropcapli": 3,
        "dropcapt": 3,
        "ds": 3,
        "dxfrtext": 3,
        "dy": 3,
        "ebcend": 5,
        "ebcstart": 5,
        "edmins": 3,
        "embo": 2,
        "emdash": 1,
        "emfblip": 4,
        "emspace": 1,
        "endash": 1,
        "enddoc": 4,
        "endnhere": 4,
        "endnotes": 4,
        "enforceprot": 3,
        "enspace": 1,
        "expnd": 3,
        "expndtw": 3,
        "expshrtn": 4,
        "f": 3,
        "faauto": 4,
        "facenter": 4,
        "facingp": 4,
        "factoidname": 5,
        "fafixed": 4,
        "fahang": 4,
        "falt": 5,
        "faroman": 4,
        "favar": 4,
        "fbias": 3,
        "fbidi": 4,
        "fbidis": 4,
        "fbimajor": 4,
        "fbiminor": 4,
        "fchars": 5,
        "fcharset": 3,
        "fcs": 3,
        "fdbmajor": 4,
        "fdbminor": 4,
        "fdecor": 4,
        "felnbrelev": 4,
        "fet": 3,
        "fetch": 4,
        "ffdefres": 3,
        "ffdeftext": 5,
        "ffentrymcr": 5,
        "ffexitmcr": 5,
        "ffformat": 5,
        "ffhaslistbox": 3,
        "ffhelptext": 5,
        "ffhps": 3,
        "ffl": 5,
        "ffmaxlen": 3,
        "ffname": 5,
        "ffownhelp": 3,
        "ffownstat": 3,
        "ffprot": 3,
        "ffrecalc": 3,
        "ffres": 3,
        "ffsize": 3,
        "ffstattext": 5,
        "fftype": 3,
        "fftypetxt": 3,
        "fhimajor": 4,
        "fhiminor": 4,
        "fi": 3,
        "fid": 3,
        "field": 5,
        "file": 5,
        "filetbl": 5,
        "fittext": 3,
        "fjgothic": 4,
        "fjminchou": 4,
        "fldalt": 4,
        "flddirty": 4,
        "fldedit": 4,
        "fldinst": 5,
        "fldlock": 4,
        "fldpriv": 4,
        "fldrslt": 5,
        "fldtype": 5,
        "flomajor": 4,
        "flominor": 4,
        "fmodern": 4,
        "fn": 3,
        "fname": 5,
        "fnetwork": 4,
        "fnil": 4,
        "fnonfilesys": 4,
        "fontemb": 5,
        "fontfile": 5,
        "fonttbl": 5,
        "footer": 5,
        "footerf": 5,
        "footerl": 5,
        "footerr": 5,
        "footery": 3,
        "footnote": 5,
        "forceupgrade": 4,
        "formatConverter": 5,
        "formdisp": 4,
        "formfield": 5,
        "formprot": 4,
        "formshade": 4,
        "fosnum": 3,
        "fprq": 3,
        "fracwidth": 4,
        "frelative": 3,
        "frmtxbtlr": 4,
        "frmtxlrtb": 4,
        "frmtxlrtbv": 4,
        "frmtxtbrl": 4,
        "frmtxtbrlv": 4,
        "froman": 4,
        "fromhtml": 3,
        "fromtext": 4,
        "fs": 3,
        "fscript": 4,
        "fswiss": 4,
        "ftech": 4,
        "ftnalt": 4,
        "ftnbj": 4,
        "ftncn": 5,
        "ftnil": 4,
        "ftnlytwnine": 4,
        "ftnnalc": 4,
        "ftnnar": 4,
        "ftnnauc": 4,
        "ftnnchi": 4,
        "ftnnchosung": 4,
        "ftnncnum": 4,
        "ftnndbar": 4,
        "ftnndbnum": 4,
        "ftnndbnumd": 4,
        "ftnndbnumk": 4,
        "ftnndbnumt": 4,
        "ftnnganada": 4,
        "ftnngbnum": 4,
        "ftnngbnumd": 4,
        "ftnngbnumk": 4,
        "ftnngbnuml": 4,
        "ftnnrlc": 4,
        "ftnnruc": 4,
        "ftnnzodiac": 4,
        "ftnnzodiacd": 4,
        "ftnnzodiacl": 4,
        "ftnrestart": 4,
        "ftnrstcont": 4,
        "ftnrstpg": 4,
        "ftnsep": 5,
        "ftnsepc": 5,
        "ftnstart": 3,
        "ftntj": 4,
        "fttruetype": 4,
        "fvaliddos": 4,
        "fvalidhpfs": 4,
        "fvalidmac": 4,
        "fvalidntfs": 4,
        "g": 5,
        "gcw": 3,
        "generator": 5,
        "green": 3,
        "grfdocevents": 3,
        "gridtbl": 5,
        "gutter": 3,
        "gutterprl": 4,
        "guttersxn": 3,
        "header": 5,
        "headerf": 5,
        "headerl": 5,
        "headerr": 5,
        "headery": 3,
        "hich": 4,
        "highlight": 3,
        "hl": 5,
        "hlfr": 5,
        "hlinkbase": 5,
        "hlloc": 5,
        "hlsrc": 5,
        "horzdoc": 4,
        "horzsect": 4,
        "horzvert": 3,
        "hr": 3,
        "hres": 3,
        "hrule": 4,
        "hsv": 5,
        "htmautsp": 4,
        "htmlbase": 4,
        "htmlrtf": 2,
        "htmltag": 5,
        "hwelev": 4,
        "hyphauto": 2,
        "hyphcaps": 2,
        "hyphconsec": 3,
        "hyphhotz": 3,
        "hyphpar": 2,
        "i": 2,
        "id": 3,
        "ignoremixedcontent": 3,
        "ilfomacatclnup": 3,
        "ilvl": 3,
        "impr": 2,
        "indmirror": 4,
        "indrlsweleven": 4,
        "info": 5,
        "insrsid": 3,
        "intbl": 4,
        "ipgp": 3,
        "irowband": 3,
        "irow": 3,
        "itap": 3,
        "ixe": 4,
        "jcompress": 4,
        "jexpand": 4,
        "jis": 4,
        "jpegblip": 4,
        "jsksu": 4,
        "keep": 4,
        "keepn": 4,
        "kerning": 3,
        "keycode": 5,
        "keywords": 5,
        "krnprsnet": 4,
        "ksulang": 3,
        "jclisttab": 4,
        "landscape": 4,
        "lang": 3,
        "langfe": 3,
        "langfenp": 3,
        "langnp": 3,
        "lastrow": 4,
        "latentstyles": 5,
        "lbr": 3,
        "lchars": 5,
        "ldblquote": 1,
        "level": 3,
        "levelfollow": 3,
        "levelindent": 3,
        "leveljc": 3,
        "leveljcn": 3,
        "levellegal": 3,
        "levelnfc": 3,
        "levelnfcn": 3,
        "levelnorestart": 3,
        "levelnumbers": 5,
        "levelold": 3,
        "levelpicture": 3,
        "levelpicturenosize": 4,
        "levelprev": 3,
        "levelprevspace": 3,
        "levelspace": 3,
        "levelstartat": 3,
        "leveltemplateid": 3,
        "leveltext": 5,
        "lfolevel": 5,
        "li": 3,
        "line": 1,
        "linebetcol": 4,
        "linecont": 4,
        "linemod": 3,
        "lineppage": 4,
        "linerestart": 4,
        "linestart": 3,
        "linestarts": 3,
        "linex": 3,
        "linkself": 4,
        "linkstyles": 4,
        "linkval": 5,
        "lin": 3,
        "lisa": 3,
        "lisb": 3,
        "list": 5,
        "listhybrid": 4,
        "listid": 3,
        "listlevel": 5,
        "listname": 5,
        "listoverride": 5,
        "listoverridecount": 3,
        "listoverrideformat": 3,
        "listoverridestartat": 4,
        "listoverridetable": 5,
        "listpicture": 5,
        "listrestarthdn": 3,
        "listsimple": 3,
        "liststyleid": 3,
        "liststylename": 5,
        "listtable": 5,
        "listtemplateid": 3,
        "listtext": 5,
        "lnbrkrule": 4,
        "lndscpsxn": 4,
        "lnongrid": 4,
        "loch": 4,
        "lquote": 1,
        "ls": 3,
        "lsdlocked": 3,
        "lsdlockeddef": 3,
        "lsdlockedexcept": 5,
        "lsdpriority": 3,
        "lsdprioritydef": 3,
        "lsdqformat": 3,
        "lsdqformatdef": 3,
        "lsdsemihidden": 3,
        "lsdsemihiddendef": 3,
        "lsdstimax": 3,
        "lsdunhideused": 3,
        "lsdunhideuseddef": 3,
        "ltrch": 4,
        "ltrdoc": 4,
        "ltrmark": 1,
        "ltrpar": 4,
        "ltrrow": 4,
        "ltrsect": 4,
        "lvltentative": 4,
        "lytcalctblwd": 4,
        "lytexcttp": 4,
        "lytprtmet": 4,
        "lyttblrtgr": 4,
        "mac": 4,
        "macc": 5,
        "maccPr": 5,
        "macpict": 4,
        "mailmerge": 5,
        "makebackup": 4,
        "maln": 5,
        "malnScr": 5,
        "manager": 5,
        "margb": 3,
        "margbsxn": 3,
        "margl": 3,
        "marglsxn": 3,
        "margmirror": 4,
        "margmirsxn": 4,
        "margPr": 5,
        "margr": 3,
        "margrsxn": 3,
        "margSz": 3,
        "margt": 3,
        "margtsxn": 3,
        "mbar": 5,
        "mbarPr": 5,
        "mbaseJc": 5,
        "mbegChr": 5,
        "mborderBox": 5,
        "mborderBoxPr": 5,
        "mbox": 5,
        "mboxPr": 5,
        "mbrk": 3,
        "mbrkBin": 3,
        "mbrkBinSub": 3,
        "mcGp": 3,
        "mcGpRule": 3,
        "mchr": 5,
        "mcount": 5,
        "mcSp": 3,
        "mctrlPr": 5,
        "md": 5,
        "mdefJc": 3,
        "mdeg": 5,
        "mdegHide": 5,
        "mden": 5,
        "mdiff": 5,
        "mdiffSty": 3,
        "mdispDef": 3,
        "mdPr": 5,
        "me": 5,
        "mendChr": 5,
        "meqArr": 5,
        "meqArrPr": 5,
        "mf": 5,
        "mfName": 5,
        "mfPr": 5,
        "mfunc": 5,
        "mfuncPr": 5,
        "mgroupChr": 5,
        "mgroupChrPr": 5,
        "mgrow": 5,
        "mhideBot": 5,
        "mhideLeft": 5,
        "mhideRight": 5,
        "mhideTop": 5,
        "mhtmltag": 5,
        "min": 3,
        "minterSp": 3,
        "mintLim": 3,
        "mintraSp": 3,
        "mjc": 3,
        "mlim": 5,
        "mlimLoc": 5,
        "mlimLow": 5,
        "mlimLowPr": 5,
        "mlimUpp": 5,
        "mlimUppPr": 5,
        "mlit": 4,
        "mlMargin": 3,
        "mm": 5,
        "mmaddfieldname": 5,
        "mmath": 5,
        "mmathFont": 3,
        "mmathPict": 5,
        "mmathPr": 5,
        "mmattach": 4,
        "mmaxDist": 5,
        "mmblanklines": 4,
        "mmc": 5,
        "mmcJc": 5,
        "mmconnectstr": 5,
        "mmconnectstrdata": 5,
        "mmcPr": 5,
        "mmcs": 5,
        "mmdatasource": 5,
        "mmdatatypeaccess": 4,
        "mmdatatypeexcel": 4,
        "mmdatatypefile": 4,
        "mmdatatypeodbc": 4,
        "mmdatatypeodso": 4,
        "mmdatatypeqt": 4,
        "mmdefaultsql": 4,
        "mmdestemail": 4,
        "mmdestfax": 4,
        "mmdestnewdoc": 4,
        "mmdestprinter": 4,
        "mmerrors": 3,
        "mmfttypeaddress": 4,
        "mmfttypebarcode": 4,
        "mmfttypedbcolumn": 4,
        "mmfttypemapped": 4,
        "mmfttypenull": 4,
        "mmfttypesalutation": 4,
        "mmheadersource": 5,
        "mmjdsotype": 3,
        "mmlinktoquery": 4,
        "mmmailsubject": 5,
        "mmmaintypecatalog": 4,
        "mmmaintypeemail": 4,
        "mmmaintypeenvelopes": 4,
        "mmmaintypefax": 4,
        "mmmaintypelabels": 4,
        "mmmaintypeletters": 4,
        "mmodso": 5,
        "mmodsoactive": 3,
        "mmodsocoldelim": 3,
        "mmodsocolumn": 3,
        "mmodsodynaddr": 3,
        "mmodsofhdr": 3,
        "mmodsofilter": 5,
        "mmodsofldmpdata": 5,
        "mmodsofmcolumn": 3,
        "mmodsohash": 3,
        "mmodsolid": 3,
        "mmodsomappedname": 5,
        "mmodsoname": 5,
        "mmodsorecipdata": 5,
        "mmodsosort": 5,
        "mmodsosrc": 5,
        "mmodsotable": 5,
        "mmodsoudl": 5,
        "mmodsoudldata": 5,
        "mmodsouniquetag": 5,
        "mmPr": 5,
        "mmquery": 5,
        "mmr": 5,
        "mmreccur": 3,
        "mmshowdata": 4,
        "mnary": 5,
        "mnaryLim": 3,
        "mnaryPr": 5,
        "mnoBreak": 5,
        "mnor": 4,
        "mnum": 5,
        "mo": 3,
        "mobjDist": 5,
        "moMath": 5,
        "moMathPara": 5,
        "moMathParaPr": 5,
        "mopEmu": 5,
        "mphant": 5,
        "mphantPr": 5,
        "mplcHide": 5,
        "mpos": 5,
        "mpostSp": 3,
        "mpreSp": 3,
        "mr": 5,
        "mrad": 5,
        "mradPr": 5,
        "mrMargin": 3,
        "mrPr": 5,
        "mrSp": 3,
        "mrSpRule": 3,
        "mscr": 3,
        "msepChr": 5,
        "mshow": 5,
        "mshp": 5,
        "msmallFrac": 3,
        "msmcap": 4,
        "msPre": 5,
        "msPrePr": 5,
        "msSub": 5,
        "msSubPr": 5,
        "msSubSup": 5,
        "msSubSupPr": 5,
        "msSup": 5,
        "msSupPr": 5,
        "mstrikeBLTR": 5,
        "mstrikeH": 5,
        "mstrikeTLBR": 5,
        "mstrikeV": 5,
        "msty": 3,
        "msub": 5,
        "msubHide": 5,
        "msup": 5,
        "msupHide": 5,
        "mtransp": 5,
        "mtype": 5,
        "muser": 4,
        "mvauth": 3,
        "mvdate": 3,
        "mvertJc": 5,
        "mvf": 4,
        "mvfmf": 5,
        "mvfml": 5,
        "mvt": 4,
        "mvtof": 5,
        "mvtol": 5,
        "mwrapIndent": 3,
        "mwrapRight": 3,
        "mzeroAsc": 5,
        "mzeroDesc": 5,
        "mzeroWid": 5,
        "nestcell": 1,
        "nestrow": 1,
        "nesttableprops": 5,
        "newtblstyruls": 4,
        "nextfile": 5,
        "noafcnsttbl": 4,
        "nobrkwrptbl": 4,
        "nocolbal": 4,
        "nocompatoptions": 4,
        "nocwrap": 4,
        "nocxsptable": 4,
        "noextrasprl": 4,
        "nofchars": 3,
        "nofcharsws": 3,
        "nofeaturethrottle": 4,
        "nofpages": 3,
        "nofwords": 3,
        "nogrowautofit": 4,
        "noindnmbrts": 4,
        "nojkernpunct": 4,
        "nolead": 4,
        "noline": 4,
        "nolnhtadjtbl": 4,
        "nonesttables": 5,
        "nonshppict": 5,
        "nooverflow": 4,
        "noproof": 4,
        "noqfpromote": 4,
        "nosectexpand": 4,
        "nosnaplinegrid": 4,
        "nospaceforul": 4,
        "nosupersub": 4,
        "notabind": 4,
        "notbrkcnstfrctbl": 4,
        "notcvasp": 4,
        "notvatxbx": 4,
        "nouicompat": 4,
        "noultrlspc": 4,
        "nowidctlpar": 4,
        "nowrap": 4,
        "nowwrap": 4,
        "noxlattoyen": 4,
        "objalias": 5,
        "objalign": 3,
        "objattph": 4,
        "objautlink": 4,
        "objclass": 5,
        "objcropb": 3,
        "objcropl": 3,
        "objcropr": 3,
        "objcropt": 3,
        "objdata": 5,
        "object": 5,
        "objemb": 4,
        "objh": 3,
        "objhtml": 4,
        "objicemb": 4,
        "objlink": 4,
        "objlock": 4,
        "objname": 5,
        "objocx": 4,
        "objpub": 4,
        "objscalex": 3,
        "objscaley": 3,
        "objsect": 5,
        "objsetsize": 4,
        "objsub": 4,
        "objtime": 5,
        "objtransy": 3,
        "objupdate": 4,
        "objw": 3,
        "ogutter": 3,
        "oldas": 4,
        "oldcprops": 5,
        "oldlinewrap": 4,
        "oldpprops": 5,
        "oldsprops": 5,
        "oldtprops": 5,
        "oleclsid": 5,
        "operator": 5,
        "otblrul": 4,
        "outl": 2,
        "outlinelevel": 3,
        "overlay": 4,
        "page": 1,
        "pagebb": 4,
        "panose": 5,
        "paperh": 3,
        "paperw": 3,
        "par": 1,
        "pararsid": 3,
        "pard": 4,
        "password": 5,
        "passwordhash": 5,
        "pc": 4,
        "pca": 4,
        "pgbrdrb": 4,
        "pgbrdrfoot": 4,
        "pgbrdrhead": 4,
        "pgbrdrl": 4,
        "pgbrdropt": 3,
        "pgbrdrr": 4,
        "pgbrdrsnap": 4,
        "pgbrdrt": 4,
        "pghsxn": 3,
        "pgnbidia": 4,
        "pgnbidib": 4,
        "pgnchosung": 4,
        "pgncnum": 4,
        "pgncont": 4,
        "pgndbnum": 4,
        "pgndbnumd": 4,
        "pgndbnumk": 4,
        "pgndbnumt": 4,
        "pgndec": 4,
        "pgndecd": 4,
        "pgnganada": 4,
        "pgngbnum": 4,
        "pgngbnumd": 4,
        "pgngbnumk": 4,
        "pgngbnuml": 4,
        "pgnhindia": 4,
        "pgnhindib": 4,
        "pgnhindic": 4,
        "pgnhindid": 4,
        "pgnhn": 3,
        "pgnhnsc": 4,
        "pgnhnsh": 4,
        "pgnhnsm": 4,
        "pgnhnsn": 4,
        "pgnhnsp": 4,
        "pgnid": 4,
        "pgnlcltr": 4,
        "pgnlcrm": 4,
        "pgnrestart": 4,
        "pgnstart": 3,
        "pgnstarts": 3,
        "pgnthaia": 4,
        "pgnthaib": 4,
        "pgnthaic": 4,
        "pgnucltr": 4,
        "pgnucrm": 4,
        "pgnvieta": 4,
        "pgnx": 3,
        "pgny": 3,
        "pgnzodiac": 4,
        "pgnzodiacd": 4,
        "pgnzodiacl": 4,
        "pgp": 5,
        "pgptbl": 5,
        "pgwsxn": 3,
        "phcol": 4,
        "phmrg": 4,
        "phpg": 4,
        "picbmp": 4,
        "picbpp": 3,
        "piccropb": 3,
        "piccropl": 3,
        "piccropr": 3,
        "piccropt": 3,
        "pich": 3,
        "pichgoal": 3,
        "picprop": 5,
        "picscaled": 4,
        "picscalex": 3,
        "picscaley": 3,
        "pict": 5,
        "picw": 3,
        "picwgoal": 3,
        "pindtabqc": 4,
        "pindtabql": 4,
        "pindtabqr": 4,
        "plain": 4,
        "pmartabqc": 4,
        "pmartabql": 4,
        "pmartabqr": 4,
        "pmmetafile": 3,
        "pn": 5,
        "pnacross": 4,
        "pnaiu": 4,
        "pnaiud": 4,
        "pnaiueo": 4,
        "pnaiueod": 4,
        "pnb": 2,
        "pnbidia": 4,
        "pnbidib": 4,
        "pncaps": 2,
        "pncard": 4,
        "pncf": 3,
        "pnchosung": 4,
        "pncnum": 4,
        "pndbnum": 4,
        "pndbnumd": 4,
        "pndbnumk": 4,
        "pndbnuml": 4,
        "pndbnumt": 4,
        "pndec": 4,
        "pndecd": 4,
        "pnf": 3,
        "pnfs": 3,
        "pnganada": 4,
        "pngblip": 4,
        "pngbnum": 4,
        "pngbnumd": 4,
        "pngbnumk": 4,
        "pngbnuml": 4,
        "pnhang": 4,
        "pni": 2,
        "pnindent": 3,
        "pniroha": 4,
        "pnirohad": 4,
        "pnlcltr": 4,
        "pnlcrm": 4,
        "pnlvl": 3,
        "pnlvlblt": 4,
        "pnlvlbody": 4,
        "pnlvlcont": 4,
        "pnnumonce": 4,
        "pnord": 4,
        "pnordt": 4,
        "pnprev": 4,
        "pnqc": 4,
        "pnql": 4,
        "pnqr": 4,
        "pnrauth": 3,
        "pnrdate": 3,
        "pnrestart": 4,
        "pnrnfc": 3,
        "pnrnot": 4,
        "pnrpnbr": 3,
        "pnrrgb": 3,
        "pnrstart": 3,
        "pnrstop": 3,
        "pnrxst": 3,
        "pnscaps": 2,
        "pnseclvl": 5,
        "pnsp": 3,
        "pnstart": 3,
        "pnstrike": 2,
        "pntext": 5,
        "pntxta": 5,
        "pntxtb": 5,
        "pnucltr": 4,
        "pnucrm": 4,
        "pnul": 2,
        "pnuld": 4,
        "pnuldash": 4,
        "pnuldashd": 4,
        "pnuldashdd": 4,
        "pnuldb": 4,
        "pnulhair": 4,
        "pnulnone": 4,
        "pnulth": 4,
        "pnulw": 4,
        "pnulwave": 4,
        "pnzodiac": 4,
        "pnzodiacd": 4,
        "pnzodiacl": 4,
        "posnegx": 3,
        "posnegy": 3,
        "posx": 3,
        "posxc": 4,
        "posxi": 4,
        "posxl": 4,
        "posxo": 4,
        "posxr": 4,
        "posy": 3,
        "posyb": 4,
        "posyc": 4,
        "posyil": 4,
        "posyin": 4,
        "posyout": 4,
        "posyt": 4,
        "prauth": 3,
        "prcolbl": 4,
        "prdate": 3,
        "printdata": 4,
        "printim": 5,
        "private": 5,
        "propname": 5,
        "proptype": 3,
        "protect": 2,
        "protend": 5,
        "protlevel": 3,
        "protstart": 5,
        "protusertbl": 5,
        "psover": 4,
        "psz": 3,
        "ptabldot": 4,
        "ptablmdot": 4,
        "ptablminus": 4,
        "ptablnone": 4,
        "ptabluscore": 4,
        "pubauto": 4,
        "pvmrg": 4,
        "pvpara": 4,
        "pvpg": 4,
        "pwd": 3,
        "pxe": 5,
        "qc": 4,
        "qd": 4,
        "qj": 4,
        "qk": 3,
        "ql": 4,
        "qmspace": 1,
        "qr": 4,
        "qt": 4,
        "rawclbgdkbdiag": 4,
        "rawclbgbdiag": 4,
        "rawclbgcross": 4,
        "rawclbgdcross": 4,
        "rawclbgdkcross": 4,
        "rawclbgdkdcross": 4,
        "rawclbgdkfdiag": 4,
        "rawclbgdkhor": 4,
        "rawclbgdkvert": 4,
        "rawclbgfdiag": 4,
        "rawclbghoriz": 4,
        "rawclbgvert": 4,
        "rdblquote": 1,
        "readonlyrecommended": 4,
        "readprot": 4,
        "red": 3,
        "relyonvml": 3,
        "remdttm": 4,
        "rempersonalinfo": 4,
        "result": 5,
        "revauth": 3,
        "revauthdel": 3,
        "revbar": 3,
        "revdttm": 3,
        "revdttmdel": 3,
        "revised": 2,
        "revisions": 4,
        "revprop": 3,
        "revprot": 4,
        "revtbl": 5,
        "revtim": 5,
        "ri": 3,
        "rin": 3,
        "row": 1,
        "rquote": 1,
        "rsid": 3,
        "rsidroot": 3,
        "rsidtbl": 5,
        "rsltbmp": 4,
        "rslthtml": 4,
        "rsltmerge": 4,
        "rsltpict": 4,
        "rsltrtf": 4,
        "rslttxt": 4,
        "rtf": 5,
        "rtlch": 4,
        "rtldoc": 4,
        "rtlgutter": 4,
        "rtlmark": 1,
        "rtlpar": 4,
        "rtlrow": 4,
        "rtlsect": 4,
        "rxe": 5,
        "s": 3,
        "sa": 3,
        "saauto": 2,
        "saftnnalc": 4,
        "saftnnar": 4,
        "saftnnauc": 4,
        "saftnnchi": 4,
        "saftnnchosung": 4,
        "saftnncnum": 4,
        "saftnndbar": 4,
        "saftnndbnum": 4,
        "saftnndbnumd": 4,
        "saftnndbnumk": 4,
        "saftnndbnumt": 4,
        "saftnnganada": 4,
        "saftnngbnum": 4,
        "saftnngbnumd": 4,
        "saftnngbnumk": 4,
        "saftnngbnuml": 4,
        "saftnnrlc": 4,
        "saftnnruc": 4,
        "saftnnzodiac": 4,
        "saftnnzodiacd": 4,
        "saftnnzodiacl": 4,
        "saftnrestart": 4,
        "saftnrstcont": 4,
        "saftnstart": 3,
        "sautoupd": 4,
        "saveinvalidxml": 4,
        "saveprevpict": 4,
        "sb": 3,
        "sbasedon": 3,
        "sbauto": 2,
        "sbkcol": 4,
        "sbkeven": 4,
        "sbknone": 4,
        "sbkodd": 4,
        "sbkpage": 4,
        "sbys": 4,
        "scaps": 2,
        "scompose": 4,
        "sec": 3,
        "sect": 1,
        "sectd": 4,
        "sectdefaultcl": 4,
        "sectexpand": 3,
        "sectlinegrid": 3,
        "sectnum": 1,
        "sectrsid": 3,
        "sectspecifycl": 4,
        "sectspecifygen": 4,
        "sectspecifyl": 4,
        "sectunlocked": 4,
        "sftnbj": 4,
        "sftnnalc": 4,
        "sftnnar": 4,
        "sftnnauc": 4,
        "sftnnchi": 4,
        "sftnnchosung": 4,
        "sftnncnum": 4,
        "sftnndbar": 4,
        "sftnndbnum": 4,
        "sftnndbnumd": 4,
        "sftnndbnumk": 4,
        "sftnndbnumt": 4,
        "sftnnganada": 4,
        "sftnngbnum": 4,
        "sftnngbnumd": 4,
        "sftnngbnumk": 4,
        "sftnngbnuml": 4,
        "sftnnrlc": 4,
        "sftnnruc": 4,
        "sftnnzodiac": 4,
        "sftnnzodiacd": 4,
        "sftnnzodiacl": 4,
        "sftnrestart": 4,
        "sftnrstcont": 4,
        "sftnrstpg": 4,
        "sftnstart": 3,
        "sftntj": 4,
        "shad": 2,
        "shading": 3,
        "shidden": 4,
        "shift": 4,
        "showplaceholdtext": 3,
        "showxmlerrors": 3,
        "shp": 5,
        "shpbottom": 3,
        "shpbxcolumn": 4,
        "shpbxignore": 4,
        "shpbxmargin": 4,
        "shpbxpage": 4,
        "shpbyignore": 4,
        "shpbymargin": 4,
        "shpbypage": 4,
        "shpbypara": 4,
        "shpfblwtxt": 3,
        "shpfhdr": 3,
        "shpgrp": 5,
        "shpinst": 5,
        "shpleft": 3,
        "shplid": 3,
        "shplockanchor": 4,
        "shppict": 5,
        "shpright": 3,
        "shprslt": 5,
        "shptop": 3,
        "shptxt": 5,
        "shpwrk": 3,
        "shpwr": 3,
        "shpz": 3,
        "sl": 3,
        "slink": 3,
        "slmult": 3,
        "slocked": 4,
        "sn": 5,
        "snaptogridincell": 4,
        "snext": 3,
        "softcol": 4,
        "softlheight": 3,
        "softline": 4,
        "softpage": 4,
        "sp": 5,
        "spersonal": 4,
        "spltpgpar": 4,
        "splytwnine": 4,
        "spriority": 3,
        "sprsbsp": 4,
        "sprslnsp": 4,
        "sprsspbf": 4,
        "sprstsm": 4,
        "sprstsp": 4,
        "spv": 4,
        "sqformat": 4,
        "srauth": 3,
        "srdate": 3,
        "sreply": 4,
        "ssemihidden": 3,
        "staticval": 5,
        "stextflow": 3,
        "strike": 2,
        "striked": 2,
        "stshfbi": 3,
        "stshfdbch": 3,
        "stshfhich": 3,
        "stshfloch": 3,
        "stylelock": 4,
        "stylelockbackcomp": 4,
        "stylelockenforced": 4,
        "stylelockqfset": 4,
        "stylelocktheme": 4,
        "stylesheet": 5,
        "stylesortmethod": 3,
        "styrsid": 3,
        "sub": 4,
        "subdocument": 3,
        "subfontbysize": 4,
        "subject": 5,
        "sunhideused": 3,
        "super": 4,
        "sv": 5,
        "svb": 5,
        "swpbdr": 4,
        "tab": 1,
        "tabsnoovrlp": 4,
        "taprtl": 4,
        "tb": 3,
        "tblind": 3,
        "tblindtype": 3,
        "tbllkbestfit": 4,
        "tbllkborder": 4,
        "tbllkcolor": 4,
        "tbllkfont": 4,
        "tbllkhdrcols": 4,
        "tbllkhdrrows": 4,
        "tbllklastcol": 4,
        "tbllklastrow": 4,
        "tbllknocolband": 4,
        "tbllknorowband": 4,
        "tbllkshading": 4,
        "tblrsid": 3,
        "tc": 5,
        "tcelld": 4,
        "tcf": 3,
        "tcl": 3,
        "tcn": 4,
        "tdfrmtxtBottom": 3,
        "tdfrmtxtLeft": 3,
        "tdfrmtxtRight": 3,
        "tdfrmtxtTop": 3,
        "template": 5,
        "themedata": 5,
        "themelang": 3,
        "themelangcs": 3,
        "themelangfe": 3,
        "time": 4,
        "title": 5,
        "titlepg": 4,
        "tldot": 4,
        "tleq": 4,
        "tlhyph": 4,
        "tlmdot": 4,
        "tlth": 4,
        "tlul": 4,
        "toplinepunct": 4,
        "tphcol": 4,
        "tphmrg": 4,
        "tphpg": 4,
        "tposnegx": 3,
        "tposnegy": 3,
        "tposxc": 4,
        "tposxi": 4,
        "tposxl": 4,
        "tposx": 3,
        "tposxo": 4,
        "tposxr": 4,
        "tposy": 3,
        "tposyb": 4,
        "tposyc": 4,
        "tposyil": 4,
        "tposyin": 4,
        "tposyout": 4,
        "tposyt": 4,
        "tpvmrg": 4,
        "tpvpara": 4,
        "tpvpg": 4,
        "tqc": 4,
        "tqdec": 4,
        "tqr": 4,
        "trackformatting": 3,
        "trackmoves": 3,
        "transmf": 4,
        "trauth": 3,
        "trautofit": 2,
        "trbgbdiag": 4,
        "trbgcross": 4,
        "trbgdcross": 4,
        "trbgdkbdiag": 4,
        "trbgdkcross": 4,
        "trbgdkdcross": 4,
        "trbgdkfdiag": 4,
        "trbgdkhor": 4,
        "trbgdkvert": 4,
        "trbgfdiag": 4,
        "trbghoriz": 4,
        "trbgvert": 4,
        "trbrdrb": 4,
        "trbrdrh": 4,
        "trbrdrl": 4,
        "trbrdrr": 4,
        "trbrdrt": 4,
        "trbrdrv": 4,
        "trcbpat": 3,
        "trcfpat": 3,
        "trdate": 3,
        "trftsWidthA": 3,
        "trftsWidthB": 3,
        "trftsWidth": 3,
        "trgaph": 3,
        "trhdr": 4,
        "trkeep": 4,
        "trkeepfollow": 4,
        "trleft": 3,
        "trowd": 4,
        "trpaddb": 3,
        "trpaddfb": 3,
        "trpaddfl": 3,
        "trpaddfr": 3,
        "trpaddft": 3,
        "trpaddl": 3,
        "trpaddr": 3,
        "trpaddt": 3,
        "trpadob": 3,
        "trpadofb": 3,
        "trpadofl": 3,
        "trpadofr": 3,
        "trpadoft": 3,
        "trpadol": 3,
        "trpador": 3,
        "trpadot": 3,
        "trpat": 3,
        "trqc": 4,
        "trql": 4,
        "trqr": 4,
        "trrh": 3,
        "trshdng": 3,
        "trspdb": 3,
        "trspdfb": 3,
        "trspdfl": 3,
        "trspdfr": 3,
        "trspdft": 3,
        "trspdl": 3,
        "trspdr": 3,
        "trspdt": 3,
        "trspob": 3,
        "trspofb": 3,
        "trspofl": 3,
        "trspofr": 3,
        "trspoft": 3,
        "trspol": 3,
        "trspor": 3,
        "trspot": 3,
        "truncatefontheight": 4,
        "truncex": 4,
        "trwWidthA": 3,
        "trwWidthB": 3,
        "trwWidth": 3,
        "ts": 3,
        "tsbgbdiag": 4,
        "tsbgcross": 4,
        "tsbgdcross": 4,
        "tsbgdkbdiag": 4,
        "tsbgdkcross": 4,
        "tsbgdkdcross": 4,
        "tsbgdkfdiag": 4,
        "tsbgdkhor": 4,
        "tsbgdkvert": 4,
        "tsbgfdiag": 4,
        "tsbghoriz": 4,
        "tsbgvert": 4,
        "tsbrdrb": 4,
        "tsbrdrdgl": 4,
        "tsbrdrdgr": 4,
        "tsbrdrh": 4,
        "tsbrdrl": 4,
        "tsbrdrr": 4,
        "tsbrdrt": 4,
        "tsbrdrv": 4,
        "tscbandhorzeven": 4,
        "tscbandhorzodd": 4,
        "tscbandsh": 3,
        "tscbandsv": 3,
        "tscbandverteven": 4,
        "tscbandvertodd": 4,
        "tscellcbpat": 3,
        "tscellcfpat": 3,
        "tscellpaddb": 3,
        "tscellpaddfb": 3,
        "tscellpaddfl": 3,
        "tscellpaddfr": 3,
        "tscellpaddft": 3,
        "tscellpaddl": 3,
        "tscellpaddr": 3,
        "tscellpaddt": 3,
        "tscellpct": 3,
        "tscellwidth": 3,
        "tscellwidthfts": 3,
        "tscfirstcol": 4,
        "tscfirstrow": 4,
        "tsclastcol": 4,
        "tsclastrow": 4,
        "tscnecell": 4,
        "tscnwcell": 4,
        "tscsecell": 4,
        "tscswcell": 4,
        "tsd": 4,
        "tsnowrap": 4,
        "tsrowd": 4,
        "tsvertalb": 4,
        "tsvertalc": 4,
        "tsvertalt": 4,
        "twoinone": 3,
        "twoonone": 4,
        "tx": 3,
        "txbxtwalways": 4,
        "txbxtwfirst": 4,
        "txbxtwfirstlast": 4,
        "txbxtwlast": 4,
        "txbxtwno": 4,
        "txe": 5,
        "u": 3,
        "uc": 3,
        "ud": 5,
        "ul": 2,
        "ulc": 3,
        "uld": 4,
        "uldash": 2,
        "uldashd": 2,
        "uldashdd": 2,
        "uldb": 2,
        "ulhair": 2,
        "ulhwave": 2,
        "ulldash": 2,
        "ulnone": 4,
        "ulth": 2,
        "ulthd": 2,
        "ulthdash": 2,
        "ulthdashd": 2,
        "ulthdashdd": 2,
        "ulthldash": 2,
        "ululdbwave": 2,
        "ulw": 4,
        "ulwave": 2,
        "up": 3,
        "upr": 5,
        "urtf": 3,
        "useltbaln": 4,
        "usenormstyforlist": 4,
        "userprops": 5,
        "usexform": 4,
        "utinl": 4,
        "v": 2,
        "validatexml": 3,
        "vern": 3,
        "version": 3,
        "vertal": 4,
        "vertalb": 4,
        "vertalc": 4,
        "vertalj": 4,
        "vertalt": 4,
        "vertdoc": 4,
        "vertsect": 4,
        "viewbksp": 3,
        "viewkind": 3,
        "viewnobound": 4,
        "viewscale": 3,
        "viewzk": 3,
        "wbitmap": 3,
        "wbmbitspixel": 3,
        "wbmplanes": 3,
        "wbmwidthbytes": 3,
        "webhidden": 4,
        "wgrffmtfilter": 5,
        "widctlpar": 4,
        "widowctrl": 4,
        "windowcaption": 5,
        "wmetafile": 3,
        "wpeqn": 4,
        "wpjst": 4,
        "wpsp": 4,
        "wraparound": 4,
        "wrapdefault": 4,
        "wrapthrough": 4,
        "wraptight": 4,
        "wraptrsp": 4,
        "writereservation": 5,
        "writereservhash": 5,
        "wrppunct": 4,
        "xe": 5,
        "xef": 3,
        "xform": 5,
        "xmlattr": 4,
        "xmlattrname": 5,
        "xmlattrns": 3,
        "xmlattrvalue": 5,
        "xmlclose": 5,
        "xmlname": 5,
        "xmlns": 3,
        "xmlnstbl": 5,
        "xmlopen": 5,
        "xmlsdttcell": 4,
        "xmlsdttpara": 4,
        "xmlsdttregular": 4,
        "xmlsdttrow": 4,
        "xmlsdttunknown": 4,
        "yr": 3,
        "yts": 3,
        "yxe": 4,
        "zwbo": 1,
        "zwj": 1,
        "zwnbo": 1,
        "zwnj": 1
      };
    }, {}],
    55: [function (require, module, exports) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      /* eslint-disable node/no-deprecated-api */
      var buffer = require('buffer');
      var Buffer = buffer.Buffer;

      // alternative to using Object.keys for old browsers
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        // Copy properties from require('buffer')
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer.prototype);

      // Copy static methods from Buffer
      copyProps(Buffer, SafeBuffer);
      SafeBuffer.from = function (arg, encodingOrOffset, length) {
        if (typeof arg === 'number') {
          throw new TypeError('Argument must not be a number');
        }
        return Buffer(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function (size, fill, encoding) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }
        var buf = Buffer(size);
        if (fill !== undefined) {
          if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }
        return Buffer(size);
      };
      SafeBuffer.allocUnsafeSlow = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }
        return buffer.SlowBuffer(size);
      };
    }, {
      "buffer": 7
    }],
    56: [function (require, module, exports) {
      (function (process) {
        (function () {
          /* eslint-disable node/no-deprecated-api */

          'use strict';

          var buffer = require('buffer');
          var Buffer = buffer.Buffer;
          var safer = {};
          var key;
          for (key in buffer) {
            if (!buffer.hasOwnProperty(key)) continue;
            if (key === 'SlowBuffer' || key === 'Buffer') continue;
            safer[key] = buffer[key];
          }
          var Safer = safer.Buffer = {};
          for (key in Buffer) {
            if (!Buffer.hasOwnProperty(key)) continue;
            if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
            Safer[key] = Buffer[key];
          }
          safer.Buffer.prototype = Buffer.prototype;
          if (!Safer.from || Safer.from === Uint8Array.from) {
            Safer.from = function (value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('The "value" argument must not be of type number. Received type ' + _typeof(value));
              }
              if (value && typeof value.length === 'undefined') {
                throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + _typeof(value));
              }
              return Buffer(value, encodingOrOffset, length);
            };
          }
          if (!Safer.alloc) {
            Safer.alloc = function (size, fill, encoding) {
              if (typeof size !== 'number') {
                throw new TypeError('The "size" argument must be of type number. Received type ' + _typeof(size));
              }
              if (size < 0 || size >= 2 * (1 << 30)) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
              var buf = Buffer(size);
              if (!fill || fill.length === 0) {
                buf.fill(0);
              } else if (typeof encoding === 'string') {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
              return buf;
            };
          }
          if (!safer.kStringMaxLength) {
            try {
              safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
            } catch (e) {
              // we can't determine kStringMaxLength in environments where process.binding
              // is unsupported, so let's not set it
            }
          }
          if (!safer.constants) {
            safer.constants = {
              MAX_LENGTH: safer.kMaxLength
            };
            if (safer.kStringMaxLength) {
              safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
            }
          }
          module.exports = safer;
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "_process": 36,
      "buffer": 7
    }],
    57: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      module.exports = Stream;
      var EE = require('events').EventEmitter;
      var inherits = require('inherits');
      inherits(Stream, EE);
      Stream.Readable = require('readable-stream/lib/_stream_readable.js');
      Stream.Writable = require('readable-stream/lib/_stream_writable.js');
      Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
      Stream.Transform = require('readable-stream/lib/_stream_transform.js');
      Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
      Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
      Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js');

      // Backwards-compat with node 0.4.x
      Stream.Stream = Stream;

      // old-style streams.  Note that the pipe method (the only relevant
      // part of this class) is overridden in the Readable class.

      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function (dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on('data', ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on('drain', ondrain);

        // If the 'end' option is not supplied, dest.end() will be called when
        // source gets the 'end' or 'close' events.  Only dest.end() once.
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on('end', onend);
          source.on('close', onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === 'function') dest.destroy();
        }

        // don't leave dangling pipes when there are errors.
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, 'error') === 0) {
            throw er; // Unhandled stream error in pipe.
          }
        }

        source.on('error', onerror);
        dest.on('error', onerror);

        // remove all the event listeners that were added.
        function cleanup() {
          source.removeListener('data', ondata);
          dest.removeListener('drain', ondrain);
          source.removeListener('end', onend);
          source.removeListener('close', onclose);
          source.removeListener('error', onerror);
          dest.removeListener('error', onerror);
          source.removeListener('end', cleanup);
          source.removeListener('close', cleanup);
          dest.removeListener('close', cleanup);
        }
        source.on('end', cleanup);
        source.on('close', cleanup);
        dest.on('close', cleanup);
        dest.emit('pipe', source);

        // Allow for unix-like usage: A.pipe(B).pipe(C)
        return dest;
      };
    }, {
      "events": 11,
      "inherits": 33,
      "readable-stream/lib/_stream_duplex.js": 59,
      "readable-stream/lib/_stream_passthrough.js": 60,
      "readable-stream/lib/_stream_readable.js": 61,
      "readable-stream/lib/_stream_transform.js": 62,
      "readable-stream/lib/_stream_writable.js": 63,
      "readable-stream/lib/internal/streams/end-of-stream.js": 67,
      "readable-stream/lib/internal/streams/pipeline.js": 69
    }],
    58: [function (require, module, exports) {
      'use strict';

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === 'string') {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(NodeError, _Base);
          function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function (i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

      function endsWith(str, search, this_len) {
        if (this_len === undefined || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

      function includes(str, search, start) {
        if (typeof start !== 'number') {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
        // determiner: 'must be' or 'must not be'
        var determiner;
        if (typeof expected === 'string' && startsWith(expected, 'not ')) {
          determiner = 'must not be';
          expected = expected.replace(/^not /, '');
        } else {
          determiner = 'must be';
        }
        var msg;
        if (endsWith(name, ' argument')) {
          // For cases like 'first argument'
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
        } else {
          var type = includes(name, '.') ? 'property' : 'argument';
          msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
        }
        msg += ". Received type ".concat(_typeof(actual));
        return msg;
      }, TypeError);
      createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
      createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
        return 'The ' + name + ' method is not implemented';
      });
      createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
      createErrorType('ERR_STREAM_DESTROYED', function (name) {
        return 'Cannot call ' + name + ' after a stream was destroyed';
      });
      createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
      createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
      createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
      createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
      createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
        return 'Unknown encoding: ' + arg;
      }, TypeError);
      createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
      module.exports.codes = codes;
    }, {}],
    59: [function (require, module, exports) {
      (function (process) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // a duplex stream is just a stream that is both readable and writable.
          // Since JS doesn't have multiple prototypal inheritance, this class
          // prototypally inherits from Readable, and then parasitically from
          // Writable.
          'use strict';

          /*<replacement>*/
          var objectKeys = Object.keys || function (obj) {
            var keys = [];
            for (var key in obj) {
              keys.push(key);
            }
            return keys;
          };
          /*</replacement>*/

          module.exports = Duplex;
          var Readable = require('./_stream_readable');
          var Writable = require('./_stream_writable');
          require('inherits')(Duplex, Readable);
          {
            // Allow the keys array to be GC'ed.
            var keys = objectKeys(Writable.prototype);
            for (var v = 0; v < keys.length; v++) {
              var method = keys[v];
              if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
            }
          }
          function Duplex(options) {
            if (!(this instanceof Duplex)) return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            this.allowHalfOpen = true;
            if (options) {
              if (options.readable === false) this.readable = false;
              if (options.writable === false) this.writable = false;
              if (options.allowHalfOpen === false) {
                this.allowHalfOpen = false;
                this.once('end', onend);
              }
            }
          }
          Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          Object.defineProperty(Duplex.prototype, 'writableBuffer', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          Object.defineProperty(Duplex.prototype, 'writableLength', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          }); // the no-half-open enforcer

          function onend() {
            // If the writable side ended, then we're ok.
            if (this._writableState.ended) return; // no more data can be written.
            // But allow more writes to happen in this tick.

            process.nextTick(onEndNT, this);
          }
          function onEndNT(self) {
            self.end();
          }
          Object.defineProperty(Duplex.prototype, 'destroyed', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === undefined || this._writableState === undefined) {
                return false;
              }
              return this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (this._readableState === undefined || this._writableState === undefined) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed

              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          });
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "./_stream_readable": 61,
      "./_stream_writable": 63,
      "_process": 36,
      "inherits": 33
    }],
    60: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      // a passthrough stream.
      // basically just the most minimal sort of Transform stream.
      // Every written chunk gets output as-is.
      'use strict';

      module.exports = PassThrough;
      var Transform = require('./_stream_transform');
      require('inherits')(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function (chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, {
      "./_stream_transform": 62,
      "inherits": 33
    }],
    61: [function (require, module, exports) {
      (function (process, global) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          'use strict';

          module.exports = Readable;
          /*<replacement>*/

          var Duplex;
          /*</replacement>*/

          Readable.ReadableState = ReadableState;
          /*<replacement>*/

          var EE = require('events').EventEmitter;
          var EElistenerCount = function EElistenerCount(emitter, type) {
            return emitter.listeners(type).length;
          };
          /*</replacement>*/

          /*<replacement>*/

          var Stream = require('./internal/streams/stream');
          /*</replacement>*/

          var Buffer = require('buffer').Buffer;
          var OurUint8Array = global.Uint8Array || function () {};
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          /*<replacement>*/

          var debugUtil = require('util');
          var debug;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog('stream');
          } else {
            debug = function debug() {};
          }
          /*</replacement>*/

          var BufferList = require('./internal/streams/buffer_list');
          var destroyImpl = require('./internal/streams/destroy');
          var _require = require('./internal/streams/state'),
            getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require('../errors').codes,
            ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
            ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
            ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
            ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.

          var StringDecoder;
          var createReadableStreamAsyncIterator;
          var from;
          require('inherits')(Readable, Stream);
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.

            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream, isDuplex) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {}; // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.

            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away

            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"

            this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()

            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.

            this.sync = true; // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.

            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.paused = true; // Should close be emitted on destroy. Defaults to true.

            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

            this.autoDestroy = !!options.autoDestroy; // has it been destroyed

            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.

            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require('./_stream_duplex');
            if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
            // the ReadableState constructor, at least with V8 6.5

            var isDuplex = this instanceof Duplex;
            this._readableState = new ReadableState(options, this, isDuplex); // legacy

            this.readable = true;
            if (options) {
              if (typeof options.read === 'function') this._read = options.read;
              if (typeof options.destroy === 'function') this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, 'destroyed', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === undefined) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed

              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function (err, cb) {
            cb(err);
          }; // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.

          Readable.prototype.push = function (chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = '';
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          }; // Unshift should *always* be something directly out of read()

          Readable.prototype.unshift = function (chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            debug('readableAddChunk', chunk);
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck) er = chunkInvalid(state, chunk);
              if (er) {
                errorOrDestroy(stream, er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                } else if (state.destroyed) {
                  return false;
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
                maybeReadMore(stream, state);
              }
            } // We can push more data if we are below the highWaterMark.
            // Also, if we have no data yet, we can stand some more bytes.
            // This is to work around cases where hwm=0, such as the repl.

            return !state.ended && (state.length < state.highWaterMark || state.length === 0);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              state.awaitDrain = 0;
              stream.emit('data', chunk);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
              if (state.needReadable) emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
            }
            return er;
          }
          Readable.prototype.isPaused = function () {
            return this._readableState.flowing === false;
          }; // backwards compatibility.

          Readable.prototype.setEncoding = function (enc) {
            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
            var decoder = new StringDecoder(enc);
            this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

            this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

            var p = this._readableState.buffer.head;
            var content = '';
            while (p !== null) {
              content += decoder.write(p.data);
              p = p.next;
            }
            this._readableState.buffer.clear();
            if (content !== '') this._readableState.buffer.push(content);
            this._readableState.length = content.length;
            return this;
          }; // Don't raise the hwm > 1GB

          var MAX_HWM = 0x40000000;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
              n = MAX_HWM;
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          } // This function is designed to be inlinable, so please take care when making
          // changes to the function body.

          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended) return 0;
            if (state.objectMode) return 1;
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
            } // If we're asking for more than the current hwm, then raise the hwm.

            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length) return n; // Don't have enough

            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          } // you can override either this method, or the async _read(n) below.

          Readable.prototype.read = function (n) {
            debug('read', n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.

            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
              debug('read: emitReadable', state.length, state.ended);
              if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this);
              return null;
            } // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.
            // if we need a readable event, then we need to do some reading.

            var doRead = state.needReadable;
            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug('length less than watermark', doRead);
            } // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.

            if (state.ended || state.reading) {
              doRead = false;
              debug('reading or ended', doRead);
            } else if (doRead) {
              debug('do read');
              state.reading = true;
              state.sync = true; // if the length is currently zero, then we *need* a readable event.

              if (state.length === 0) state.needReadable = true; // call internal read method

              this._read(state.highWaterMark);
              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.

              if (!state.reading) n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0) ret = fromList(n, state);else ret = null;
            if (ret === null) {
              state.needReadable = state.length <= state.highWaterMark;
              n = 0;
            } else {
              state.length -= n;
              state.awaitDrain = 0;
            }
            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

              if (nOrig !== n && state.ended) endReadable(this);
            }
            if (ret !== null) this.emit('data', ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            debug('onEofChunk');
            if (state.ended) return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            if (state.sync) {
              // if we are sync, wait until next tick to emit the data.
              // Otherwise we risk emitting data in the flow()
              // the readable code triggers during a read() call
              emitReadable(stream);
            } else {
              // emit 'readable' now to make sure it gets picked up.
              state.needReadable = false;
              if (!state.emittedReadable) {
                state.emittedReadable = true;
                emitReadable_(stream);
              }
            }
          } // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.

          function emitReadable(stream) {
            var state = stream._readableState;
            debug('emitReadable', state.needReadable, state.emittedReadable);
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug('emitReadable', state.flowing);
              state.emittedReadable = true;
              process.nextTick(emitReadable_, stream);
            }
          }
          function emitReadable_(stream) {
            var state = stream._readableState;
            debug('emitReadable_', state.destroyed, state.length, state.ended);
            if (!state.destroyed && (state.length || state.ended)) {
              stream.emit('readable');
              state.emittedReadable = false;
            } // The stream needs another readable event if
            // 1. It is not flowing, as the flow mechanism will take
            //    care of it.
            // 2. It is not ended.
            // 3. It is below the highWaterMark, so we can schedule
            //    another readable later.

            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
            flow(stream);
          } // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.

          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              process.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            // Attempt to read more data if we should.
            //
            // The conditions for reading more data are (one of):
            // - Not enough data buffered (state.length < state.highWaterMark). The loop
            //   is responsible for filling the buffer with enough data if such data
            //   is available. If highWaterMark is 0 and we are not in the flowing mode
            //   we should _not_ attempt to buffer any extra data. We'll get more data
            //   when the stream consumer calls read() instead.
            // - No data in the buffer, and the stream is in flowing mode. In this mode
            //   the loop below is responsible for ensuring read() is called. Failing to
            //   call read here would abort the flow and there's no other mechanism for
            //   continuing the flow if the stream consumer has just subscribed to the
            //   'data' event.
            //
            // In addition to the above conditions to keep reading data, the following
            // conditions prevent the data from being read:
            // - The stream has ended (state.ended).
            // - There is already a pending 'read' operation (state.reading). This is a
            //   case where the the stream has called the implementation defined _read()
            //   method, but they are processing the call asynchronously and have _not_
            //   called push() with new data. In this case we skip performing more
            //   read()s. The execution ends in this method again after the _read() ends
            //   up calling push() with more data.
            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
              var len = state.length;
              debug('maybeReadMore read 0');
              stream.read(0);
              if (len === state.length)
                // didn't get any data, stop spinning.
                break;
            }
            state.readingMore = false;
          } // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.

          Readable.prototype._read = function (n) {
            errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
          };
          Readable.prototype.pipe = function (dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
            dest.on('unpipe', onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug('onunpipe');
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug('onend');
              dest.end();
            } // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.

            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug('cleanup'); // cleanup event handlers once the pipe is broken

              dest.removeListener('close', onclose);
              dest.removeListener('finish', onfinish);
              dest.removeListener('drain', ondrain);
              dest.removeListener('error', onerror);
              dest.removeListener('unpipe', onunpipe);
              src.removeListener('end', onend);
              src.removeListener('end', unpipe);
              src.removeListener('data', ondata);
              cleanedUp = true; // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.

              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
            }
            src.on('data', ondata);
            function ondata(chunk) {
              debug('ondata');
              var ret = dest.write(chunk);
              debug('dest.write', ret);
              if (ret === false) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug('false write response, pause', state.awaitDrain);
                  state.awaitDrain++;
                }
                src.pause();
              }
            } // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.

            function onerror(er) {
              debug('onerror', er);
              unpipe();
              dest.removeListener('error', onerror);
              if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
            } // Make sure our error handler is attached before userland ones.

            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

            function onclose() {
              dest.removeListener('finish', onfinish);
              unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
              debug('onfinish');
              dest.removeListener('close', onclose);
              unpipe();
            }
            dest.once('finish', onfinish);
            function unpipe() {
              debug('unpipe');
              src.unpipe(dest);
            } // tell the dest that it's being piped to

            dest.emit('pipe', src); // start the flow if it hasn't been started already.

            if (!state.flowing) {
              debug('pipe resume');
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function pipeOnDrainFunctionResult() {
              var state = src._readableState;
              debug('pipeOnDrain', state.awaitDrain);
              if (state.awaitDrain) state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function (dest) {
            var state = this._readableState;
            var unpipeInfo = {
              hasUnpiped: false
            }; // if we're not piping anywhere, then do nothing.

            if (state.pipesCount === 0) return this; // just one destination.  most common case.

            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this;
              if (!dest) dest = state.pipes; // got a match.

              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest) dest.emit('unpipe', this, unpipeInfo);
              return this;
            } // slow case. multiple pipe destinations.

            if (!dest) {
              // remove all.
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit('unpipe', this, {
                  hasUnpiped: false
                });
              }
              return this;
            } // try to find the right one.

            var index = indexOf(state.pipes, dest);
            if (index === -1) return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1) state.pipes = state.pipes[0];
            dest.emit('unpipe', this, unpipeInfo);
            return this;
          }; // set up data events if they are asked for
          // Ensure readable listeners eventually get something

          Readable.prototype.on = function (ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            var state = this._readableState;
            if (ev === 'data') {
              // update readableListening so that resume() may be a no-op
              // a few lines down. This is needed to support once('readable').
              state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

              if (state.flowing !== false) this.resume();
            } else if (ev === 'readable') {
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.flowing = false;
                state.emittedReadable = false;
                debug('on readable', state.length, state.reading);
                if (state.length) {
                  emitReadable(this);
                } else if (!state.reading) {
                  process.nextTick(nReadingNextTick, this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          Readable.prototype.removeListener = function (ev, fn) {
            var res = Stream.prototype.removeListener.call(this, ev, fn);
            if (ev === 'readable') {
              // We need to check if there is someone still listening to
              // readable and reset the state. However this needs to happen
              // after readable has been emitted but before I/O (nextTick) to
              // support once('readable', fn) cycles. This means that calling
              // resume within the same tick will have no
              // effect.
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          Readable.prototype.removeAllListeners = function (ev) {
            var res = Stream.prototype.removeAllListeners.apply(this, arguments);
            if (ev === 'readable' || ev === undefined) {
              // We need to check if there is someone still listening to
              // readable and reset the state. However this needs to happen
              // after readable has been emitted but before I/O (nextTick) to
              // support once('readable', fn) cycles. This means that calling
              // resume within the same tick will have no
              // effect.
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          function updateReadableListening(self) {
            var state = self._readableState;
            state.readableListening = self.listenerCount('readable') > 0;
            if (state.resumeScheduled && !state.paused) {
              // flowing needs to be set to true now, otherwise
              // the upcoming resume will not flow.
              state.flowing = true; // crude way to check if we should resume
            } else if (self.listenerCount('data') > 0) {
              self.resume();
            }
          }
          function nReadingNextTick(self) {
            debug('readable nexttick read 0');
            self.read(0);
          } // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.

          Readable.prototype.resume = function () {
            var state = this._readableState;
            if (!state.flowing) {
              debug('resume'); // we flow only if there is no one listening
              // for readable, but we still have to call
              // resume()

              state.flowing = !state.readableListening;
              resume(this, state);
            }
            state.paused = false;
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              process.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            debug('resume', state.reading);
            if (!state.reading) {
              stream.read(0);
            }
            state.resumeScheduled = false;
            stream.emit('resume');
            flow(stream);
            if (state.flowing && !state.reading) stream.read(0);
          }
          Readable.prototype.pause = function () {
            debug('call pause flowing=%j', this._readableState.flowing);
            if (this._readableState.flowing !== false) {
              debug('pause');
              this._readableState.flowing = false;
              this.emit('pause');
            }
            this._readableState.paused = true;
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug('flow', state.flowing);
            while (state.flowing && stream.read() !== null) {
              ;
            }
          } // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.

          Readable.prototype.wrap = function (stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on('end', function () {
              debug('wrapped end');
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on('data', function (chunk) {
              debug('wrapped data');
              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

              if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            }); // proxy all the other methods.
            // important when wrapping filters and duplexes.

            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === 'function') {
                this[i] = function methodWrap(method) {
                  return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            } // proxy certain important events.

            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            } // when we try to consume some more bytes, simply unpause the
            // underlying stream.

            this._read = function (n) {
              debug('wrapped _read', n);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          if (typeof Symbol === 'function') {
            Readable.prototype[Symbol.asyncIterator] = function () {
              if (createReadableStreamAsyncIterator === undefined) {
                createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
              }
              return createReadableStreamAsyncIterator(this);
            };
          }
          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          });
          Object.defineProperty(Readable.prototype, 'readableBuffer', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState && this._readableState.buffer;
            }
          });
          Object.defineProperty(Readable.prototype, 'readableFlowing', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.flowing;
            },
            set: function set(state) {
              if (this._readableState) {
                this._readableState.flowing = state;
              }
            }
          }); // exposed for testing purposes only.

          Readable._fromList = fromList;
          Object.defineProperty(Readable.prototype, 'readableLength', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.length;
            }
          }); // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.

          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null;
            var ret;
            if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              // read part of list
              ret = state.buffer.consume(n, state.decoder);
            }
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            debug('endReadable', state.endEmitted);
            if (!state.endEmitted) {
              state.ended = true;
              process.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit('end');
              if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the writable side is ready for autoDestroy as well
                var wState = stream._writableState;
                if (!wState || wState.autoDestroy && wState.finished) {
                  stream.destroy();
                }
              }
            }
          }
          if (typeof Symbol === 'function') {
            Readable.from = function (iterable, opts) {
              if (from === undefined) {
                from = require('./internal/streams/from');
              }
              return from(Readable, iterable, opts);
            };
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i;
            }
            return -1;
          }
        }).call(this);
      }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "../errors": 58,
      "./_stream_duplex": 59,
      "./internal/streams/async_iterator": 64,
      "./internal/streams/buffer_list": 65,
      "./internal/streams/destroy": 66,
      "./internal/streams/from": 68,
      "./internal/streams/state": 70,
      "./internal/streams/stream": 71,
      "_process": 36,
      "buffer": 7,
      "events": 11,
      "inherits": 33,
      "string_decoder/": 72,
      "util": 5
    }],
    62: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      // a transform stream is a readable/writable stream where you do
      // something with the data.  Sometimes it's called a "filter",
      // but that's not a great name for it, since that implies a thing where
      // some bits pass through, and others are simply ignored.  (That would
      // be a valid example of a transform, of course.)
      //
      // While the output is causally related to the input, it's not a
      // necessarily symmetric or synchronous transformation.  For example,
      // a zlib stream might take multiple plain-text writes(), and then
      // emit a single compressed chunk some time in the future.
      //
      // Here's how this works:
      //
      // The Transform stream has all the aspects of the readable and writable
      // stream classes.  When you write(chunk), that calls _write(chunk,cb)
      // internally, and returns false if there's a lot of pending writes
      // buffered up.  When you call read(), that calls _read(n) until
      // there's enough pending readable data buffered up.
      //
      // In a transform stream, the written data is placed in a buffer.  When
      // _read(n) is called, it transforms the queued up data, calling the
      // buffered _write cb's as it consumes chunks.  If consuming a single
      // written chunk would result in multiple output chunks, then the first
      // outputted bit calls the readcb, and subsequent chunks just go into
      // the read buffer, and will cause it to emit 'readable' if necessary.
      //
      // This way, back-pressure is actually determined by the reading side,
      // since _read has to be called to start processing a new chunk.  However,
      // a pathological inflate type of transform can cause excessive buffering
      // here.  For example, imagine a stream where every byte of input is
      // interpreted as an integer from 0-255, and then results in that many
      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
      // 1kb of data being output.  In this case, you could write a very small
      // amount of input, and end up with a very large amount of output.  In
      // such a pathological inflating mechanism, there'd be no way to tell
      // the system to stop doing the transform.  A single 4MB write could
      // cause the system to run out of memory.
      //
      // However, even in such a pathological case, only a single written chunk
      // would be consumed, and then the rest would wait (un-transformed) until
      // the results of the previous transformed chunk were consumed.
      'use strict';

      module.exports = Transform;
      var _require$codes = require('../errors').codes,
        ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
        ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
        ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require('./_stream_duplex');
      require('inherits')(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit('error', new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          // single equals check for both `null` and `undefined`
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }; // start out asking for a readable event once data is transformed.

        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.

        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === 'function') this._transform = options.transform;
          if (typeof options.flush === 'function') this._flush = options.flush;
        } // When the writable side finishes, then flush out anything remaining.

        this.on('prefinish', prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === 'function' && !this._readableState.destroyed) {
          this._flush(function (er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function (chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      }; // This is the part where you do stuff!
      // override this function in implementation classes.
      // 'chunk' is an input chunk.
      //
      // Call `push(newChunk)` to pass along transformed output
      // to the readable side.  You may call 'push' zero or more times.
      //
      // Call `cb(err)` when you are done with this chunk.  If you pass
      // an error, then that'll put the hurt on the whole operation.  If you
      // never call cb(), then you'll never get another chunk.

      Transform.prototype._transform = function (chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
      };
      Transform.prototype._write = function (chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      }; // Doesn't matter what the args are here.
      // _transform does all the work.
      // That we got here means that the readable side wants more data.

      Transform.prototype._read = function (n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          // mark that we need a transform, so that any data that comes in
          // will get processed, now that we've asked for it.
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function (err, cb) {
        Duplex.prototype._destroy.call(this, err, function (err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er) return stream.emit('error', er);
        if (data != null)
          // single equals check for both `null` and `undefined`
          stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
        // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided

        if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }, {
      "../errors": 58,
      "./_stream_duplex": 59,
      "inherits": 33
    }],
    63: [function (require, module, exports) {
      (function (process, global) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.
          'use strict';

          module.exports = Writable;
          /* <replacement> */

          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          } // It seems a linked list but it is not
          // there will be only 2 of these for each stream

          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function () {
              onCorkedFinish(_this, state);
            };
          }
          /* </replacement> */

          /*<replacement>*/

          var Duplex;
          /*</replacement>*/

          Writable.WritableState = WritableState;
          /*<replacement>*/

          var internalUtil = {
            deprecate: require('util-deprecate')
          };
          /*</replacement>*/

          /*<replacement>*/

          var Stream = require('./internal/streams/stream');
          /*</replacement>*/

          var Buffer = require('buffer').Buffer;
          var OurUint8Array = global.Uint8Array || function () {};
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require('./internal/streams/destroy');
          var _require = require('./internal/streams/state'),
            getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require('../errors').codes,
            ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
            ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
            ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
            ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
            ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
            ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
            ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
            ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          require('inherits')(Writable, Stream);
          function nop() {}
          function WritableState(options, stream, isDuplex) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {}; // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream,
            // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
            // contains buffers or objects.

            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()

            this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

            this.finalCalled = false; // drain event flag.

            this.needDrain = false; // at the start of calling end()

            this.ending = false; // when end() has been called, and returned

            this.ended = false; // when 'finish' is emitted

            this.finished = false; // has it been destroyed

            this.destroyed = false; // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.

            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.

            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.

            this.length = 0; // a flag to see when we're in the middle of a write.

            this.writing = false; // when true all writes will be buffered until .uncork() call

            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.

            this.sync = true; // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.

            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

            this.onwrite = function (er) {
              onwrite(stream, er);
            }; // the callback that the user supplies to write(chunk,encoding,cb)

            this.writecb = null; // the amount that is being written when _write is called.

            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted

            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams

            this.prefinished = false; // True if the error was already emitted and should not be thrown again

            this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

            this.autoDestroy = !!options.autoDestroy; // count buffered requests

            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two

            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function () {
            try {
              Object.defineProperty(WritableState.prototype, 'buffer', {
                get: internalUtil.deprecate(function writableStateBufferGetter() {
                  return this.getBuffer();
                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
              });
            } catch (_) {}
          })(); // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.

          var realHasInstance;
          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function value(object) {
                if (realHasInstance.call(this, object)) return true;
                if (this !== Writable) return false;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function realHasInstance(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.
            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            // Checking for a Stream.Duplex instance is faster here instead of inside
            // the WritableState constructor, at least with V8 6.5

            var isDuplex = this instanceof Duplex;
            if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
            this._writableState = new WritableState(options, this, isDuplex); // legacy.

            this.writable = true;
            if (options) {
              if (typeof options.write === 'function') this._write = options.write;
              if (typeof options.writev === 'function') this._writev = options.writev;
              if (typeof options.destroy === 'function') this._destroy = options.destroy;
              if (typeof options.final === 'function') this._final = options.final;
            }
            Stream.call(this);
          } // Otherwise people can pipe Writable streams, which is just wrong.

          Writable.prototype.pipe = function () {
            errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
          };
          function writeAfterEnd(stream, cb) {
            var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

            errorOrDestroy(stream, er);
            process.nextTick(cb, er);
          } // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.

          function validChunk(stream, state, chunk, cb) {
            var er;
            if (chunk === null) {
              er = new ERR_STREAM_NULL_VALUES();
            } else if (typeof chunk !== 'string' && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
            }
            if (er) {
              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
              return false;
            }
            return true;
          }
          Writable.prototype.write = function (chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
            if (typeof cb !== 'function') cb = nop;
            if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function () {
            this._writableState.corked++;
          };
          Writable.prototype.uncork = function () {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === 'string') encoding = encoding.toLowerCase();
            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          Object.defineProperty(Writable.prototype, 'writableBuffer', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          }); // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.

          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = 'buffer';
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

            if (!ret) state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              process.nextTick(cb, er); // this can emit finish, and it will always happen
              // after error

              process.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er);
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er); // this can emit finish, but finish must
              // always follow error

              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
            onwriteStateUpdate(state);
            if (er) onwriteError(stream, state, sync, er, cb);else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state) || stream.destroyed;
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                process.nextTick(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          } // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.

          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          } // if there's something in the buffer waiting, then process it

          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf) allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite

              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.

                if (state.writing) {
                  break;
                }
              }
              if (entry === null) state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function (chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function (chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

            if (state.corked) {
              state.corked = 1;
              this.uncork();
            } // ignore unnecessary end() calls.

            if (!state.ending) endWritable(this, state, cb);
            return this;
          };
          Object.defineProperty(Writable.prototype, 'writableLength', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function (err) {
              state.pendingcb--;
              if (err) {
                errorOrDestroy(stream, err);
              }
              state.prefinished = true;
              stream.emit('prefinish');
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === 'function' && !state.destroyed) {
                state.pendingcb++;
                state.finalCalled = true;
                process.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit('prefinish');
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit('finish');
                if (state.autoDestroy) {
                  // In case of duplex streams we need a way to detect
                  // if the readable side is ready for autoDestroy as well
                  var rState = stream._readableState;
                  if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                  }
                }
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            } // reuse the free corkReq.

            state.corkedRequestsFree.next = corkReq;
          }
          Object.defineProperty(Writable.prototype, 'destroyed', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._writableState === undefined) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed

              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function (err, cb) {
            cb(err);
          };
        }).call(this);
      }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "../errors": 58,
      "./_stream_duplex": 59,
      "./internal/streams/destroy": 66,
      "./internal/streams/state": 70,
      "./internal/streams/stream": 71,
      "_process": 36,
      "buffer": 7,
      "inherits": 33,
      "util-deprecate": 73
    }],
    64: [function (require, module, exports) {
      (function (process) {
        (function () {
          'use strict';

          var _Object$setPrototypeO;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var finished = require('./end-of-stream');
          var kLastResolve = Symbol('lastResolve');
          var kLastReject = Symbol('lastReject');
          var kError = Symbol('error');
          var kEnded = Symbol('ended');
          var kLastPromise = Symbol('lastPromise');
          var kHandlePromise = Symbol('handlePromise');
          var kStream = Symbol('stream');
          function createIterResult(value, done) {
            return {
              value: value,
              done: done
            };
          }
          function readAndResolve(iter) {
            var resolve = iter[kLastResolve];
            if (resolve !== null) {
              var data = iter[kStream].read(); // we defer if data is null
              // we can be expecting either 'end' or
              // 'error'

              if (data !== null) {
                iter[kLastPromise] = null;
                iter[kLastResolve] = null;
                iter[kLastReject] = null;
                resolve(createIterResult(data, false));
              }
            }
          }
          function onReadable(iter) {
            // we wait for the next tick, because it might
            // emit an error with process.nextTick
            process.nextTick(readAndResolve, iter);
          }
          function wrapForNext(lastPromise, iter) {
            return function (resolve, reject) {
              lastPromise.then(function () {
                if (iter[kEnded]) {
                  resolve(createIterResult(undefined, true));
                  return;
                }
                iter[kHandlePromise](resolve, reject);
              }, reject);
            };
          }
          var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
            get stream() {
              return this[kStream];
            },
            next: function next() {
              var _this = this;

              // if we have detected an error in the meanwhile
              // reject straight away
              var error = this[kError];
              if (error !== null) {
                return Promise.reject(error);
              }
              if (this[kEnded]) {
                return Promise.resolve(createIterResult(undefined, true));
              }
              if (this[kStream].destroyed) {
                // We need to defer via nextTick because if .destroy(err) is
                // called, the error will be emitted via nextTick, and
                // we cannot guarantee that there is no error lingering around
                // waiting to be emitted.
                return new Promise(function (resolve, reject) {
                  process.nextTick(function () {
                    if (_this[kError]) {
                      reject(_this[kError]);
                    } else {
                      resolve(createIterResult(undefined, true));
                    }
                  });
                });
              } // if we have multiple next() calls
              // we will wait for the previous Promise to finish
              // this logic is optimized to support for await loops,
              // where next() is only called once at a time

              var lastPromise = this[kLastPromise];
              var promise;
              if (lastPromise) {
                promise = new Promise(wrapForNext(lastPromise, this));
              } else {
                // fast path needed to support multiple this.push()
                // without triggering the next() queue
                var data = this[kStream].read();
                if (data !== null) {
                  return Promise.resolve(createIterResult(data, false));
                }
                promise = new Promise(this[kHandlePromise]);
              }
              this[kLastPromise] = promise;
              return promise;
            }
          }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
            return this;
          }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
            var _this2 = this;

            // destroy(err, cb) is a private API
            // we can guarantee we have that here, because we control the
            // Readable class this is attached to
            return new Promise(function (resolve, reject) {
              _this2[kStream].destroy(null, function (err) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve(createIterResult(undefined, true));
              });
            });
          }), _Object$setPrototypeO), AsyncIteratorPrototype);
          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
            var _Object$create;
            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
              value: stream,
              writable: true
            }), _defineProperty(_Object$create, kLastResolve, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kLastReject, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kError, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kEnded, {
              value: stream._readableState.endEmitted,
              writable: true
            }), _defineProperty(_Object$create, kHandlePromise, {
              value: function value(resolve, reject) {
                var data = iterator[kStream].read();
                if (data) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(data, false));
                } else {
                  iterator[kLastResolve] = resolve;
                  iterator[kLastReject] = reject;
                }
              },
              writable: true
            }), _Object$create));
            iterator[kLastPromise] = null;
            finished(stream, function (err) {
              if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
                var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
                // returned by next() and store the error

                if (reject !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  reject(err);
                }
                iterator[kError] = err;
                return;
              }
              var resolve = iterator[kLastResolve];
              if (resolve !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(undefined, true));
              }
              iterator[kEnded] = true;
            });
            stream.on('readable', onReadable.bind(null, iterator));
            return iterator;
          };
          module.exports = createReadableStreamAsyncIterator;
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "./end-of-stream": 67,
      "_process": 36
    }],
    65: [function (require, module, exports) {
      'use strict';

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require('buffer'),
        Buffer = _require.Buffer;
      var _require2 = require('util'),
        inspect = _require2.inspect;
      var custom = inspect && inspect.custom || 'inspect';
      function copyBuffer(src, target, offset) {
        Buffer.prototype.copy.call(src, target, offset);
      }
      module.exports = /*#__PURE__*/
      function () {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0) this.tail.next = entry;else this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0) return '';
            var p = this.head;
            var ret = '' + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0) return Buffer.alloc(0);
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          } // Consumes a specified amount of bytes or characters from the buffered data.
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              // `slice` is the same for buffers and strings.
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              // First chunk is a perfect match.
              ret = this.shift();
            } else {
              // Result spans more than one buffer.
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          } // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next;else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          } // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next;else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          } // Make sure the linked list only shows the minimal necessary information.
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }, {
      "buffer": 7,
      "util": 5
    }],
    66: [function (require, module, exports) {
      (function (process) {
        (function () {
          'use strict';

          // undocumented cb() API, needed for core, not for public API
          function destroy(err, cb) {
            var _this = this;
            var readableDestroyed = this._readableState && this._readableState.destroyed;
            var writableDestroyed = this._writableState && this._writableState.destroyed;
            if (readableDestroyed || writableDestroyed) {
              if (cb) {
                cb(err);
              } else if (err) {
                if (!this._writableState) {
                  process.nextTick(emitErrorNT, this, err);
                } else if (!this._writableState.errorEmitted) {
                  this._writableState.errorEmitted = true;
                  process.nextTick(emitErrorNT, this, err);
                }
              }
              return this;
            } // we set destroyed to true before firing error callbacks in order
            // to make it re-entrance safe in case destroy() is called within callbacks

            if (this._readableState) {
              this._readableState.destroyed = true;
            } // if this is a duplex stream mark the writable part as destroyed as well

            if (this._writableState) {
              this._writableState.destroyed = true;
            }
            this._destroy(err || null, function (err) {
              if (!cb && err) {
                if (!_this._writableState) {
                  process.nextTick(emitErrorAndCloseNT, _this, err);
                } else if (!_this._writableState.errorEmitted) {
                  _this._writableState.errorEmitted = true;
                  process.nextTick(emitErrorAndCloseNT, _this, err);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              } else if (cb) {
                process.nextTick(emitCloseNT, _this);
                cb(err);
              } else {
                process.nextTick(emitCloseNT, _this);
              }
            });
            return this;
          }
          function emitErrorAndCloseNT(self, err) {
            emitErrorNT(self, err);
            emitCloseNT(self);
          }
          function emitCloseNT(self) {
            if (self._writableState && !self._writableState.emitClose) return;
            if (self._readableState && !self._readableState.emitClose) return;
            self.emit('close');
          }
          function undestroy() {
            if (this._readableState) {
              this._readableState.destroyed = false;
              this._readableState.reading = false;
              this._readableState.ended = false;
              this._readableState.endEmitted = false;
            }
            if (this._writableState) {
              this._writableState.destroyed = false;
              this._writableState.ended = false;
              this._writableState.ending = false;
              this._writableState.finalCalled = false;
              this._writableState.prefinished = false;
              this._writableState.finished = false;
              this._writableState.errorEmitted = false;
            }
          }
          function emitErrorNT(self, err) {
            self.emit('error', err);
          }
          function errorOrDestroy(stream, err) {
            // We have tests that rely on errors being emitted
            // in the same tick, so changing this is semver major.
            // For now when you opt-in to autoDestroy we allow
            // the error to be emitted nextTick. In a future
            // semver major update we should change the default to this.
            var rState = stream._readableState;
            var wState = stream._writableState;
            if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
          }
          module.exports = {
            destroy: destroy,
            undestroy: undestroy,
            errorOrDestroy: errorOrDestroy
          };
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "_process": 36
    }],
    67: [function (require, module, exports) {
      // Ported from https://github.com/mafintosh/end-of-stream with
      // permission from the author, Mathias Buus (@mafintosh).
      'use strict';

      var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function () {
          if (called) return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {}
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === 'function';
      }
      function eos(stream, opts, callback) {
        if (typeof opts === 'function') return eos(stream, null, opts);
        if (!opts) opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish() {
          if (!stream.writable) onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish() {
          writable = false;
          writableEnded = true;
          if (!readable) callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend() {
          readable = false;
          readableEnded = true;
          if (!writable) callback.call(stream);
        };
        var onerror = function onerror(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest() {
          stream.req.on('finish', onfinish);
        };
        if (isRequest(stream)) {
          stream.on('complete', onfinish);
          stream.on('abort', onclose);
          if (stream.req) onrequest();else stream.on('request', onrequest);
        } else if (writable && !stream._writableState) {
          // legacy streams
          stream.on('end', onlegacyfinish);
          stream.on('close', onlegacyfinish);
        }
        stream.on('end', onend);
        stream.on('finish', onfinish);
        if (opts.error !== false) stream.on('error', onerror);
        stream.on('close', onclose);
        return function () {
          stream.removeListener('complete', onfinish);
          stream.removeListener('abort', onclose);
          stream.removeListener('request', onrequest);
          if (stream.req) stream.req.removeListener('finish', onfinish);
          stream.removeListener('end', onlegacyfinish);
          stream.removeListener('close', onlegacyfinish);
          stream.removeListener('finish', onfinish);
          stream.removeListener('end', onend);
          stream.removeListener('error', onerror);
          stream.removeListener('close', onclose);
        };
      }
      module.exports = eos;
    }, {
      "../../../errors": 58
    }],
    68: [function (require, module, exports) {
      module.exports = function () {
        throw new Error('Readable.from is not available in the browser');
      };
    }, {}],
    69: [function (require, module, exports) {
      // Ported from https://github.com/mafintosh/pump with
      // permission from the author, Mathias Buus (@mafintosh).
      'use strict';

      var eos;
      function once(callback) {
        var called = false;
        return function () {
          if (called) return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require('../../../errors').codes,
        ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        // Rethrow the error if it exists to avoid swallowing it
        if (err) throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === 'function';
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on('close', function () {
          closed = true;
        });
        if (eos === undefined) eos = require('./end-of-stream');
        eos(stream, {
          readable: reading,
          writable: writing
        }, function (err) {
          if (err) return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function (err) {
          if (closed) return;
          if (destroyed) return;
          destroyed = true; // request.destroy just do .end - .abort is what we want

          if (isRequest(stream)) return stream.abort();
          if (typeof stream.destroy === 'function') return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED('pipe'));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length) return noop;
        if (typeof streams[streams.length - 1] !== 'function') return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0])) streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS('streams');
        }
        var error;
        var destroys = streams.map(function (stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function (err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }, {
      "../../../errors": 58,
      "./end-of-stream": 67
    }],
    70: [function (require, module, exports) {
      'use strict';

      var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : 'highWaterMark';
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        } // Default value

        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark: getHighWaterMark
      };
    }, {
      "../../../errors": 58
    }],
    71: [function (require, module, exports) {
      module.exports = require('events').EventEmitter;
    }, {
      "events": 11
    }],
    72: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      /*<replacement>*/
      var Buffer = require('safe-buffer').Buffer;
      /*</replacement>*/

      var isEncoding = Buffer.isEncoding || function (encoding) {
        encoding = '' + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc) return 'utf8';
        var retried;
        while (true) {
          switch (enc) {
            case 'utf8':
            case 'utf-8':
              return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 'utf16le';
            case 'latin1':
            case 'binary':
              return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
              return enc;
            default:
              if (retried) return; // undefined
              enc = ('' + enc).toLowerCase();
              retried = true;
          }
        }
      }
      ;

      // Do not cache `Buffer.isEncoding` when checking encoding names as some
      // modules monkey-patch it to support additional encodings
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
        return nenc || enc;
      }

      // StringDecoder provides an interface for efficiently splitting a series of
      // buffers into a series of JS strings without breaking apart multi-byte
      // characters.
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function (buf) {
        if (buf.length === 0) return '';
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === undefined) return '';
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || '';
      };
      StringDecoder.prototype.end = utf8End;

      // Returns only complete characters in a Buffer
      StringDecoder.prototype.text = utf8Text;

      // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
      StringDecoder.prototype.fillLast = function (buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };

      // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
      // continuation byte. If an invalid byte is detected, -2 is returned.
      function utf8CheckByte(byte) {
        if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
        return byte >> 6 === 0x02 ? -1 : -2;
      }

      // Checks at most 3 bytes at the end of a Buffer in order to detect an
      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
      // needed to complete the UTF-8 character (if applicable) are returned.
      function utf8CheckIncomplete(self, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }

      // Validates as many continuation bytes for a multi-byte UTF-8 character as
      // needed or are available. If we see a non-continuation byte where we expect
      // one, we "replace" the validated continuation bytes we've seen so far with
      // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
      // behavior. The continuation byte check is included three times in the case
      // where all of the continuation bytes for a character exist in the same buffer.
      // It is also done this way as a slight performance increase instead of using a
      // loop.
      function utf8CheckExtraBytes(self, buf, p) {
        if ((buf[0] & 0xC0) !== 0x80) {
          self.lastNeed = 0;
          return "\uFFFD";
        }
        if (self.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "\uFFFD";
          }
          if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
              self.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }

      // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== undefined) return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }

      // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
      // partial character, the character's bytes are buffered until the required
      // number of bytes are available.
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString('utf8', i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString('utf8', i, end);
      }

      // For UTF-8, a replacement character is added when ending on a partial
      // character.
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + "\uFFFD";
        return r;
      }

      // UTF-16LE typically needs two bytes per character, but even if we have an even
      // number of bytes available, we need to check if we end on a leading/high
      // surrogate. In that case, we need to wait for the next two bytes in order to
      // decode the last character properly.
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString('utf16le', i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString('utf16le', i, buf.length - 1);
      }

      // For UTF-16LE we do not explicitly append special replacement characters if we
      // end on a partial character, we simply let v8 handle that.
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString('utf16le', 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString('base64', i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString('base64', i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
        return r;
      }

      // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : '';
      }
    }, {
      "safe-buffer": 55
    }],
    73: [function (require, module, exports) {
      (function (global) {
        (function () {
          /**
           * Module exports.
           */

          module.exports = deprecate;

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config('noDeprecation')) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config('throwDeprecation')) {
                  throw new Error(msg);
                } else if (config('traceDeprecation')) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === 'true';
          }
        }).call(this);
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}]
  }, {}, [1])(1);
});
