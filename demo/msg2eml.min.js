function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _defineProperty2(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.msg2eml = f();
  }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }
          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }
        return n[i].exports;
      }
      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
        o(t[i]);
      }
      return o;
    }
    return r;
  }()({
    1: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          var __extends = void 0 && (void 0).__extends || function () {
            var _extendStatics = function extendStatics(d, b) {
              _extendStatics = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (d, b) {
                d.__proto__ = b;
              } || function (d, b) {
                for (var p in b) {
                  if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                }
              };
              return _extendStatics(d, b);
            };
            return function (d, b) {
              if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              _extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function (resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          };
          var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
            var _ = {
                label: 0,
                sent: function sent() {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                },
                trys: [],
                ops: []
              },
              f,
              y,
              t,
              g;
            return g = {
              next: verb(0),
              "throw": verb(1),
              "return": verb(2)
            }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
              return this;
            }), g;
            function verb(n) {
              return function (v) {
                return step([n, v]);
              };
            }
            function step(op) {
              if (f) throw new TypeError("Generator is already executing.");
              while (g && (g = 0, op[0] && (_ = 0)), _) {
                try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                  if (y = 0, t) op = [op[0] & 2, t.value];
                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op;
                      break;
                    case 4:
                      _.label++;
                      return {
                        value: op[1],
                        done: false
                      };
                    case 5:
                      _.label++;
                      y = op[1];
                      op = [0];
                      continue;
                    case 7:
                      op = _.ops.pop();
                      _.trys.pop();
                      continue;
                    default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                      }
                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                      }
                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                      }
                      if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                      }
                      if (t[2]) _.ops.pop();
                      _.trys.pop();
                      continue;
                  }
                  op = body.call(thisArg, _);
                } catch (e) {
                  op = [6, e];
                  y = 0;
                } finally {
                  f = t = 0;
                }
              }
              if (op[0] & 5) throw op[1];
              return {
                value: op[0] ? op[1] : void 0,
                done: true
              };
            }
          };
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.msg2eml = void 0;
          var iconvLite = require("iconv-lite");
          var rtf_stream_parser_1 = require("rtf-stream-parser");
          var CFB = require('cfb');
          var eml_format = require('eml-format');
          var moment = require('moment');
          var decompressRTF = require('@kenjiuno/decompressrtf').decompressRTF;
          var bigInt = require("big-integer");
          var property_tags = new Array(0x3F08 + 1);
          property_tags[0x01] = ['ACKNOWLEDGEMENT_MODE', 'I4'];
          property_tags[0x02] = ['ALTERNATE_RECIPIENT_ALLOWED', 'BOOLEAN'];
          property_tags[0x03] = ['AUTHORIZING_USERS', 'BINARY'];
          // Comment on an automatically forwarded message
          property_tags[0x04] = ['AUTO_FORWARD_COMMENT', 'STRING'];
          // Whether a message has been automatically forwarded
          property_tags[0x05] = ['AUTO_FORWARDED', 'BOOLEAN'];
          property_tags[0x06] = ['CONTENT_CONFIDENTIALITY_ALGORITHM_ID', 'BINARY'];
          property_tags[0x07] = ['CONTENT_CORRELATOR', 'BINARY'];
          property_tags[0x08] = ['CONTENT_IDENTIFIER', 'STRING'];
          // MIME content length
          property_tags[0x09] = ['CONTENT_LENGTH', 'I4'];
          property_tags[0x0A] = ['CONTENT_RETURN_REQUESTED', 'BOOLEAN'];
          property_tags[0x0B] = ['CONVERSATION_KEY', 'BINARY'];
          property_tags[0x0C] = ['CONVERSION_EITS', 'BINARY'];
          property_tags[0x0D] = ['CONVERSION_WITH_LOSS_PROHIBITED', 'BOOLEAN'];
          property_tags[0x0E] = ['CONVERTED_EITS', 'BINARY'];
          // Time to deliver for delayed delivery messages
          property_tags[0x0F] = ['DEFERRED_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x10] = ['DELIVER_TIME', 'SYSTIME'];
          // Reason a message was discarded
          property_tags[0x11] = ['DISCARD_REASON', 'I4'];
          property_tags[0x12] = ['DISCLOSURE_OF_RECIPIENTS', 'BOOLEAN'];
          property_tags[0x13] = ['DL_EXPANSION_HISTORY', 'BINARY'];
          property_tags[0x14] = ['DL_EXPANSION_PROHIBITED', 'BOOLEAN'];
          property_tags[0x15] = ['EXPIRY_TIME', 'SYSTIME'];
          property_tags[0x16] = ['IMPLICIT_CONVERSION_PROHIBITED', 'BOOLEAN'];
          // Message importance
          property_tags[0x17] = ['IMPORTANCE', 'I4'];
          property_tags[0x18] = ['IPM_ID', 'BINARY'];
          property_tags[0x19] = ['LATEST_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x1A] = ['MESSAGE_CLASS', 'STRING'];
          property_tags[0x1B] = ['MESSAGE_DELIVERY_ID', 'BINARY'];
          property_tags[0x1E] = ['MESSAGE_SECURITY_LABEL', 'BINARY'];
          property_tags[0x1F] = ['OBSOLETED_IPMS', 'BINARY'];
          // Person a message was originally for
          property_tags[0x20] = ['ORIGINALLY_INTENDED_RECIPIENT_NAME', 'BINARY'];
          property_tags[0x21] = ['ORIGINAL_EITS', 'BINARY'];
          property_tags[0x22] = ['ORIGINATOR_CERTIFICATE', 'BINARY'];
          property_tags[0x23] = ['ORIGINATOR_DELIVERY_REPORT_REQUESTED', 'BOOLEAN'];
          // Address of the message sender
          property_tags[0x24] = ['ORIGINATOR_RETURN_ADDRESS', 'BINARY'];
          property_tags[0x25] = ['PARENT_KEY', 'BINARY'];
          property_tags[0x26] = ['PRIORITY', 'I4'];
          property_tags[0x27] = ['ORIGIN_CHECK', 'BINARY'];
          property_tags[0x28] = ['PROOF_OF_SUBMISSION_REQUESTED', 'BOOLEAN'];
          // Whether a read receipt is desired
          property_tags[0x29] = ['READ_RECEIPT_REQUESTED', 'BOOLEAN'];
          // Time a message was received
          property_tags[0x2A] = ['RECEIPT_TIME', 'SYSTIME'];
          property_tags[0x2B] = ['RECIPIENT_REASSIGNMENT_PROHIBITED', 'BOOLEAN'];
          property_tags[0x2C] = ['REDIRECTION_HISTORY', 'BINARY'];
          property_tags[0x2D] = ['RELATED_IPMS', 'BINARY'];
          // Sensitivity of the original message
          property_tags[0x2E] = ['ORIGINAL_SENSITIVITY', 'I4'];
          property_tags[0x2F] = ['LANGUAGES', 'STRING'];
          property_tags[0x30] = ['REPLY_TIME', 'SYSTIME'];
          property_tags[0x31] = ['REPORT_TAG', 'BINARY'];
          property_tags[0x32] = ['REPORT_TIME', 'SYSTIME'];
          property_tags[0x33] = ['RETURNED_IPM', 'BOOLEAN'];
          property_tags[0x34] = ['SECURITY', 'I4'];
          property_tags[0x35] = ['INCOMPLETE_COPY', 'BOOLEAN'];
          property_tags[0x36] = ['SENSITIVITY', 'I4'];
          // The message subject
          property_tags[0x37] = ['SUBJECT', 'STRING'];
          property_tags[0x38] = ['SUBJECT_IPM', 'BINARY'];
          property_tags[0x39] = ['CLIENT_SUBMIT_TIME', 'SYSTIME'];
          property_tags[0x3A] = ['REPORT_NAME', 'STRING'];
          property_tags[0x3B] = ['SENT_REPRESENTING_SEARCH_KEY', 'BINARY'];
          property_tags[0x3C] = ['X400_CONTENT_TYPE', 'BINARY'];
          property_tags[0x3D] = ['SUBJECT_PREFIX', 'STRING'];
          property_tags[0x3E] = ['NON_RECEIPT_REASON', 'I4'];
          property_tags[0x3F] = ['RECEIVED_BY_ENTRYID', 'BINARY'];
          // Received by: entry
          property_tags[0x40] = ['RECEIVED_BY_NAME', 'STRING'];
          property_tags[0x41] = ['SENT_REPRESENTING_ENTRYID', 'BINARY'];
          property_tags[0x42] = ['SENT_REPRESENTING_NAME', 'STRING'];
          property_tags[0x43] = ['RCVD_REPRESENTING_ENTRYID', 'BINARY'];
          property_tags[0x44] = ['RCVD_REPRESENTING_NAME', 'STRING'];
          property_tags[0x45] = ['REPORT_ENTRYID', 'BINARY'];
          property_tags[0x46] = ['READ_RECEIPT_ENTRYID', 'BINARY'];
          property_tags[0x47] = ['MESSAGE_SUBMISSION_ID', 'BINARY'];
          property_tags[0x48] = ['PROVIDER_SUBMIT_TIME', 'SYSTIME'];
          // Subject of the original message
          property_tags[0x49] = ['ORIGINAL_SUBJECT', 'STRING'];
          property_tags[0x4A] = ['DISC_VAL', 'BOOLEAN'];
          property_tags[0x4B] = ['ORIG_MESSAGE_CLASS', 'STRING'];
          property_tags[0x4C] = ['ORIGINAL_AUTHOR_ENTRYID', 'BINARY'];
          // Author of the original message
          property_tags[0x4D] = ['ORIGINAL_AUTHOR_NAME', 'STRING'];
          // Time the original message was submitted
          property_tags[0x4E] = ['ORIGINAL_SUBMIT_TIME', 'SYSTIME'];
          property_tags[0x4F] = ['REPLY_RECIPIENT_ENTRIES', 'BINARY'];
          property_tags[0x50] = ['REPLY_RECIPIENT_NAMES', 'STRING'];
          property_tags[0x51] = ['RECEIVED_BY_SEARCH_KEY', 'BINARY'];
          property_tags[0x52] = ['RCVD_REPRESENTING_SEARCH_KEY', 'BINARY'];
          property_tags[0x53] = ['READ_RECEIPT_SEARCH_KEY', 'BINARY'];
          property_tags[0x54] = ['REPORT_SEARCH_KEY', 'BINARY'];
          property_tags[0x55] = ['ORIGINAL_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x56] = ['ORIGINAL_AUTHOR_SEARCH_KEY', 'BINARY'];
          property_tags[0x57] = ['MESSAGE_TO_ME', 'BOOLEAN'];
          property_tags[0x58] = ['MESSAGE_CC_ME', 'BOOLEAN'];
          property_tags[0x59] = ['MESSAGE_RECIP_ME', 'BOOLEAN'];
          // Sender of the original message
          property_tags[0x5A] = ['ORIGINAL_SENDER_NAME', 'STRING'];
          property_tags[0x5B] = ['ORIGINAL_SENDER_ENTRYID', 'BINARY'];
          property_tags[0x5C] = ['ORIGINAL_SENDER_SEARCH_KEY', 'BINARY'];
          property_tags[0x5D] = ['ORIGINAL_SENT_REPRESENTING_NAME', 'STRING'];
          property_tags[0x5E] = ['ORIGINAL_SENT_REPRESENTING_ENTRYID', 'BINARY'];
          property_tags[0x5F] = ['ORIGINAL_SENT_REPRESENTING_SEARCH_KEY', 'BINARY'];
          property_tags[0x60] = ['START_DATE', 'SYSTIME'];
          property_tags[0x61] = ['END_DATE', 'SYSTIME'];
          property_tags[0x62] = ['OWNER_APPT_ID', 'I4'];
          // Whether a response to the message is desired
          property_tags[0x63] = ['RESPONSE_REQUESTED', 'BOOLEAN'];
          property_tags[0x64] = ['SENT_REPRESENTING_ADDRTYPE', 'STRING'];
          property_tags[0x65] = ['SENT_REPRESENTING_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x66] = ['ORIGINAL_SENDER_ADDRTYPE', 'STRING'];
          // Email of the original message sender
          property_tags[0x67] = ['ORIGINAL_SENDER_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x68] = ['ORIGINAL_SENT_REPRESENTING_ADDRTYPE', 'STRING'];
          property_tags[0x69] = ['ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x70] = ['CONVERSATION_TOPIC', 'STRING'];
          property_tags[0x71] = ['CONVERSATION_INDEX', 'BINARY'];
          property_tags[0x72] = ['ORIGINAL_DISPLAY_BCC', 'STRING'];
          property_tags[0x73] = ['ORIGINAL_DISPLAY_CC', 'STRING'];
          property_tags[0x74] = ['ORIGINAL_DISPLAY_TO', 'STRING'];
          property_tags[0x75] = ['RECEIVED_BY_ADDRTYPE', 'STRING'];
          property_tags[0x76] = ['RECEIVED_BY_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x77] = ['RCVD_REPRESENTING_ADDRTYPE', 'STRING'];
          property_tags[0x78] = ['RCVD_REPRESENTING_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x79] = ['ORIGINAL_AUTHOR_ADDRTYPE', 'STRING'];
          property_tags[0x7A] = ['ORIGINAL_AUTHOR_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x7B] = ['ORIGINALLY_INTENDED_RECIP_ADDRTYPE', 'STRING'];
          property_tags[0x7C] = ['ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x7D] = ['TRANSPORT_MESSAGE_HEADERS', 'STRING'];
          property_tags[0x7E] = ['DELEGATION', 'BINARY'];
          property_tags[0x7F] = ['TNEF_CORRELATION_KEY', 'BINARY'];
          property_tags[0x1000] = ['BODY', 'STRING'];
          property_tags[0x1001] = ['REPORT_TEXT', 'STRING'];
          property_tags[0x1002] = ['ORIGINATOR_AND_DL_EXPANSION_HISTORY', 'BINARY'];
          property_tags[0x1003] = ['REPORTING_DL_NAME', 'BINARY'];
          property_tags[0x1004] = ['REPORTING_MTA_CERTIFICATE', 'BINARY'];
          property_tags[0x1006] = ['RTF_SYNC_BODY_CRC', 'I4'];
          property_tags[0x1007] = ['RTF_SYNC_BODY_COUNT', 'I4'];
          property_tags[0x1008] = ['RTF_SYNC_BODY_TAG', 'STRING'];
          property_tags[0x1009] = ['RTF_COMPRESSED', 'BINARY'];
          property_tags[0x1010] = ['RTF_SYNC_PREFIX_COUNT', 'I4'];
          property_tags[0x1011] = ['RTF_SYNC_TRAILING_COUNT', 'I4'];
          property_tags[0x1012] = ['ORIGINALLY_INTENDED_RECIP_ENTRYID', 'BINARY'];
          property_tags[0x0C00] = ['CONTENT_INTEGRITY_CHECK', 'BINARY'];
          property_tags[0x0C01] = ['EXPLICIT_CONVERSION', 'I4'];
          property_tags[0x0C02] = ['IPM_RETURN_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C03] = ['MESSAGE_TOKEN', 'BINARY'];
          property_tags[0x0C04] = ['NDR_REASON_CODE', 'I4'];
          property_tags[0x0C05] = ['NDR_DIAG_CODE', 'I4'];
          property_tags[0x0C06] = ['NON_RECEIPT_NOTIFICATION_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C07] = ['DELIVERY_POINT', 'I4'];
          property_tags[0x0C08] = ['ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C09] = ['ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT', 'BINARY'];
          property_tags[0x0C0A] = ['PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY', 'BOOLEAN'];
          property_tags[0x0C0B] = ['PHYSICAL_DELIVERY_MODE', 'I4'];
          property_tags[0x0C0C] = ['PHYSICAL_DELIVERY_REPORT_REQUEST', 'I4'];
          property_tags[0x0C0D] = ['PHYSICAL_FORWARDING_ADDRESS', 'BINARY'];
          property_tags[0x0C0E] = ['PHYSICAL_FORWARDING_ADDRESS_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C0F] = ['PHYSICAL_FORWARDING_PROHIBITED', 'BOOLEAN'];
          property_tags[0x0C10] = ['PHYSICAL_RENDITION_ATTRIBUTES', 'BINARY'];
          property_tags[0x0C11] = ['PROOF_OF_DELIVERY', 'BINARY'];
          property_tags[0x0C12] = ['PROOF_OF_DELIVERY_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C13] = ['RECIPIENT_CERTIFICATE', 'BINARY'];
          property_tags[0x0C14] = ['RECIPIENT_NUMBER_FOR_ADVICE', 'STRING'];
          property_tags[0x0C15] = ['RECIPIENT_TYPE', 'I4'];
          property_tags[0x0C16] = ['REGISTERED_MAIL_TYPE', 'I4'];
          property_tags[0x0C17] = ['REPLY_REQUESTED', 'BOOLEAN'];
          property_tags[0x0C18] = ['REQUESTED_DELIVERY_METHOD', 'I4'];
          property_tags[0x0C19] = ['SENDER_ENTRYID', 'BINARY'];
          property_tags[0x0C1A] = ['SENDER_NAME', 'STRING'];
          property_tags[0x0C1B] = ['SUPPLEMENTARY_INFO', 'STRING'];
          property_tags[0x0C1C] = ['TYPE_OF_MTS_USER', 'I4'];
          property_tags[0x0C1D] = ['SENDER_SEARCH_KEY', 'BINARY'];
          property_tags[0x0C1E] = ['SENDER_ADDRTYPE', 'STRING'];
          property_tags[0x0C1F] = ['SENDER_EMAIL_ADDRESS', 'STRING'];
          property_tags[0x0E00] = ['CURRENT_VERSION', 'I8'];
          property_tags[0x0E01] = ['DELETE_AFTER_SUBMIT', 'BOOLEAN'];
          property_tags[0x0E02] = ['DISPLAY_BCC', 'STRING'];
          property_tags[0x0E03] = ['DISPLAY_CC', 'STRING'];
          property_tags[0x0E04] = ['DISPLAY_TO', 'STRING'];
          property_tags[0x0E05] = ['PARENT_DISPLAY', 'STRING'];
          property_tags[0x0E06] = ['MESSAGE_DELIVERY_TIME', 'SYSTIME'];
          property_tags[0x0E07] = ['MESSAGE_FLAGS', 'I4'];
          property_tags[0x0E08] = ['MESSAGE_SIZE', 'I4'];
          property_tags[0x0E09] = ['PARENT_ENTRYID', 'BINARY'];
          property_tags[0x0E0A] = ['SENTMAIL_ENTRYID', 'BINARY'];
          property_tags[0x0E0C] = ['CORRELATE', 'BOOLEAN'];
          property_tags[0x0E0D] = ['CORRELATE_MTSID', 'BINARY'];
          property_tags[0x0E0E] = ['DISCRETE_VALUES', 'BOOLEAN'];
          property_tags[0x0E0F] = ['RESPONSIBILITY', 'BOOLEAN'];
          property_tags[0x0E10] = ['SPOOLER_STATUS', 'I4'];
          property_tags[0x0E11] = ['TRANSPORT_STATUS', 'I4'];
          property_tags[0x0E12] = ['MESSAGE_RECIPIENTS', 'OBJECT'];
          property_tags[0x0E13] = ['MESSAGE_ATTACHMENTS', 'OBJECT'];
          property_tags[0x0E14] = ['SUBMIT_FLAGS', 'I4'];
          property_tags[0x0E15] = ['RECIPIENT_STATUS', 'I4'];
          property_tags[0x0E16] = ['TRANSPORT_KEY', 'I4'];
          property_tags[0x0E17] = ['MSG_STATUS', 'I4'];
          property_tags[0x0E18] = ['MESSAGE_DOWNLOAD_TIME', 'I4'];
          property_tags[0x0E19] = ['CREATION_VERSION', 'I8'];
          property_tags[0x0E1A] = ['MODIFY_VERSION', 'I8'];
          property_tags[0x0E1B] = ['HASATTACH', 'BOOLEAN'];
          property_tags[0x0E1D] = ['NORMALIZED_SUBJECT', 'STRING'];
          property_tags[0x0E1F] = ['RTF_IN_SYNC', 'BOOLEAN'];
          property_tags[0x0E20] = ['ATTACH_SIZE', 'I4'];
          property_tags[0x0E21] = ['ATTACH_NUM', 'I4'];
          property_tags[0x0E22] = ['PREPROCESS', 'BOOLEAN'];
          property_tags[0x0E25] = ['ORIGINATING_MTA_CERTIFICATE', 'BINARY'];
          property_tags[0x0E26] = ['PROOF_OF_SUBMISSION', 'BINARY'];
          // A unique identifier for editing the properties of a MAPI object
          property_tags[0x0FFF] = ['ENTRYID', 'BINARY'];
          // The type of an object
          property_tags[0x0FFE] = ['OBJECT_TYPE', 'I4'];
          property_tags[0x0FFD] = ['ICON', 'BINARY'];
          property_tags[0x0FFC] = ['MINI_ICON', 'BINARY'];
          property_tags[0x0FFB] = ['STORE_ENTRYID', 'BINARY'];
          property_tags[0x0FFA] = ['STORE_RECORD_KEY', 'BINARY'];
          // Binary identifer for an individual object
          property_tags[0x0FF9] = ['RECORD_KEY', 'BINARY'];
          property_tags[0x0FF8] = ['MAPPING_SIGNATURE', 'BINARY'];
          property_tags[0x0FF7] = ['ACCESS_LEVEL', 'I4'];
          // The primary key of a column in a table
          property_tags[0x0FF6] = ['INSTANCE_KEY', 'BINARY'];
          property_tags[0x0FF5] = ['ROW_TYPE', 'I4'];
          property_tags[0x0FF4] = ['ACCESS', 'I4'];
          property_tags[0x3000] = ['ROWID', 'I4'];
          // The name to display for a given MAPI object
          property_tags[0x3001] = ['DISPLAY_NAME', 'STRING'];
          property_tags[0x3002] = ['ADDRTYPE', 'STRING'];
          // An email address
          property_tags[0x3003] = ['EMAIL_ADDRESS', 'STRING'];
          // A comment field
          property_tags[0x3004] = ['COMMENT', 'STRING'];
          property_tags[0x3005] = ['DEPTH', 'I4'];
          // Provider-defined display name for a service provider
          property_tags[0x3006] = ['PROVIDER_DISPLAY', 'STRING'];
          // The time an object was created
          property_tags[0x3007] = ['CREATION_TIME', 'SYSTIME'];
          // The time an object was last modified
          property_tags[0x3008] = ['LAST_MODIFICATION_TIME', 'SYSTIME'];
          // Flags describing a service provider, message service, or status object
          property_tags[0x3009] = ['RESOURCE_FLAGS', 'I4'];
          // The name of a provider dll, minus any "32" suffix and ".dll"
          property_tags[0x300A] = ['PROVIDER_DLL_NAME', 'STRING'];
          property_tags[0x300B] = ['SEARCH_KEY', 'BINARY'];
          property_tags[0x300C] = ['PROVIDER_UID', 'BINARY'];
          property_tags[0x300D] = ['PROVIDER_ORDINAL', 'I4'];
          property_tags[0x3301] = ['FORM_VERSION', 'STRING'];
          property_tags[0x3302] = ['FORM_CLSID', 'CLSID'];
          property_tags[0x3303] = ['FORM_CONTACT_NAME', 'STRING'];
          property_tags[0x3304] = ['FORM_CATEGORY', 'STRING'];
          property_tags[0x3305] = ['FORM_CATEGORY_SUB', 'STRING'];
          property_tags[0x3306] = ['FORM_HOST_MAP', 'MV_LONG'];
          property_tags[0x3307] = ['FORM_HIDDEN', 'BOOLEAN'];
          property_tags[0x3308] = ['FORM_DESIGNER_NAME', 'STRING'];
          property_tags[0x3309] = ['FORM_DESIGNER_GUID', 'CLSID'];
          property_tags[0x330A] = ['FORM_MESSAGE_BEHAVIOR', 'I4'];
          // Is this row the default message store?
          property_tags[0x3400] = ['DEFAULT_STORE', 'BOOLEAN'];
          property_tags[0x340D] = ['STORE_SUPPORT_MASK', 'I4'];
          property_tags[0x340E] = ['STORE_STATE', 'I4'];
          property_tags[0x3410] = ['IPM_SUBTREE_SEARCH_KEY', 'BINARY'];
          property_tags[0x3411] = ['IPM_OUTBOX_SEARCH_KEY', 'BINARY'];
          property_tags[0x3412] = ['IPM_WASTEBASKET_SEARCH_KEY', 'BINARY'];
          property_tags[0x3413] = ['IPM_SENTMAIL_SEARCH_KEY', 'BINARY'];
          // Provder-defined message store type
          property_tags[0x3414] = ['MDB_PROVIDER', 'BINARY'];
          property_tags[0x3415] = ['RECEIVE_FOLDER_SETTINGS', 'OBJECT'];
          property_tags[0x35DF] = ['VALID_FOLDER_MASK', 'I4'];
          property_tags[0x35E0] = ['IPM_SUBTREE_ENTRYID', 'BINARY'];
          property_tags[0x35E2] = ['IPM_OUTBOX_ENTRYID', 'BINARY'];
          property_tags[0x35E3] = ['IPM_WASTEBASKET_ENTRYID', 'BINARY'];
          property_tags[0x35E4] = ['IPM_SENTMAIL_ENTRYID', 'BINARY'];
          property_tags[0x35E5] = ['VIEWS_ENTRYID', 'BINARY'];
          property_tags[0x35E6] = ['COMMON_VIEWS_ENTRYID', 'BINARY'];
          property_tags[0x35E7] = ['FINDER_ENTRYID', 'BINARY'];
          property_tags[0x3600] = ['CONTAINER_FLAGS', 'I4'];
          property_tags[0x3601] = ['FOLDER_TYPE', 'I4'];
          property_tags[0x3602] = ['CONTENT_COUNT', 'I4'];
          property_tags[0x3603] = ['CONTENT_UNREAD', 'I4'];
          property_tags[0x3604] = ['CREATE_TEMPLATES', 'OBJECT'];
          property_tags[0x3605] = ['DETAILS_TABLE', 'OBJECT'];
          property_tags[0x3607] = ['SEARCH', 'OBJECT'];
          property_tags[0x3609] = ['SELECTABLE', 'BOOLEAN'];
          property_tags[0x360A] = ['SUBFOLDERS', 'BOOLEAN'];
          property_tags[0x360B] = ['STATUS', 'I4'];
          property_tags[0x360C] = ['ANR', 'STRING'];
          property_tags[0x360D] = ['CONTENTS_SORT_ORDER', 'MV_LONG'];
          property_tags[0x360E] = ['CONTAINER_HIERARCHY', 'OBJECT'];
          property_tags[0x360F] = ['CONTAINER_CONTENTS', 'OBJECT'];
          property_tags[0x3610] = ['FOLDER_ASSOCIATED_CONTENTS', 'OBJECT'];
          property_tags[0x3611] = ['DEF_CREATE_DL', 'BINARY'];
          property_tags[0x3612] = ['DEF_CREATE_MAILUSER', 'BINARY'];
          property_tags[0x3613] = ['CONTAINER_CLASS', 'STRING'];
          property_tags[0x3614] = ['CONTAINER_MODIFY_VERSION', 'I8'];
          property_tags[0x3615] = ['AB_PROVIDER_ID', 'BINARY'];
          property_tags[0x3616] = ['DEFAULT_VIEW_ENTRYID', 'BINARY'];
          property_tags[0x3617] = ['ASSOC_CONTENT_COUNT', 'I4'];
          property_tags[0x3700] = ['ATTACHMENT_X400_PARAMETERS', 'BINARY'];
          property_tags[0x3701] = ['ATTACH_DATA_OBJ', 'OBJECT'];
          property_tags[0x3701] = ['ATTACH_DATA_BIN', 'BINARY'];
          property_tags[0x3702] = ['ATTACH_ENCODING', 'BINARY'];
          property_tags[0x3703] = ['ATTACH_EXTENSION', 'STRING'];
          property_tags[0x3704] = ['ATTACH_FILENAME', 'STRING'];
          property_tags[0x3705] = ['ATTACH_METHOD', 'I4'];
          property_tags[0x3707] = ['ATTACH_LONG_FILENAME', 'STRING'];
          property_tags[0x3708] = ['ATTACH_PATHNAME', 'STRING'];
          property_tags[0x370A] = ['ATTACH_TAG', 'BINARY'];
          property_tags[0x370B] = ['RENDERING_POSITION', 'I4'];
          property_tags[0x370C] = ['ATTACH_TRANSPORT_NAME', 'STRING'];
          property_tags[0x370D] = ['ATTACH_LONG_PATHNAME', 'STRING'];
          property_tags[0x370E] = ['ATTACH_MIME_TAG', 'STRING'];
          property_tags[0x370F] = ['ATTACH_ADDITIONAL_INFO', 'BINARY'];
          property_tags[0x3900] = ['DISPLAY_TYPE', 'I4'];
          property_tags[0x3902] = ['TEMPLATEID', 'BINARY'];
          property_tags[0x3904] = ['PRIMARY_CAPABILITY', 'BINARY'];
          property_tags[0x39FF] = ['7BIT_DISPLAY_NAME', 'STRING'];
          property_tags[0x3A00] = ['ACCOUNT', 'STRING'];
          property_tags[0x3A01] = ['ALTERNATE_RECIPIENT', 'BINARY'];
          property_tags[0x3A02] = ['CALLBACK_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A03] = ['CONVERSION_PROHIBITED', 'BOOLEAN'];
          property_tags[0x3A04] = ['DISCLOSE_RECIPIENTS', 'BOOLEAN'];
          property_tags[0x3A05] = ['GENERATION', 'STRING'];
          property_tags[0x3A06] = ['GIVEN_NAME', 'STRING'];
          property_tags[0x3A07] = ['GOVERNMENT_ID_NUMBER', 'STRING'];
          property_tags[0x3A08] = ['BUSINESS_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A09] = ['HOME_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A0A] = ['INITIALS', 'STRING'];
          property_tags[0x3A0B] = ['KEYWORD', 'STRING'];
          property_tags[0x3A0C] = ['LANGUAGE', 'STRING'];
          property_tags[0x3A0D] = ['LOCATION', 'STRING'];
          property_tags[0x3A0E] = ['MAIL_PERMISSION', 'BOOLEAN'];
          property_tags[0x3A0F] = ['MHS_COMMON_NAME', 'STRING'];
          property_tags[0x3A10] = ['ORGANIZATIONAL_ID_NUMBER', 'STRING'];
          property_tags[0x3A11] = ['SURNAME', 'STRING'];
          property_tags[0x3A12] = ['ORIGINAL_ENTRYID', 'BINARY'];
          property_tags[0x3A13] = ['ORIGINAL_DISPLAY_NAME', 'STRING'];
          property_tags[0x3A14] = ['ORIGINAL_SEARCH_KEY', 'BINARY'];
          property_tags[0x3A15] = ['POSTAL_ADDRESS', 'STRING'];
          property_tags[0x3A16] = ['COMPANY_NAME', 'STRING'];
          property_tags[0x3A17] = ['TITLE', 'STRING'];
          property_tags[0x3A18] = ['DEPARTMENT_NAME', 'STRING'];
          property_tags[0x3A19] = ['OFFICE_LOCATION', 'STRING'];
          property_tags[0x3A1A] = ['PRIMARY_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1B] = ['BUSINESS2_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1C] = ['MOBILE_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1D] = ['RADIO_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1E] = ['CAR_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A1F] = ['OTHER_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A20] = ['TRANSMITABLE_DISPLAY_NAME', 'STRING'];
          property_tags[0x3A21] = ['PAGER_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A22] = ['USER_CERTIFICATE', 'BINARY'];
          property_tags[0x3A23] = ['PRIMARY_FAX_NUMBER', 'STRING'];
          property_tags[0x3A24] = ['BUSINESS_FAX_NUMBER', 'STRING'];
          property_tags[0x3A25] = ['HOME_FAX_NUMBER', 'STRING'];
          property_tags[0x3A26] = ['COUNTRY', 'STRING'];
          property_tags[0x3A27] = ['LOCALITY', 'STRING'];
          property_tags[0x3A28] = ['STATE_OR_PROVINCE', 'STRING'];
          property_tags[0x3A29] = ['STREET_ADDRESS', 'STRING'];
          property_tags[0x3A2A] = ['POSTAL_CODE', 'STRING'];
          property_tags[0x3A2B] = ['POST_OFFICE_BOX', 'STRING'];
          property_tags[0x3A2C] = ['TELEX_NUMBER', 'STRING'];
          property_tags[0x3A2D] = ['ISDN_NUMBER', 'STRING'];
          property_tags[0x3A2E] = ['ASSISTANT_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A2F] = ['HOME2_TELEPHONE_NUMBER', 'STRING'];
          property_tags[0x3A30] = ['ASSISTANT', 'STRING'];
          property_tags[0x3A40] = ['SEND_RICH_INFO', 'BOOLEAN'];
          property_tags[0x3A41] = ['WEDDING_ANNIVERSARY', 'SYSTIME'];
          property_tags[0x3A42] = ['BIRTHDAY', 'SYSTIME'];
          property_tags[0x3A43] = ['HOBBIES', 'STRING'];
          property_tags[0x3A44] = ['MIDDLE_NAME', 'STRING'];
          property_tags[0x3A45] = ['DISPLAY_NAME_PREFIX', 'STRING'];
          property_tags[0x3A46] = ['PROFESSION', 'STRING'];
          property_tags[0x3A47] = ['PREFERRED_BY_NAME', 'STRING'];
          property_tags[0x3A48] = ['SPOUSE_NAME', 'STRING'];
          property_tags[0x3A49] = ['COMPUTER_NETWORK_NAME', 'STRING'];
          property_tags[0x3A4A] = ['CUSTOMER_ID', 'STRING'];
          property_tags[0x3A4B] = ['TTYTDD_PHONE_NUMBER', 'STRING'];
          property_tags[0x3A4C] = ['FTP_SITE', 'STRING'];
          property_tags[0x3A4D] = ['GENDER', 'I2'];
          property_tags[0x3A4E] = ['MANAGER_NAME', 'STRING'];
          property_tags[0x3A4F] = ['NICKNAME', 'STRING'];
          property_tags[0x3A50] = ['PERSONAL_HOME_PAGE', 'STRING'];
          property_tags[0x3A51] = ['BUSINESS_HOME_PAGE', 'STRING'];
          property_tags[0x3A52] = ['CONTACT_VERSION', 'CLSID'];
          property_tags[0x3A53] = ['CONTACT_ENTRYIDS', 'MV_BINARY'];
          property_tags[0x3A54] = ['CONTACT_ADDRTYPES', 'MV_STRING'];
          property_tags[0x3A55] = ['CONTACT_DEFAULT_ADDRESS_INDEX', 'I4'];
          property_tags[0x3A56] = ['CONTACT_EMAIL_ADDRESSES', 'MV_STRING'];
          property_tags[0x3A57] = ['COMPANY_MAIN_PHONE_NUMBER', 'STRING'];
          property_tags[0x3A58] = ['CHILDRENS_NAMES', 'MV_STRING'];
          property_tags[0x3A59] = ['HOME_ADDRESS_CITY', 'STRING'];
          property_tags[0x3A5A] = ['HOME_ADDRESS_COUNTRY', 'STRING'];
          property_tags[0x3A5B] = ['HOME_ADDRESS_POSTAL_CODE', 'STRING'];
          property_tags[0x3A5C] = ['HOME_ADDRESS_STATE_OR_PROVINCE', 'STRING'];
          property_tags[0x3A5D] = ['HOME_ADDRESS_STREET', 'STRING'];
          property_tags[0x3A5E] = ['HOME_ADDRESS_POST_OFFICE_BOX', 'STRING'];
          property_tags[0x3A5F] = ['OTHER_ADDRESS_CITY', 'STRING'];
          property_tags[0x3A60] = ['OTHER_ADDRESS_COUNTRY', 'STRING'];
          property_tags[0x3A61] = ['OTHER_ADDRESS_POSTAL_CODE', 'STRING'];
          property_tags[0x3A62] = ['OTHER_ADDRESS_STATE_OR_PROVINCE', 'STRING'];
          property_tags[0x3A63] = ['OTHER_ADDRESS_STREET', 'STRING'];
          property_tags[0x3A64] = ['OTHER_ADDRESS_POST_OFFICE_BOX', 'STRING'];
          property_tags[0x3D00] = ['STORE_PROVIDERS', 'BINARY'];
          property_tags[0x3D01] = ['AB_PROVIDERS', 'BINARY'];
          property_tags[0x3D02] = ['TRANSPORT_PROVIDERS', 'BINARY'];
          property_tags[0x3D04] = ['DEFAULT_PROFILE', 'BOOLEAN'];
          property_tags[0x3D05] = ['AB_SEARCH_PATH', 'MV_BINARY'];
          property_tags[0x3D06] = ['AB_DEFAULT_DIR', 'BINARY'];
          property_tags[0x3D07] = ['AB_DEFAULT_PAB', 'BINARY'];
          property_tags[0x3D09] = ['SERVICE_NAME', 'STRING'];
          property_tags[0x3D0A] = ['SERVICE_DLL_NAME', 'STRING'];
          property_tags[0x3D0B] = ['SERVICE_ENTRY_NAME', 'STRING'];
          property_tags[0x3D0C] = ['SERVICE_UID', 'BINARY'];
          property_tags[0x3D0D] = ['SERVICE_EXTRA_UIDS', 'BINARY'];
          property_tags[0x3D0E] = ['SERVICES', 'BINARY'];
          property_tags[0x3D0F] = ['SERVICE_SUPPORT_FILES', 'MV_STRING'];
          property_tags[0x3D10] = ['SERVICE_DELETE_FILES', 'MV_STRING'];
          property_tags[0x3D11] = ['AB_SEARCH_PATH_UPDATE', 'BINARY'];
          property_tags[0x3D12] = ['PROFILE_NAME', 'STRING'];
          property_tags[0x3E00] = ['IDENTITY_DISPLAY', 'STRING'];
          property_tags[0x3E01] = ['IDENTITY_ENTRYID', 'BINARY'];
          property_tags[0x3E02] = ['RESOURCE_METHODS', 'I4'];
          // Service provider type
          property_tags[0x3E03] = ['RESOURCE_TYPE', 'I4'];
          property_tags[0x3E04] = ['STATUS_CODE', 'I4'];
          property_tags[0x3E05] = ['IDENTITY_SEARCH_KEY', 'BINARY'];
          property_tags[0x3E06] = ['OWN_STORE_ENTRYID', 'BINARY'];
          property_tags[0x3E07] = ['RESOURCE_PATH', 'STRING'];
          property_tags[0x3E08] = ['STATUS_STRING', 'STRING'];
          property_tags[0x3E09] = ['X400_DEFERRED_DELIVERY_CANCEL', 'BOOLEAN'];
          property_tags[0x3E0A] = ['HEADER_FOLDER_ENTRYID', 'BINARY'];
          property_tags[0x3E0B] = ['REMOTE_PROGRESS', 'I4'];
          property_tags[0x3E0C] = ['REMOTE_PROGRESS_TEXT', 'STRING'];
          property_tags[0x3E0D] = ['REMOTE_VALIDATE_OK', 'BOOLEAN'];
          property_tags[0x3F00] = ['CONTROL_FLAGS', 'I4'];
          property_tags[0x3F01] = ['CONTROL_STRUCTURE', 'BINARY'];
          property_tags[0x3F02] = ['CONTROL_TYPE', 'I4'];
          property_tags[0x3F03] = ['DELTAX', 'I4'];
          property_tags[0x3F04] = ['DELTAY', 'I4'];
          property_tags[0x3F05] = ['XPOS', 'I4'];
          property_tags[0x3F06] = ['YPOS', 'I4'];
          property_tags[0x3F07] = ['CONTROL_ID', 'BINARY'];
          property_tags[0x3F08] = ['INITIAL_DETAILS_PANE', 'I4'];
          var FixedLengthValueLoader = /** @class */function () {
            function FixedLengthValueLoader() {
              this.fixed_length = "";
            }
            return FixedLengthValueLoader;
          }();
          var VariableLengthValueLoader = /** @class */function () {
            function VariableLengthValueLoader() {
              this.variable_length = "";
            }
            return VariableLengthValueLoader;
          }();
          var NULL = /** @class */function (_super) {
            __extends(NULL, _super);
            function NULL() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            NULL.prototype.load = function (value) {
              // value is an eight-byte long bytestring with unused content.
              return null;
            };
            return NULL;
          }(FixedLengthValueLoader);
          var BOOLEAN = /** @class */function (_super) {
            __extends(BOOLEAN, _super);
            function BOOLEAN() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            BOOLEAN.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding a two-byte integer.
              return value[0] == 1;
            };
            return BOOLEAN;
          }(FixedLengthValueLoader);
          var INTEGER16 = /** @class */function (_super) {
            __extends(INTEGER16, _super);
            function INTEGER16() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTEGER16.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding a two-byte integer.
              return value.slice(0, 2).reverse().reduce(function (a, b) {
                return (a << 8) + b;
              });
            };
            return INTEGER16;
          }(FixedLengthValueLoader);
          var INTEGER32 = /** @class */function (_super) {
            __extends(INTEGER32, _super);
            function INTEGER32() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTEGER32.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding a four-byte integer.
              return value.slice(0, 4).reverse().reduce(function (a, b) {
                return (a << 8) + b;
              });
            };
            return INTEGER32;
          }(FixedLengthValueLoader);
          var INTEGER64 = /** @class */function (_super) {
            __extends(INTEGER64, _super);
            function INTEGER64() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTEGER64.prototype.load = function (value) {
              // value is an eight-byte long bytestring holding an eight-byte integer.
              return value.slice().reverse().reduce(function (a, b) {
                return bigInt(a).shiftLeft(8).add(bigInt(b));
              });
            };
            return INTEGER64;
          }(FixedLengthValueLoader);
          var INTTIME = /** @class */function (_super) {
            __extends(INTTIME, _super);
            function INTTIME() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            INTTIME.prototype.load = function (value) {
              // value is an eight-byte long bytestring encoding the integer number of
              // 100-nanosecond intervals since January 1, 1601.
              //
              // Use bigint due to number type being too small to fit a 64-bit integer
              var delta = value.slice().reverse().reduce(function (a, b) {
                return bigInt(a).shiftLeft(8).add(bigInt(b));
              });
              return new Date(new Date('1601-01-01T00:00:00Z').getTime() + Number(delta.divide(10000)));
            };
            return INTTIME;
          }(FixedLengthValueLoader);
          var BINARY = /** @class */function (_super) {
            __extends(BINARY, _super);
            function BINARY() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            BINARY.prototype.load = function (value) {
              return value;
            };
            return BINARY;
          }(VariableLengthValueLoader);
          var STRING8 = /** @class */function (_super) {
            __extends(STRING8, _super);
            function STRING8() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            STRING8.prototype.load = function (value) {
              return new TextDecoder("utf-8").decode(new Uint8Array(value || []));
            };
            return STRING8;
          }(VariableLengthValueLoader);
          var UNICODE = /** @class */function (_super) {
            __extends(UNICODE, _super);
            function UNICODE() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            UNICODE.prototype.load = function (value) {
              return new TextDecoder("utf-16le").decode(new Uint8Array(value || []));
            };
            return UNICODE;
          }(VariableLengthValueLoader);
          var EMBEDDED_MESSAGE = /** @class */function () {
            function EMBEDDED_MESSAGE() {}
            EMBEDDED_MESSAGE.prototype.load = function (cfb, entry_name) {
              return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4 /*yield*/, load_message_stream(cfb, entry_name, false)];
                    case 1:
                      return [2 /*return*/, _a.sent()];
                  }
                });
              });
            };
            return EMBEDDED_MESSAGE;
          }();
          var property_types = new Array(0x102 + 1);
          property_types[0x1] = new NULL();
          property_types[0x2] = new INTEGER16();
          property_types[0x3] = new INTEGER32();
          property_types[0x4] = "FLOAT";
          property_types[0x5] = "DOUBLE";
          property_types[0x6] = "CURRENCY";
          property_types[0x7] = "APPTIME";
          property_types[0xa] = "ERROR";
          property_types[0xb] = new BOOLEAN();
          property_types[0xd] = new EMBEDDED_MESSAGE();
          property_types[0x14] = new INTEGER64();
          property_types[0x1e] = new STRING8();
          property_types[0x1f] = new UNICODE();
          property_types[0x40] = new INTTIME();
          property_types[0x48] = "CLSID";
          property_types[0xFB] = "SVREID";
          property_types[0xFD] = "SRESTRICT";
          property_types[0xFE] = "ACTIONS";
          property_types[0x102] = new BINARY();
          function parse_properties(cfb, entry_name, is_top_level) {
            return __awaiter(this, void 0, void 0, function () {
              var entry, i, ret, property_type, property_tag, flags, value, tag_name, tag_type, stream_name, stream_name;
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    entry = CFB.find(cfb, entry_name);
                    if (entry == null) {
                      return [2 /*return*/, {}];
                    }
                    i = is_top_level ? 32 : 24;
                    ret = {};
                    _a.label = 1;
                  case 1:
                    if (!(i < entry.size)) return [3 /*break*/, 6];
                    property_type = entry.content.slice(i + 0, i + 2);
                    property_tag = entry.content.slice(i + 2, i + 4);
                    flags = entry.content.slice(i + 4, i + 8);
                    value = entry.content.slice(i + 8, i + 16);
                    i += 16;
                    // Turn the byte strings into numbers and look up the property type
                    property_type = property_type[0] + (property_type[1] << 8);
                    property_tag = property_tag[0] + (property_tag[1] << 8);
                    if (property_tag > property_tags.length || !property_tags[property_tag]) return [3 /*break*/, 1];
                    tag_name = property_tags[property_tag][0];
                    tag_type = property_types[property_type];
                    if (!(tag_type instanceof FixedLengthValueLoader)) return [3 /*break*/, 2];
                    ret[tag_name] = tag_type.load(value);
                    return [3 /*break*/, 5];
                  case 2:
                    if (!(tag_type instanceof VariableLengthValueLoader)) return [3 /*break*/, 3];
                    stream_name = "__substg1.0_" + property_tag.toString(16).toUpperCase().padStart(4, '0') + property_type.toString(16).toUpperCase().padStart(4, '0');
                    stream_name = entry_name.substring(0, entry_name.lastIndexOf('/')) + '/' + stream_name;
                    value = CFB.find(cfb, stream_name);
                    if (!value) return [3 /*break*/, 1];
                    ret[tag_name] = tag_type.load(value.content);
                    return [3 /*break*/, 5];
                  case 3:
                    if (!(tag_type instanceof EMBEDDED_MESSAGE)) return [3 /*break*/, 5];
                    stream_name = "__substg1.0_" + property_tag.toString(16).toUpperCase().padStart(4, '0') + property_type.toString(16).toUpperCase().padStart(4, '0');
                    stream_name = entry_name.substring(0, entry_name.lastIndexOf('/')) + '/' + stream_name;
                    return [4 /*yield*/, tag_type.load(cfb, stream_name)];
                  case 4:
                    value = _a.sent();
                    ret[tag_name] = value;
                    _a.label = 5;
                  case 5:
                    return [3 /*break*/, 1];
                  case 6:
                    return [2 /*return*/, ret];
                }
              });
            });
          }
          function process_attachment(cfb, entry_name, msg) {
            return __awaiter(this, void 0, void 0, function () {
              var props, blob, filename, mime_type;
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    return [4 /*yield*/, parse_properties(cfb, entry_name + "/__properties_version1.0", false)];
                  case 1:
                    props = _a.sent();
                    blob = props["ATTACH_DATA_BIN"];
                    if (!blob) {
                      return [2 /*return*/];
                    }

                    filename = props["ATTACH_LONG_FILENAME"] || props["ATTACH_FILENAME"];
                    // Determine the correct filename for embedded e-mails
                    if (!filename) {
                      if ("ATTACH_MIME_TAG" in props && props["ATTACH_MIME_TAG"] == "message/rfc822") {
                        if ("DISPLAY_NAME" in props && props["DISPLAY_NAME"]) {
                          filename = props["DISPLAY_NAME"].replace(/[/\\?%*:|"<>]/g, '-') + ".eml";
                        } else {
                          cfb.unknown_attachment_count = cfb.unknown_attachment_count || 0;
                          cfb.unknown_attachment_count++;
                          filename = "unknown_" + cfb.unknown_attachment_count + ".eml";
                        }
                        props["ATTACH_MIME_TAG"] = "message/rfc822";
                      } else {
                        cfb.unknown_attachment_count = cfb.unknown_attachment_count || 0;
                        cfb.unknown_attachment_count++;
                        filename = "unknown_" + cfb.unknown_attachment_count + ".dat";
                      }
                    }
                    mime_type = props["ATTACH_MIME_TAG"] || "application/octet-stream";
                    filename = filename.split("/").slice(-1)[0].split("\\").slice(-1)[0];
                    msg.attachments.push({
                      name: filename,
                      contentType: mime_type,
                      data: Buffer.from(blob)
                    });
                    return [2 /*return*/];
                }
              });
            });
          }

          function resolvePlaceholderHeaders(eml, headers) {
            return headers ? eml.toString().replace("Headers-Original: Headers-Original", headers.replace(/[\r\n]+$/, "")).replace(/To: Headers-Original(\r\n|$)/, "") : eml;
          }
          function load_message_stream(cfb, entry_name, is_top_level) {
            return __awaiter(this, void 0, void 0, function () {
              var props, msg, headers_obj, original_headers, headers, header_lines, attachment_refs, rtf, html, r, m, i;
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    return [4 /*yield*/, parse_properties(cfb, entry_name + "/__properties_version1.0", is_top_level)];
                  case 1:
                    props = _a.sent();
                    msg = {};
                    headers_obj = {};
                    original_headers = null;
                    if ('TRANSPORT_MESSAGE_HEADERS' in props) {
                      headers = props['TRANSPORT_MESSAGE_HEADERS'];
                      header_lines = Array.from(headers.split("\r\n"));
                      // Ensure the transport headers are valid
                      if (header_lines.length && header_lines.filter(function (h) {
                        return h.length && h.indexOf(': ') >= 0;
                      }).length > 0) {
                        // Put a placeholder header which will be resolved later
                        headers_obj["Headers-Original"] = "Headers-Original";
                        // Put a dummy To header to satisfy EML formatter
                        if (/(^|[\r\n])To: /.test(headers)) {
                          headers_obj["To"] = "Headers-Original";
                        } else if ("DISPLAY_TO" in props && props["DISPLAY_TO"]) {
                          headers_obj["To"] = props["DISPLAY_TO"].replace(/\x00$/, "");
                        }
                        // Strip headers for attachments
                        original_headers = headers.replace(/(^|[\r\n])\s*boundary=--[\s\S]+/, "").replace(/(^|[\r\n])Content-Type: .+(\r\n|$)/, "");
                      }
                    }
                    if (Object.keys(headers_obj).length == 0) {
                      // Construct common headers from metadata.
                      if ("MESSAGE_DELIVERY_TIME" in props) {
                        headers_obj["Date"] = moment(props["MESSAGE_DELIVERY_TIME"]).format("ddd, DD MMM YYYY HH:mm:ss ZZ");
                      }
                      if ("SENDER_NAME" in props && props["SENDER_NAME"]) {
                        if ("SENT_REPRESENTING_NAME" in props && props["SENT_REPRESENTING_NAME"] && props["SENDER_NAME"] != props["SENT_REPRESENTING_NAME"]) {
                          props["SENDER_NAME"] = props["SENDER_NAME"] + " (" + props["SENT_REPRESENTING_NAME"] + ")";
                        }
                        headers_obj["From"] = props["SENDER_NAME"];
                      }
                      if ("SENDER_EMAIL_ADDRESS" in props && props["SENDER_EMAIL_ADDRESS"]) {
                        headers_obj["From"] = (headers_obj["From"] || "") + " <" + props["SENDER_EMAIL_ADDRESS"] + ">";
                      }
                      if ("DISPLAY_TO" in props && props["DISPLAY_TO"]) {
                        headers_obj["To"] = props["DISPLAY_TO"].replace(/\x00$/, "");
                      }
                      if ("DISPLAY_CC" in props && props["DISPLAY_CC"]) {
                        headers_obj["CC"] = props["DISPLAY_CC"];
                      }
                      if ("DISPLAY_BCC" in props && props["DISPLAY_BCC"]) {
                        headers_obj["BCC"] = props["DISPLAY_BCC"];
                      }
                      if ("SUBJECT" in props && props["SUBJECT"]) {
                        headers_obj["Subject"] = props["SUBJECT"];
                      }
                    }
                    attachment_refs = {};
                    if ("BODY" in props && !("RTF_COMPRESSED" in props)) {
                      msg["text"] = props["BODY"];
                    } else {
                      rtf = new Uint8Array(decompressRTF(props["RTF_COMPRESSED"]));
                      // Check if the RTF actually contains HTML tags, otherwise use plaintext
                      if (new TextDecoder("utf-8").decode(rtf).indexOf("\\*\\htmltag") >= 0) {
                        html = (0, rtf_stream_parser_1.deEncapsulateSync)(Buffer.from(rtf), {
                          decode: iconvLite.decode
                        }).text;
                        msg["html"] = html;
                        r = /src="cid:(([^@]+)@[A-Z0-9]+\.[A-Z0-9]+)"/g;
                        m = void 0;
                        while ((m = r.exec(html)) !== null) {
                          attachment_refs[m[2]] = m[1];
                        }
                      } else {
                        msg["text"] = props["BODY"];
                      }
                    }
                    msg["headers"] = headers_obj;
                    // Copy all attachments
                    msg.attachments = msg.attachments || [];
                    i = 0;
                    _a.label = 2;
                  case 2:
                    if (!(i < cfb.FullPaths.length)) return [3 /*break*/, 5];
                    if (!(cfb.FullPaths[i].indexOf("/__attach_version1.0_#") >= 0 && cfb.FullPaths[i].indexOf(entry_name.replace(/\/$/g, "")) == 0 && cfb.FullPaths[i].replace(/\/$/g, "") != entry_name.replace(/\/$/g, "") && cfb.FullPaths[i].replace(/\/$/g, "").split('/').length == entry_name.replace(/\/$/g, "").split('/').length + 1)) return [3 /*break*/, 4];
                    return [4 /*yield*/, process_attachment(cfb, cfb.FullPaths[i].replace(/\/$/g, ""), msg)];
                  case 3:
                    _a.sent();
                    _a.label = 4;
                  case 4:
                    i++;
                    return [3 /*break*/, 2];
                  case 5:
                    // Fix inline-attachment references
                    msg.attachments.forEach(function (a) {
                      if (a.name in attachment_refs) {
                        a.cid = attachment_refs[a.name];
                      }
                    });
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                      eml_format.build(msg, function (error, eml) {
                        if (error) {
                          reject(error);
                        } else {
                          resolve(resolvePlaceholderHeaders(eml, original_headers));
                        }
                      });
                    })];
                }
              });
            });
          }
          moment.locale("en");
          function msg2eml(obj) {
            return __awaiter(this, void 0, void 0, function () {
              var arrBuffer, _a, result;
              return __generator(this, function (_b) {
                switch (_b.label) {
                  case 0:
                    if (!(obj.constructor && obj.constructor.name === 'Blob')) return [3 /*break*/, 2];
                    _a = Uint8Array.bind;
                    return [4 /*yield*/, obj.arrayBuffer()];
                  case 1:
                    arrBuffer = new (_a.apply(Uint8Array, [void 0, _b.sent()]))();
                    return [3 /*break*/, 3];
                  case 2:
                    if (obj.constructor && obj.constructor.name == 'Array' || obj.constructor && obj.constructor.name == 'ArrayBuffer') {
                      arrBuffer = new Uint8Array(obj);
                    } else {
                      throw 'Unknown or unsupported source type: ' + (obj.constructor ? obj.constructor.name : obj);
                    }
                    _b.label = 3;
                  case 3:
                    result = CFB.parse(arrBuffer);
                    return [4 /*yield*/, load_message_stream(result, "Root Entry", true)];
                  case 4:
                    return [2 /*return*/, _b.sent()];
                }
              });
            });
          }
          exports.msg2eml = msg2eml;
          ;
          if (typeof window !== 'undefined' && window) {
            window.msg2eml = msg2eml;
          }
          if (typeof module !== 'undefined' && module && module.exports) {
            module.exports = msg2eml;
          }
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "@kenjiuno/decompressrtf": 2,
      "big-integer": 4,
      "buffer": 7,
      "cfb": 8,
      "eml-format": 9,
      "iconv-lite": 31,
      "moment": 34,
      "rtf-stream-parser": 50
    }],
    2: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.decompressRTF = void 0;
      var Stream = /** @class */function () {
        function Stream(buf) {
          this.buf = buf;
        }
        Stream.prototype.readInt32LE = function (offset) {
          var value = this.buf[offset] & 255 | (this.buf[offset + 1] & 255) << 8 | (this.buf[offset + 2] & 255) << 16 | (this.buf[offset + 3] & 255) << 24;
          return value;
        };
        Stream.prototype.readUInt16BE = function (offset) {
          var value = (this.buf[offset] & 255) << 8 | this.buf[offset + 1] & 255;
          return value;
        };
        Stream.prototype.readUInt8 = function (offset) {
          var value = this.buf[offset] & 255;
          return value;
        };
        Stream.prototype.writeUInt8 = function (value, offset) {
          this.buf[offset] = value & 255;
        };
        return Stream;
      }();
      /**
       * Decompress PR_RTF_COMPRESSED (PidTagRtfCompressed) data
       *
       * Check these:
       *
       * - The Compressed RTF Format
       *   https://www.freeutils.net/source/jtnef/rtfcompressed
       *
       * - 2.1.3.1 RTF Compression Format
       *   https://msdn.microsoft.com/en-us/library/ee159164(v=exchg.80).aspx
       *
       */
      function decompressRTF(inputArray) {
        if (inputArray.length < 16) {
          throw new Error("At least 16 bytes");
        }
        var input = new Stream(inputArray);
        var fileSize = input.readInt32LE(0);
        var rawSize = input.readInt32LE(4);
        var compType = input.readInt32LE(8);
        var crc = input.readInt32LE(12);
        var COMPRESSED = 0x75465A4C;
        var UNCOMPRESSED = 0x414C454D;
        if (compType == COMPRESSED) {
          var initialDictionary = "{\\rtf1\\ansi\\mac\\deff0\\deftab720{\\fonttbl;}{\\f0\\fnil \\froman \\fswi" + "ss \\fmodern \\fscript \\fdecor MS Sans SerifSymbolArialTimes New Ro" + "manCourier{\\colortbl\\red0\\green0\\blue0\r\n\\par \\pard\\plain\\f0\\fs20\\" + "b\\i\\u\\tab\\tx";
          //if (initialDictionary.length != 207) throw new Error("Fix initialDictionary!");
          var outputArray = []; // automatically expanded
          var output = new Stream(outputArray);
          var outPos = 0;
          var inPos = 16;
          var control = void 0;
          for (var x = 0; x < initialDictionary.length; x += 1) {
            output.writeUInt8(initialDictionary.charCodeAt(x), outPos);
            outPos += 1;
          }
          var inEnd = fileSize + 4;
          for (var run_1 = 0; inPos < inEnd; run_1 = run_1 + 1 & 7) {
            if (0 == run_1) {
              control = input.readUInt8(inPos);
              inPos += 1;
            }
            if (0 != (1 << run_1 & control)) {
              // dictionary
              var token = input.readUInt16BE(inPos);
              inPos += 2;
              var offset = token >> 4;
              var length_1 = (token & 15) + 2;
              var readPos = (outPos & ~4095) + offset;
              if (readPos == outPos) {
                break;
              }
              if (readPos > outPos) {
                readPos -= 4096;
              }
              for (var x = 0; x < length_1; x += 1) {
                var octet = output.readUInt8(readPos);
                output.writeUInt8(octet, outPos);
                readPos += 1;
                outPos += 1;
              }
            } else {
              // literal
              var octet = input.readUInt8(inPos);
              output.writeUInt8(octet, outPos);
              inPos += 1;
              outPos += 1;
            }
          }
          return outputArray.slice(initialDictionary.length);
        } else if (compType == UNCOMPRESSED) {
          return inputArray.slice(16, 16 + rawSize);
        } else {
          throw new Error("Either COMPRESSED or UNCOMPRESSED");
        }
      }
      exports.decompressRTF = decompressRTF;
    }, {}],
    3: [function (require, module, exports) {
      'use strict';

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications
      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
      function getLens(b64) {
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }

        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }

      // base64 is 4/3 + up to two characters of the original data
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;

        // if there are placeholders, only get up to the last complete 4 chars
        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i;
        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }
        return output.join('');
      }
      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
        }
        return parts.join('');
      }
    }, {}],
    4: [function (require, module, exports) {
      var bigInt = function (undefined) {
        "use strict";

        var BASE = 1e7,
          LOG_BASE = 7,
          MAX_INT = 9007199254740992,
          MAX_INT_ARR = smallToArray(MAX_INT),
          DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        var supportsNativeBigInt = typeof BigInt === "function";
        function Integer(v, radix, alphabet, caseSensitive) {
          if (typeof v === "undefined") return Integer[0];
          if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
          return parseValue(v);
        }
        function BigInteger(value, sign) {
          this.value = value;
          this.sign = sign;
          this.isSmall = false;
        }
        BigInteger.prototype = Object.create(Integer.prototype);
        function SmallInteger(value) {
          this.value = value;
          this.sign = value < 0;
          this.isSmall = true;
        }
        SmallInteger.prototype = Object.create(Integer.prototype);
        function NativeBigInt(value) {
          this.value = value;
        }
        NativeBigInt.prototype = Object.create(Integer.prototype);
        function isPrecise(n) {
          return -MAX_INT < n && n < MAX_INT;
        }
        function smallToArray(n) {
          // For performance reasons doesn't reference BASE, need to change this function if BASE changes
          if (n < 1e7) return [n];
          if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
          return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
        }
        function arrayToSmall(arr) {
          // If BASE changes this function may need to change
          trim(arr);
          var length = arr.length;
          if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
              case 0:
                return 0;
              case 1:
                return arr[0];
              case 2:
                return arr[0] + arr[1] * BASE;
              default:
                return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
          }
          return arr;
        }
        function trim(v) {
          var i = v.length;
          while (v[--i] === 0) {
            ;
          }
          v.length = i + 1;
        }
        function createArray(length) {
          // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
          var x = new Array(length);
          var i = -1;
          while (++i < length) {
            x[i] = 0;
          }
          return x;
        }
        function truncate(n) {
          if (n > 0) return Math.floor(n);
          return Math.ceil(n);
        }
        function add(a, b) {
          // assumes a and b are arrays with a.length >= b.length
          var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum,
            i;
          for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
          }
          while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
          }
          if (carry > 0) r.push(carry);
          return r;
        }
        function addAny(a, b) {
          if (a.length >= b.length) return add(a, b);
          return add(b, a);
        }
        function addSmall(a, carry) {
          // assumes a is array, carry is number with 0 <= carry < MAX_INT
          var l = a.length,
            r = new Array(l),
            base = BASE,
            sum,
            i;
          for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
          }
          while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r;
        }
        BigInteger.prototype.add = function (v) {
          var n = parseValue(v);
          if (this.sign !== n.sign) {
            return this.subtract(n.negate());
          }
          var a = this.value,
            b = n.value;
          if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
          }
          return new BigInteger(addAny(a, b), this.sign);
        };
        BigInteger.prototype.plus = BigInteger.prototype.add;
        SmallInteger.prototype.add = function (v) {
          var n = parseValue(v);
          var a = this.value;
          if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
          }
          var b = n.value;
          if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
          }
          return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
        };
        SmallInteger.prototype.plus = SmallInteger.prototype.add;
        NativeBigInt.prototype.add = function (v) {
          return new NativeBigInt(this.value + parseValue(v).value);
        };
        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
        function subtract(a, b) {
          // assumes a and b are arrays with a >= b
          var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i,
            difference;
          for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
              difference += base;
              borrow = 1;
            } else borrow = 0;
            r[i] = difference;
          }
          for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;else {
              r[i++] = difference;
              break;
            }
            r[i] = difference;
          }
          for (; i < a_l; i++) {
            r[i] = a[i];
          }
          trim(r);
          return r;
        }
        function subtractAny(a, b, sign) {
          var value;
          if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
          } else {
            value = subtract(b, a);
            sign = !sign;
          }
          value = arrayToSmall(value);
          if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
          }
          return new BigInteger(value, sign);
        }
        function subtractSmall(a, b, sign) {
          // assumes a is array, b is number with 0 <= b < MAX_INT
          var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i,
            difference;
          for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
          }
          r = arrayToSmall(r);
          if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
          }
          return new BigInteger(r, sign);
        }
        BigInteger.prototype.subtract = function (v) {
          var n = parseValue(v);
          if (this.sign !== n.sign) {
            return this.add(n.negate());
          }
          var a = this.value,
            b = n.value;
          if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
          return subtractAny(a, b, this.sign);
        };
        BigInteger.prototype.minus = BigInteger.prototype.subtract;
        SmallInteger.prototype.subtract = function (v) {
          var n = parseValue(v);
          var a = this.value;
          if (a < 0 !== n.sign) {
            return this.add(n.negate());
          }
          var b = n.value;
          if (n.isSmall) {
            return new SmallInteger(a - b);
          }
          return subtractSmall(b, Math.abs(a), a >= 0);
        };
        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
        NativeBigInt.prototype.subtract = function (v) {
          return new NativeBigInt(this.value - parseValue(v).value);
        };
        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
        BigInteger.prototype.negate = function () {
          return new BigInteger(this.value, !this.sign);
        };
        SmallInteger.prototype.negate = function () {
          var sign = this.sign;
          var small = new SmallInteger(-this.value);
          small.sign = !sign;
          return small;
        };
        NativeBigInt.prototype.negate = function () {
          return new NativeBigInt(-this.value);
        };
        BigInteger.prototype.abs = function () {
          return new BigInteger(this.value, false);
        };
        SmallInteger.prototype.abs = function () {
          return new SmallInteger(Math.abs(this.value));
        };
        NativeBigInt.prototype.abs = function () {
          return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
        };
        function multiplyLong(a, b) {
          var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product,
            carry,
            i,
            a_i,
            b_j;
          for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
              b_j = b[j];
              product = a_i * b_j + r[i + j];
              carry = Math.floor(product / base);
              r[i + j] = product - carry * base;
              r[i + j + 1] += carry;
            }
          }
          trim(r);
          return r;
        }
        function multiplySmall(a, b) {
          // assumes a is array, b is number with |b| < BASE
          var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product,
            i;
          for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
          }
          while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r;
        }
        function shiftLeft(x, n) {
          var r = [];
          while (n-- > 0) {
            r.push(0);
          }
          return r.concat(x);
        }
        function multiplyKaratsuba(x, y) {
          var n = Math.max(x.length, y.length);
          if (n <= 30) return multiplyLong(x, y);
          n = Math.ceil(n / 2);
          var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);
          var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
          var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
          trim(product);
          return product;
        }

        // The following function is derived from a surface fit of a graph plotting the performance difference
        // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
        function useKaratsuba(l1, l2) {
          return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
        }
        BigInteger.prototype.multiply = function (v) {
          var n = parseValue(v),
            a = this.value,
            b = n.value,
            sign = this.sign !== n.sign,
            abs;
          if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
              return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
          }
          if (useKaratsuba(a.length, b.length))
            // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
          return new BigInteger(multiplyLong(a, b), sign);
        };
        BigInteger.prototype.times = BigInteger.prototype.multiply;
        function multiplySmallAndArray(a, b, sign) {
          // a >= 0
          if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
          }
          return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
        }
        SmallInteger.prototype._multiplyBySmall = function (a) {
          if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
          }
          return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
        };
        BigInteger.prototype._multiplyBySmall = function (a) {
          if (a.value === 0) return Integer[0];
          if (a.value === 1) return this;
          if (a.value === -1) return this.negate();
          return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
        };
        SmallInteger.prototype.multiply = function (v) {
          return parseValue(v)._multiplyBySmall(this);
        };
        SmallInteger.prototype.times = SmallInteger.prototype.multiply;
        NativeBigInt.prototype.multiply = function (v) {
          return new NativeBigInt(this.value * parseValue(v).value);
        };
        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
        function square(a) {
          //console.assert(2 * BASE * BASE < MAX_INT);
          var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product,
            carry,
            i,
            a_i,
            a_j;
          for (i = 0; i < l; i++) {
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for (var j = i; j < l; j++) {
              a_j = a[j];
              product = 2 * (a_i * a_j) + r[i + j] + carry;
              carry = Math.floor(product / base);
              r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
          }
          trim(r);
          return r;
        }
        BigInteger.prototype.square = function () {
          return new BigInteger(square(this.value), false);
        };
        SmallInteger.prototype.square = function () {
          var value = this.value * this.value;
          if (isPrecise(value)) return new SmallInteger(value);
          return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
        };
        NativeBigInt.prototype.square = function (v) {
          return new NativeBigInt(this.value * this.value);
        };
        function divMod1(a, b) {
          // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
          var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit,
            shift,
            carry,
            borrow,
            i,
            l,
            q;
          if (remainder.length <= a_l) remainder.push(0);
          divisor.push(0);
          divisorMostSignificantDigit = divisor[b_l - 1];
          for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
              carry += quotientDigit * divisor[i];
              q = Math.floor(carry / base);
              borrow += remainder[shift + i] - (carry - q * base);
              carry = q;
              if (borrow < 0) {
                remainder[shift + i] = borrow + base;
                borrow = -1;
              } else {
                remainder[shift + i] = borrow;
                borrow = 0;
              }
            }
            while (borrow !== 0) {
              quotientDigit -= 1;
              carry = 0;
              for (i = 0; i < l; i++) {
                carry += remainder[shift + i] - base + divisor[i];
                if (carry < 0) {
                  remainder[shift + i] = carry + base;
                  carry = 0;
                } else {
                  remainder[shift + i] = carry;
                  carry = 1;
                }
              }
              borrow += carry;
            }
            result[shift] = quotientDigit;
          }
          // denormalization
          remainder = divModSmall(remainder, lambda)[0];
          return [arrayToSmall(result), arrayToSmall(remainder)];
        }
        function divMod2(a, b) {
          // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
          // Performs faster than divMod1 on larger input sizes.
          var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess,
            xlen,
            highx,
            highy,
            check;
          while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
              result.push(0);
              continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
              highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
              check = multiplySmall(b, guess);
              if (compareAbs(check, part) <= 0) break;
              guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
          }
          result.reverse();
          return [arrayToSmall(result), arrayToSmall(part)];
        }
        function divModSmall(value, lambda) {
          var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i,
            q,
            remainder,
            divisor;
          remainder = 0;
          for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
          }
          return [quotient, remainder | 0];
        }
        function divModAny(self, v) {
          var value,
            n = parseValue(v);
          if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
          }
          var a = self.value,
            b = n.value;
          var quotient;
          if (b === 0) throw new Error("Cannot divide by zero");
          if (self.isSmall) {
            if (n.isSmall) {
              return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
          }
          if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
              value = divModSmall(a, abs);
              quotient = arrayToSmall(value[0]);
              var remainder = value[1];
              if (self.sign) remainder = -remainder;
              if (typeof quotient === "number") {
                if (self.sign !== n.sign) quotient = -quotient;
                return [new SmallInteger(quotient), new SmallInteger(remainder)];
              }
              return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
          }
          var comparison = compareAbs(a, b);
          if (comparison === -1) return [Integer[0], self];
          if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

          // divMod1 is faster on smaller input sizes
          if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
          quotient = value[0];
          var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
          if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
          } else quotient = new BigInteger(quotient, qSign);
          if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
          } else mod = new BigInteger(mod, mSign);
          return [quotient, mod];
        }
        BigInteger.prototype.divmod = function (v) {
          var result = divModAny(this, v);
          return {
            quotient: result[0],
            remainder: result[1]
          };
        };
        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
        BigInteger.prototype.divide = function (v) {
          return divModAny(this, v)[0];
        };
        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
          return new NativeBigInt(this.value / parseValue(v).value);
        };
        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
        BigInteger.prototype.mod = function (v) {
          return divModAny(this, v)[1];
        };
        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
          return new NativeBigInt(this.value % parseValue(v).value);
        };
        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
        BigInteger.prototype.pow = function (v) {
          var n = parseValue(v),
            a = this.value,
            b = n.value,
            value,
            x,
            y;
          if (b === 0) return Integer[1];
          if (a === 0) return Integer[0];
          if (a === 1) return Integer[1];
          if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
          if (n.sign) {
            return Integer[0];
          }
          if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
          if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
          }
          x = this;
          y = Integer[1];
          while (true) {
            if (b & 1 === 1) {
              y = y.times(x);
              --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
          }
          return y;
        };
        SmallInteger.prototype.pow = BigInteger.prototype.pow;
        NativeBigInt.prototype.pow = function (v) {
          var n = parseValue(v);
          var a = this.value,
            b = n.value;
          var _0 = BigInt(0),
            _1 = BigInt(1),
            _2 = BigInt(2);
          if (b === _0) return Integer[1];
          if (a === _0) return Integer[0];
          if (a === _1) return Integer[1];
          if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
          if (n.isNegative()) return new NativeBigInt(_0);
          var x = this;
          var y = Integer[1];
          while (true) {
            if ((b & _1) === _1) {
              y = y.times(x);
              --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
          }
          return y;
        };
        BigInteger.prototype.modPow = function (exp, mod) {
          exp = parseValue(exp);
          mod = parseValue(mod);
          if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
          var r = Integer[1],
            base = this.mod(mod);
          if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
          }
          while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
          }
          return r;
        };
        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
        function compareAbs(a, b) {
          if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
          }
          for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
          }
          return 0;
        }
        BigInteger.prototype.compareAbs = function (v) {
          var n = parseValue(v),
            a = this.value,
            b = n.value;
          if (n.isSmall) return 1;
          return compareAbs(a, b);
        };
        SmallInteger.prototype.compareAbs = function (v) {
          var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
          if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
          }
          return -1;
        };
        NativeBigInt.prototype.compareAbs = function (v) {
          var a = this.value;
          var b = parseValue(v).value;
          a = a >= 0 ? a : -a;
          b = b >= 0 ? b : -b;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        BigInteger.prototype.compare = function (v) {
          // See discussion about comparison with Infinity:
          // https://github.com/peterolson/BigInteger.js/issues/61
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var n = parseValue(v),
            a = this.value,
            b = n.value;
          if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
          }
          if (n.isSmall) {
            return this.sign ? -1 : 1;
          }
          return compareAbs(a, b) * (this.sign ? -1 : 1);
        };
        BigInteger.prototype.compareTo = BigInteger.prototype.compare;
        SmallInteger.prototype.compare = function (v) {
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var n = parseValue(v),
            a = this.value,
            b = n.value;
          if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
          }
          if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
          }
          return a < 0 ? 1 : -1;
        };
        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
        NativeBigInt.prototype.compare = function (v) {
          if (v === Infinity) {
            return -1;
          }
          if (v === -Infinity) {
            return 1;
          }
          var a = this.value;
          var b = parseValue(v).value;
          return a === b ? 0 : a > b ? 1 : -1;
        };
        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
        BigInteger.prototype.equals = function (v) {
          return this.compare(v) === 0;
        };
        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
        BigInteger.prototype.notEquals = function (v) {
          return this.compare(v) !== 0;
        };
        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
        BigInteger.prototype.greater = function (v) {
          return this.compare(v) > 0;
        };
        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
        BigInteger.prototype.lesser = function (v) {
          return this.compare(v) < 0;
        };
        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
        BigInteger.prototype.greaterOrEquals = function (v) {
          return this.compare(v) >= 0;
        };
        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
        BigInteger.prototype.lesserOrEquals = function (v) {
          return this.compare(v) <= 0;
        };
        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
        BigInteger.prototype.isEven = function () {
          return (this.value[0] & 1) === 0;
        };
        SmallInteger.prototype.isEven = function () {
          return (this.value & 1) === 0;
        };
        NativeBigInt.prototype.isEven = function () {
          return (this.value & BigInt(1)) === BigInt(0);
        };
        BigInteger.prototype.isOdd = function () {
          return (this.value[0] & 1) === 1;
        };
        SmallInteger.prototype.isOdd = function () {
          return (this.value & 1) === 1;
        };
        NativeBigInt.prototype.isOdd = function () {
          return (this.value & BigInt(1)) === BigInt(1);
        };
        BigInteger.prototype.isPositive = function () {
          return !this.sign;
        };
        SmallInteger.prototype.isPositive = function () {
          return this.value > 0;
        };
        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
        BigInteger.prototype.isNegative = function () {
          return this.sign;
        };
        SmallInteger.prototype.isNegative = function () {
          return this.value < 0;
        };
        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
        BigInteger.prototype.isUnit = function () {
          return false;
        };
        SmallInteger.prototype.isUnit = function () {
          return Math.abs(this.value) === 1;
        };
        NativeBigInt.prototype.isUnit = function () {
          return this.abs().value === BigInt(1);
        };
        BigInteger.prototype.isZero = function () {
          return false;
        };
        SmallInteger.prototype.isZero = function () {
          return this.value === 0;
        };
        NativeBigInt.prototype.isZero = function () {
          return this.value === BigInt(0);
        };
        BigInteger.prototype.isDivisibleBy = function (v) {
          var n = parseValue(v);
          if (n.isZero()) return false;
          if (n.isUnit()) return true;
          if (n.compareAbs(2) === 0) return this.isEven();
          return this.mod(n).isZero();
        };
        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
        function isBasicPrime(v) {
          var n = v.abs();
          if (n.isUnit()) return false;
          if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
          if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
          if (n.lesser(49)) return true;
          // we don't know if it's prime: let the other functions figure it out
        }

        function millerRabinTest(n, a) {
          var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d,
            t,
            i,
            x;
          while (b.isEven()) {
            b = b.divide(2), r++;
          }
          next: for (i = 0; i < a.length; i++) {
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
              x = x.square().mod(n);
              if (x.isUnit()) return false;
              if (x.equals(nPrev)) continue next;
            }
            return false;
          }
          return true;
        }

        // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
        BigInteger.prototype.isPrime = function (strict) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined) return isPrime;
          var n = this.abs();
          var bits = n.bitLength();
          if (bits <= 64) return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
          var logN = Math.log(2) * bits.toJSNumber();
          var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
          for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt(i + 2));
          }
          return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
        BigInteger.prototype.isProbablePrime = function (iterations, rng) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined) return isPrime;
          var n = this.abs();
          var t = iterations === undefined ? 5 : iterations;
          for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt.randBetween(2, n.minus(2), rng));
          }
          return millerRabinTest(n, a);
        };
        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
        BigInteger.prototype.modInv = function (n) {
          var t = bigInt.zero,
            newT = bigInt.one,
            r = parseValue(n),
            newR = this.abs(),
            q,
            lastT,
            lastR;
          while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
          }
          if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
          if (t.compare(0) === -1) {
            t = t.add(n);
          }
          if (this.isNegative()) {
            return t.negate();
          }
          return t;
        };
        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
        BigInteger.prototype.next = function () {
          var value = this.value;
          if (this.sign) {
            return subtractSmall(value, 1, this.sign);
          }
          return new BigInteger(addSmall(value, 1), this.sign);
        };
        SmallInteger.prototype.next = function () {
          var value = this.value;
          if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
          return new BigInteger(MAX_INT_ARR, false);
        };
        NativeBigInt.prototype.next = function () {
          return new NativeBigInt(this.value + BigInt(1));
        };
        BigInteger.prototype.prev = function () {
          var value = this.value;
          if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
          }
          return subtractSmall(value, 1, this.sign);
        };
        SmallInteger.prototype.prev = function () {
          var value = this.value;
          if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
          return new BigInteger(MAX_INT_ARR, true);
        };
        NativeBigInt.prototype.prev = function () {
          return new NativeBigInt(this.value - BigInt(1));
        };
        var powersOfTwo = [1];
        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) {
          powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
        }
        var powers2Length = powersOfTwo.length,
          highestPower2 = powersOfTwo[powers2Length - 1];
        function shift_isSmall(n) {
          return Math.abs(n) <= BASE;
        }
        BigInteger.prototype.shiftLeft = function (v) {
          var n = parseValue(v).toJSNumber();
          if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
          }
          if (n < 0) return this.shiftRight(-n);
          var result = this;
          if (result.isZero()) return result;
          while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
          }
          return result.multiply(powersOfTwo[n]);
        };
        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
        BigInteger.prototype.shiftRight = function (v) {
          var remQuo;
          var n = parseValue(v).toJSNumber();
          if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
          }
          if (n < 0) return this.shiftLeft(-n);
          var result = this;
          while (n >= powers2Length) {
            if (result.isZero() || result.isNegative() && result.isUnit()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
          }
          remQuo = divModAny(result, powersOfTwo[n]);
          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        };
        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
        function bitwise(x, y, fn) {
          y = parseValue(y);
          var xSign = x.isNegative(),
            ySign = y.isNegative();
          var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
          var xDigit = 0,
            yDigit = 0;
          var xDivMod = null,
            yDivMod = null;
          var result = [];
          while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
              xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
              yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
          }
          var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
          for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
          }
          return sum;
        }
        BigInteger.prototype.not = function () {
          return this.negate().prev();
        };
        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
        BigInteger.prototype.and = function (n) {
          return bitwise(this, n, function (a, b) {
            return a & b;
          });
        };
        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
        BigInteger.prototype.or = function (n) {
          return bitwise(this, n, function (a, b) {
            return a | b;
          });
        };
        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
        BigInteger.prototype.xor = function (n) {
          return bitwise(this, n, function (a, b) {
            return a ^ b;
          });
        };
        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
        var LOBMASK_I = 1 << 30,
          LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
        function roughLOB(n) {
          // get lowestOneBit (rough)
          // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
          // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
          var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
          return x & -x;
        }
        function integerLogarithm(value, base) {
          if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? {
              p: t,
              e: e * 2 + 1
            } : {
              p: p,
              e: e * 2
            };
          }
          return {
            p: bigInt(1),
            e: 0
          };
        }
        BigInteger.prototype.bitLength = function () {
          var n = this;
          if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
          }
          if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
          }
          return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
        };
        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
        function max(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.greater(b) ? a : b;
        }
        function min(a, b) {
          a = parseValue(a);
          b = parseValue(b);
          return a.lesser(b) ? a : b;
        }
        function gcd(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          if (a.equals(b)) return a;
          if (a.isZero()) return b;
          if (b.isZero()) return a;
          var c = Integer[1],
            d,
            t;
          while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
          }
          while (a.isEven()) {
            a = a.divide(roughLOB(a));
          }
          do {
            while (b.isEven()) {
              b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
              t = b;
              b = a;
              a = t;
            }
            b = b.subtract(a);
          } while (!b.isZero());
          return c.isUnit() ? a : a.multiply(c);
        }
        function lcm(a, b) {
          a = parseValue(a).abs();
          b = parseValue(b).abs();
          return a.divide(gcd(a, b)).multiply(b);
        }
        function randBetween(a, b, rng) {
          a = parseValue(a);
          b = parseValue(b);
          var usedRNG = rng || Math.random;
          var low = min(a, b),
            high = max(a, b);
          var range = high.subtract(low).add(1);
          if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
          var digits = toBase(range, BASE).value;
          var result = [],
            restricted = true;
          for (var i = 0; i < digits.length; i++) {
            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < digits[i]) restricted = false;
          }
          return low.add(Integer.fromArray(result, BASE, false));
        }
        var parseBase = function parseBase(text, base, alphabet, caseSensitive) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          text = String(text);
          if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
          }
          var length = text.length;
          var i;
          var absBase = Math.abs(base);
          var alphabetValues = {};
          for (i = 0; i < alphabet.length; i++) {
            alphabetValues[alphabet[i]] = i;
          }
          for (i = 0; i < length; i++) {
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
              if (alphabetValues[c] >= absBase) {
                if (c === "1" && absBase === 1) continue;
                throw new Error(c + " is not a valid digit in base " + base + ".");
              }
            }
          }
          base = parseValue(base);
          var digits = [];
          var isNegative = text[0] === "-";
          for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));else if (c === "<") {
              var start = i;
              do {
                i++;
              } while (text[i] !== ">" && i < text.length);
              digits.push(parseValue(text.slice(start + 1, i)));
            } else throw new Error(c + " is not a valid character");
          }
          return parseBaseFromArray(digits, base, isNegative);
        };
        function parseBaseFromArray(digits, base, isNegative) {
          var val = Integer[0],
            pow = Integer[1],
            i;
          for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
          }
          return isNegative ? val.negate() : val;
        }
        function stringify(digit, alphabet) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          if (digit < alphabet.length) {
            return alphabet[digit];
          }
          return "<" + digit + ">";
        }
        function toBase(n, base) {
          base = bigInt(base);
          if (base.isZero()) {
            if (n.isZero()) return {
              value: [0],
              isNegative: false
            };
            throw new Error("Cannot convert nonzero numbers to base 0.");
          }
          if (base.equals(-1)) {
            if (n.isZero()) return {
              value: [0],
              isNegative: false
            };
            if (n.isNegative()) return {
              value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])),
              isNegative: false
            };
            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
              value: [].concat.apply([], arr),
              isNegative: false
            };
          }
          var neg = false;
          if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
          }
          if (base.isUnit()) {
            if (n.isZero()) return {
              value: [0],
              isNegative: false
            };
            return {
              value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
              isNegative: neg
            };
          }
          var out = [];
          var left = n,
            divmod;
          while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
              digit = base.minus(digit).abs();
              left = left.next();
            }
            out.push(digit.toJSNumber());
          }
          out.push(left.toJSNumber());
          return {
            value: out.reverse(),
            isNegative: neg
          };
        }
        function toBaseString(n, base, alphabet) {
          var arr = toBase(n, base);
          return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            return stringify(x, alphabet);
          }).join('');
        }
        BigInteger.prototype.toArray = function (radix) {
          return toBase(this, radix);
        };
        SmallInteger.prototype.toArray = function (radix) {
          return toBase(this, radix);
        };
        NativeBigInt.prototype.toArray = function (radix) {
          return toBase(this, radix);
        };
        BigInteger.prototype.toString = function (radix, alphabet) {
          if (radix === undefined) radix = 10;
          if (radix !== 10) return toBaseString(this, radix, alphabet);
          var v = this.value,
            l = v.length,
            str = String(v[--l]),
            zeros = "0000000",
            digit;
          while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
          }
          var sign = this.sign ? "-" : "";
          return sign + str;
        };
        SmallInteger.prototype.toString = function (radix, alphabet) {
          if (radix === undefined) radix = 10;
          if (radix != 10) return toBaseString(this, radix, alphabet);
          return String(this.value);
        };
        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
        NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
          return this.toString();
        };
        BigInteger.prototype.valueOf = function () {
          return parseInt(this.toString(), 10);
        };
        BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
        SmallInteger.prototype.valueOf = function () {
          return this.value;
        };
        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
          return parseInt(this.toString(), 10);
        };
        function parseStringValue(v) {
          if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
          }
          var sign = v[0] === "-";
          if (sign) v = v.slice(1);
          var split = v.split(/e/i);
          if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
          if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
              exp -= text.length - decimalPlace - 1;
              text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += new Array(exp + 1).join("0");
            v = text;
          }
          var isValid = /^([0-9][0-9]*)$/.test(v);
          if (!isValid) throw new Error("Invalid integer: " + v);
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
          }
          var r = [],
            max = v.length,
            l = LOG_BASE,
            min = max - l;
          while (max > 0) {
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
          }
          trim(r);
          return new BigInteger(r, sign);
        }
        function parseNumberValue(v) {
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
          }
          if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
          }
          return parseStringValue(v.toString());
        }
        function parseValue(v) {
          if (typeof v === "number") {
            return parseNumberValue(v);
          }
          if (typeof v === "string") {
            return parseStringValue(v);
          }
          if (typeof v === "bigint") {
            return new NativeBigInt(v);
          }
          return v;
        }
        // Pre-define numbers in range [-999,999]
        for (var i = 0; i < 1000; i++) {
          Integer[i] = parseValue(i);
          if (i > 0) Integer[-i] = parseValue(-i);
        }
        // Backwards compatibility
        Integer.one = Integer[1];
        Integer.zero = Integer[0];
        Integer.minusOne = Integer[-1];
        Integer.max = max;
        Integer.min = min;
        Integer.gcd = gcd;
        Integer.lcm = lcm;
        Integer.isInstance = function (x) {
          return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
        };
        Integer.randBetween = randBetween;
        Integer.fromArray = function (digits, base, isNegative) {
          return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
        };
        return Integer;
      }();

      // Node.js check
      if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
        module.exports = bigInt;
      }

      //amd check
      if (typeof define === "function" && define.amd) {
        define(function () {
          return bigInt;
        });
      }
    }, {}],
    5: [function (require, module, exports) {}, {}],
    6: [function (require, module, exports) {
      arguments[4][5][0].apply(exports, arguments);
    }, {
      "dup": 5
    }],
    7: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */
          /* eslint-disable no-proto */

          'use strict';

          var base64 = require('base64-js');
          var ieee754 = require('ieee754');
          exports.Buffer = Buffer;
          exports.SlowBuffer = SlowBuffer;
          exports.INSPECT_MAX_BYTES = 50;
          var K_MAX_LENGTH = 0x7fffffff;
          exports.kMaxLength = K_MAX_LENGTH;

          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Print warning and recommend using `buffer` v4.x which has an Object
           *               implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * We report that the browser does not support typed arrays if the are not subclassable
           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
           * for __proto__ and has a buggy typed array implementation.
           */
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
            console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
          }
          function typedArraySupport() {
            // Can typed array instances can be augmented?
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function foo() {
                  return 42;
                }
              };
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }
          Object.defineProperty(Buffer.prototype, 'parent', {
            enumerable: true,
            get: function get() {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.buffer;
            }
          });
          Object.defineProperty(Buffer.prototype, 'offset', {
            enumerable: true,
            get: function get() {
              if (!Buffer.isBuffer(this)) return undefined;
              return this.byteOffset;
            }
          });
          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            // Return an augmented `Uint8Array` instance
            var buf = new Uint8Array(length);
            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */

          function Buffer(arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new TypeError('The "string" argument must be of type string. Received type number');
              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }

          // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
          if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
              enumerable: false,
              writable: false
            });
          }
          Buffer.poolSize = 8192; // not used by this implementation

          function from(value, encodingOrOffset, length) {
            if (typeof value === 'string') {
              return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }
            if (value == null) {
              throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === 'number') {
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            }
            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }
            var b = fromObject(value);
            if (b) return b;
            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
              return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
            }
            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
          }

          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/
          Buffer.from = function (value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };

          // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
          // https://github.com/feross/buffer/pull/148
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;
          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }
          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }

          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/
          Buffer.alloc = function (size, fill, encoding) {
            return alloc(size, fill, encoding);
          };
          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }

          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */
          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(size);
          };
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */
          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(size);
          };
          function fromString(string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8';
            }
            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }
            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);
            var actual = buf.write(string, encoding);
            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              buf = buf.slice(0, actual);
            }
            return buf;
          }
          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }
          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }
            var buf;
            if (byteOffset === undefined && length === undefined) {
              buf = new Uint8Array(array);
            } else if (length === undefined) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }

            // Return an augmented `Uint8Array` instance
            buf.__proto__ = Buffer.prototype;
            return buf;
          }
          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);
              if (buf.length === 0) {
                return buf;
              }
              obj.copy(buf, 0, 0, len);
              return buf;
            }
            if (obj.length !== undefined) {
              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }
            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }
          function checked(length) {
            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= K_MAX_LENGTH) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              // eslint-disable-line eqeqeq
              length = 0;
            }
            return Buffer.alloc(+length);
          }
          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
          };

          Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            }
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer.alloc(0);
            }
            var i;
            if (length === undefined) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }
            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer.from(buf);
              }
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== 'string') {
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
            }
            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;

            // Use a for loop to avoid recursion
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len;
                case 'utf8':
                case 'utf-8':
                  return utf8ToBytes(string).length;
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2;
                case 'hex':
                  return len >>> 1;
                case 'base64':
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                  }

                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
              start = 0;
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
              return '';
            }
            if (end === undefined || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return '';
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return '';
            }
            if (!encoding) encoding = 'utf8';
            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end);
                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);
                case 'ascii':
                  return asciiSlice(this, start, end);
                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end);
                case 'base64':
                  return base64Slice(this, start, end);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;
              }
            }
          }

          // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
          // reliably in a browserify context because there could be multiple different
          // copies of the 'buffer' package in use. This method works even for Buffer
          // instances that were created from another copy of the `buffer` package.
          // See: https://github.com/feross/buffer/issues/154
          Buffer.prototype._isBuffer = true;
          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits');
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits');
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits');
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return '';
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.toLocaleString = Buffer.prototype.toString;
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = '';
            var max = exports.INSPECT_MAX_BYTES;
            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
            if (this.length > max) str += ' ... ';
            return '<Buffer ' + str + '>';
          };
          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer.from(target, target.offset, target.byteLength);
            }
            if (!Buffer.isBuffer(target)) {
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
            }
            if (start === undefined) {
              start = 0;
            }
            if (end === undefined) {
              end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
              thisStart = 0;
            }
            if (thisEnd === undefined) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index');
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
          };

          // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
          //
          // Arguments:
          // - buffer - a Buffer to search
          // - val - a string, Buffer, or number
          // - byteOffset - an index into `buffer`; will be clamped to an int32
          // - encoding - an optional encoding, relevant is val is a string
          // - dir - true for indexOf, false for lastIndexOf
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1;

            // Normalize byteOffset
            if (typeof byteOffset === 'string') {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff;
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000;
            }
            byteOffset = +byteOffset; // Coerce to Number.
            if (numberIsNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : buffer.length - 1;
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir) return -1;else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0;else return -1;
            }

            // Normalize val
            if (typeof val === 'string') {
              val = Buffer.from(val, encoding);
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === 'number') {
              val = val & 0xFF; // Search for a byte value [0-255]
              if (typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError('val must be string, number or Buffer');
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase();
              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i) {
              if (indexSize === 1) {
                return buf[i];
              } else {
                return buf.readUInt16BE(i * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i;
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found) return i;
              }
            }
            return -1;
          }
          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed)) return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8';
              length = this.length;
              offset = 0;
              // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset;
              length = this.length;
              offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === undefined) encoding = 'utf8';
              } else {
                encoding = length;
                length = undefined;
              }
            } else {
              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
            }
            var remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds');
            }
            if (!encoding) encoding = 'utf8';
            var loweredCase = false;
            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length);
                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length);
                case 'ascii':
                  return asciiWrite(this, string, offset, length);
                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length);
                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length);
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD;
                bytesPerSequence = 1;
              } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                codePoint = 0xDC00 | codePoint & 0x3FF;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }

          // Based on http://stackoverflow.com/a/22747272/680742, the browser with
          // the lowest limit is Chrome, with 0x10000 args.
          // We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 0x1000;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = '';
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7F);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = '';
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = '';
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = '';
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start) end = start;
            var newBuf = this.subarray(start, end);
            // Return an augmented `Uint8Array` instance
            newBuf.__proto__ = Buffer.prototype;
            return newBuf;
          };

          /*
           * Need to make sure that buffer isn't trying to write out of bounds.
           */
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul;
            }
            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul;
            }
            mul *= 0x80;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 0x8000 ? val | 0xFFFF0000 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1;
              checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = value / mul & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            this[offset] = value & 0xff;
            return offset + 1;
          };
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 0xFF;
            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1);
              checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 0xFF;
            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 0xFF;
            }
            return offset + byteLength;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
            if (value < 0) value = 0xff + value + 1;
            this[offset] = value & 0xff;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
            if (offset < 0) throw new RangeError('Index out of range');
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };

          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;

            // Copy 0 bytes; we're done
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;

            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }
            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
            if (end < 0) throw new RangeError('sourceEnd out of bounds');

            // Are we oob?
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
              // Use built-in when available, missing from IE11
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            }
            return len;
          };

          // Usage:
          //    buffer.fill(number[, offset[, end]])
          //    buffer.fill(buffer[, offset[, end]])
          //    buffer.fill(string[, offset[, end]][, encoding])
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === 'string') {
                encoding = end;
                end = this.length;
              }
              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string');
              }
              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
                  // Fast path: If `val` fits into a single byte, use that numeric value.
                  val = code;
                }
              }
            } else if (typeof val === 'number') {
              val = val & 255;
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index');
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;
            if (!val) val = 0;
            var i;
            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val + '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };

          // HELPER FUNCTIONS
          // ================

          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
          function base64clean(str) {
            // Node takes equal signs as end of the Base64 encoding
            str = str.split('=')[0];
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = str.trim().replace(INVALID_BASE64_RE, '');
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return '';
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '=';
            }
            return str;
          }
          function toHex(n) {
            if (n < 16) return '0' + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);

              // is surrogate component
              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                  }

                  // valid lead
                  leadSurrogate = codePoint;
                  continue;
                }

                // 2 leads in a row
                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  leadSurrogate = codePoint;
                  continue;
                }

                // valid surrogate pair
                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              }
              leadSurrogate = null;

              // encode utf8
              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
              } else {
                throw new Error('Invalid code point');
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xFF);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }
            return i;
          }

          // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
          // the `instanceof` check but they should be treated as of that type.
          // See: https://github.com/feross/buffer/issues/166
          function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            // For IE11 support
            return obj !== obj; // eslint-disable-line no-self-compare
          }
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "base64-js": 3,
      "buffer": 7,
      "ieee754": 32
    }],
    8: [function (require, module, exports) {
      (function (process, Buffer) {
        (function () {
          /* cfb.js (C) 2013-present SheetJS -- http://sheetjs.com */
          /* vim: set ts=2: */
          /*jshint eqnull:true */
          /*exported CFB */
          /*global module, require:false, process:false, Buffer:false, Uint8Array:false, Uint16Array:false */

          var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          function Base64_encode(input) {
            var o = "";
            var c1 = 0,
              c2 = 0,
              c3 = 0,
              e1 = 0,
              e2 = 0,
              e3 = 0,
              e4 = 0;
            for (var i = 0; i < input.length;) {
              c1 = input.charCodeAt(i++);
              e1 = c1 >> 2;
              c2 = input.charCodeAt(i++);
              e2 = (c1 & 3) << 4 | c2 >> 4;
              c3 = input.charCodeAt(i++);
              e3 = (c2 & 15) << 2 | c3 >> 6;
              e4 = c3 & 63;
              if (isNaN(c2)) e3 = e4 = 64;else if (isNaN(c3)) e4 = 64;
              o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
            }
            return o;
          }
          function Base64_decode(input) {
            var o = "";
            var c1 = 0,
              c2 = 0,
              c3 = 0,
              e1 = 0,
              e2 = 0,
              e3 = 0,
              e4 = 0;
            input = input.replace(/[^\w\+\/\=]/g, "");
            for (var i = 0; i < input.length;) {
              e1 = Base64_map.indexOf(input.charAt(i++));
              e2 = Base64_map.indexOf(input.charAt(i++));
              c1 = e1 << 2 | e2 >> 4;
              o += String.fromCharCode(c1);
              e3 = Base64_map.indexOf(input.charAt(i++));
              c2 = (e2 & 15) << 4 | e3 >> 2;
              if (e3 !== 64) o += String.fromCharCode(c2);
              e4 = Base64_map.indexOf(input.charAt(i++));
              c3 = (e3 & 3) << 6 | e4;
              if (e4 !== 64) o += String.fromCharCode(c3);
            }
            return o;
          }
          var has_buf = function () {
            return typeof Buffer !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && !!process.versions.node;
          }();
          var Buffer_from = function () {
            if (typeof Buffer !== 'undefined') {
              var nbfs = !Buffer.from;
              if (!nbfs) try {
                Buffer.from("foo", "utf8");
              } catch (e) {
                nbfs = true;
              }
              return nbfs ? function (buf, enc) {
                return enc ? new Buffer(buf, enc) : new Buffer(buf);
              } : Buffer.from.bind(Buffer);
            }
            return function () {};
          }();
          function new_raw_buf(len) {
            /* jshint -W056 */
            if (has_buf) {
              if (Buffer.alloc) return Buffer.alloc(len);
              var b = new Buffer(len);
              b.fill(0);
              return b;
            }
            return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
            /* jshint +W056 */
          }

          function new_unsafe_buf(len) {
            /* jshint -W056 */
            if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
            return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
            /* jshint +W056 */
          }

          var s2a = function s2a(s) {
            if (has_buf) return Buffer_from(s, "binary");
            return s.split("").map(function (x) {
              return x.charCodeAt(0) & 0xff;
            });
          };
          var chr0 = /\u0000/g,
            chr1 = /[\u0001-\u0006]/g;
          var __toBuffer = function __toBuffer(bufs) {
            var x = [];
            for (var i = 0; i < bufs[0].length; ++i) {
              x.push.apply(x, bufs[0][i]);
            }
            return x;
          };
          var ___toBuffer = __toBuffer;
          var __utf16le = function __utf16le(b, s, e) {
            var ss = [];
            for (var i = s; i < e; i += 2) {
              ss.push(String.fromCharCode(__readUInt16LE(b, i)));
            }
            return ss.join("").replace(chr0, '');
          };
          var ___utf16le = __utf16le;
          var __hexlify = function __hexlify(b, s, l) {
            var ss = [];
            for (var i = s; i < s + l; ++i) {
              ss.push(("0" + b[i].toString(16)).slice(-2));
            }
            return ss.join("");
          };
          var ___hexlify = __hexlify;
          var __bconcat = function __bconcat(bufs) {
            if (Array.isArray(bufs[0])) return [].concat.apply([], bufs);
            var maxlen = 0,
              i = 0;
            for (i = 0; i < bufs.length; ++i) {
              maxlen += bufs[i].length;
            }
            var o = new Uint8Array(maxlen);
            for (i = 0, maxlen = 0; i < bufs.length; maxlen += bufs[i].length, ++i) {
              o.set(bufs[i], maxlen);
            }
            return o;
          };
          var bconcat = __bconcat;
          if (has_buf) {
            __utf16le = function __utf16le(b, s, e) {
              if (!Buffer.isBuffer(b)) return ___utf16le(b, s, e);
              return b.toString('utf16le', s, e).replace(chr0, '') /*.replace(chr1,'!')*/;
            };

            __hexlify = function __hexlify(b, s, l) {
              return Buffer.isBuffer(b) ? b.toString('hex', s, s + l) : ___hexlify(b, s, l);
            };
            __toBuffer = function __toBuffer(bufs) {
              return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs);
            };
            s2a = function s2a(s) {
              return Buffer_from(s, "binary");
            };
            bconcat = function bconcat(bufs) {
              return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : __bconcat(bufs);
            };
          }
          var __readUInt8 = function __readUInt8(b, idx) {
            return b[idx];
          };
          var __readUInt16LE = function __readUInt16LE(b, idx) {
            return b[idx + 1] * (1 << 8) + b[idx];
          };
          var __readInt16LE = function __readInt16LE(b, idx) {
            var u = b[idx + 1] * (1 << 8) + b[idx];
            return u < 0x8000 ? u : (0xffff - u + 1) * -1;
          };
          var __readUInt32LE = function __readUInt32LE(b, idx) {
            return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
          };
          var __readInt32LE = function __readInt32LE(b, idx) {
            return (b[idx + 3] << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
          };
          function ReadShift(size, t) {
            var oI,
              oS,
              type = 0;
            switch (size) {
              case 1:
                oI = __readUInt8(this, this.l);
                break;
              case 2:
                oI = (t !== 'i' ? __readUInt16LE : __readInt16LE)(this, this.l);
                break;
              case 4:
                oI = __readInt32LE(this, this.l);
                break;
              case 16:
                type = 2;
                oS = __hexlify(this, this.l, size);
            }
            this.l += size;
            if (type === 0) return oI;
            return oS;
          }
          var __writeUInt32LE = function __writeUInt32LE(b, val, idx) {
            b[idx] = val & 0xFF;
            b[idx + 1] = val >>> 8 & 0xFF;
            b[idx + 2] = val >>> 16 & 0xFF;
            b[idx + 3] = val >>> 24 & 0xFF;
          };
          var __writeInt32LE = function __writeInt32LE(b, val, idx) {
            b[idx] = val & 0xFF;
            b[idx + 1] = val >> 8 & 0xFF;
            b[idx + 2] = val >> 16 & 0xFF;
            b[idx + 3] = val >> 24 & 0xFF;
          };
          function WriteShift(t, val, f) {
            var size = 0,
              i = 0;
            switch (f) {
              case "hex":
                for (; i < t; ++i) {
                  this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
                }
                return this;
              case "utf16le":
                var end = this.l + t;
                for (i = 0; i < Math.min(val.length, t); ++i) {
                  var cc = val.charCodeAt(i);
                  this[this.l++] = cc & 0xff;
                  this[this.l++] = cc >> 8;
                }
                while (this.l < end) {
                  this[this.l++] = 0;
                }
                return this;
            }
            switch (t) {
              case 1:
                size = 1;
                this[this.l] = val & 0xFF;
                break;
              case 2:
                size = 2;
                this[this.l] = val & 0xFF;
                val >>>= 8;
                this[this.l + 1] = val & 0xFF;
                break;
              case 4:
                size = 4;
                __writeUInt32LE(this, val, this.l);
                break;
              case -4:
                size = 4;
                __writeInt32LE(this, val, this.l);
                break;
            }
            this.l += size;
            return this;
          }
          function CheckField(hexstr, fld) {
            var m = __hexlify(this, this.l, hexstr.length >> 1);
            if (m !== hexstr) throw new Error(fld + 'Expected ' + hexstr + ' saw ' + m);
            this.l += hexstr.length >> 1;
          }
          function prep_blob(blob, pos) {
            blob.l = pos;
            blob.read_shift = ReadShift;
            blob.chk = CheckField;
            blob.write_shift = WriteShift;
          }
          function new_buf(sz) {
            var o = new_raw_buf(sz);
            prep_blob(o, 0);
            return o;
          }

          /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
          /* vim: set ts=2: */
          /*exported CRC32 */
          var CRC32 = function () {
            var CRC32 = {};
            CRC32.version = '1.2.1';
            /*global Int32Array */
            function signed_crc_table() {
              var c = 0,
                table = new Array(256);
              for (var n = 0; n != 256; ++n) {
                c = n;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
                table[n] = c;
              }
              return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
            }
            var T0 = signed_crc_table();
            function slice_by_16_tables(T) {
              var c = 0,
                v = 0,
                n = 0,
                table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096);
              for (n = 0; n != 256; ++n) {
                table[n] = T[n];
              }
              for (n = 0; n != 256; ++n) {
                v = T[n];
                for (c = 256 + n; c < 4096; c += 256) {
                  v = table[c] = v >>> 8 ^ T[v & 0xFF];
                }
              }
              var out = [];
              for (n = 1; n != 16; ++n) {
                out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
              }
              return out;
            }
            var TT = slice_by_16_tables(T0);
            var T1 = TT[0],
              T2 = TT[1],
              T3 = TT[2],
              T4 = TT[3],
              T5 = TT[4];
            var T6 = TT[5],
              T7 = TT[6],
              T8 = TT[7],
              T9 = TT[8],
              Ta = TT[9];
            var Tb = TT[10],
              Tc = TT[11],
              Td = TT[12],
              Te = TT[13],
              Tf = TT[14];
            function crc32_bstr(bstr, seed) {
              var C = seed ^ -1;
              for (var i = 0, L = bstr.length; i < L;) {
                C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 0xFF];
              }
              return ~C;
            }
            function crc32_buf(B, seed) {
              var C = seed ^ -1,
                L = B.length - 15,
                i = 0;
              for (; i < L;) {
                C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
              }
              L += 15;
              while (i < L) {
                C = C >>> 8 ^ T0[(C ^ B[i++]) & 0xFF];
              }
              return ~C;
            }
            function crc32_str(str, seed) {
              var C = seed ^ -1;
              for (var i = 0, L = str.length, c = 0, d = 0; i < L;) {
                c = str.charCodeAt(i++);
                if (c < 0x80) {
                  C = C >>> 8 ^ T0[(C ^ c) & 0xFF];
                } else if (c < 0x800) {
                  C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
                } else if (c >= 0xD800 && c < 0xE000) {
                  c = (c & 1023) + 64;
                  d = str.charCodeAt(i++) & 1023;
                  C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 0xFF];
                } else {
                  C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 0xFF];
                  C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
                }
              }
              return ~C;
            }
            CRC32.table = T0;
            CRC32.bstr = crc32_bstr;
            CRC32.buf = crc32_buf;
            CRC32.str = crc32_str;
            return CRC32;
          }();
          /* [MS-CFB] v20171201 */
          var CFB = function _CFB() {
            var exports = {};
            exports.version = '1.2.2';
            /* [MS-CFB] 2.6.4 */
            function namecmp(l, r) {
              var L = l.split("/"),
                R = r.split("/");
              for (var i = 0, c = 0, Z = Math.min(L.length, R.length); i < Z; ++i) {
                if (c = L[i].length - R[i].length) return c;
                if (L[i] != R[i]) return L[i] < R[i] ? -1 : 1;
              }
              return L.length - R.length;
            }
            function dirname(p) {
              if (p.charAt(p.length - 1) == "/") return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
              var c = p.lastIndexOf("/");
              return c === -1 ? p : p.slice(0, c + 1);
            }
            function filename(p) {
              if (p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));
              var c = p.lastIndexOf("/");
              return c === -1 ? p : p.slice(c + 1);
            }
            /* -------------------------------------------------------------------------- */
            /* DOS Date format:
               high|YYYYYYYm.mmmddddd.HHHHHMMM.MMMSSSSS|low
               add 1980 to stored year
               stored second should be doubled
            */

            /* write JS date to buf as a DOS date */
            function write_dos_date(buf, date) {
              if (typeof date === "string") date = new Date(date);
              var hms = date.getHours();
              hms = hms << 6 | date.getMinutes();
              hms = hms << 5 | date.getSeconds() >>> 1;
              buf.write_shift(2, hms);
              var ymd = date.getFullYear() - 1980;
              ymd = ymd << 4 | date.getMonth() + 1;
              ymd = ymd << 5 | date.getDate();
              buf.write_shift(2, ymd);
            }

            /* read four bytes from buf and interpret as a DOS date */
            function parse_dos_date(buf) {
              var hms = buf.read_shift(2) & 0xFFFF;
              var ymd = buf.read_shift(2) & 0xFFFF;
              var val = new Date();
              var d = ymd & 0x1F;
              ymd >>>= 5;
              var m = ymd & 0x0F;
              ymd >>>= 4;
              val.setMilliseconds(0);
              val.setFullYear(ymd + 1980);
              val.setMonth(m - 1);
              val.setDate(d);
              var S = hms & 0x1F;
              hms >>>= 5;
              var M = hms & 0x3F;
              hms >>>= 6;
              val.setHours(hms);
              val.setMinutes(M);
              val.setSeconds(S << 1);
              return val;
            }
            function parse_extra_field(blob) {
              prep_blob(blob, 0);
              var o = {};
              var flags = 0;
              while (blob.l <= blob.length - 4) {
                var type = blob.read_shift(2);
                var sz = blob.read_shift(2),
                  tgt = blob.l + sz;
                var p = {};
                switch (type) {
                  /* UNIX-style Timestamps */
                  case 0x5455:
                    {
                      flags = blob.read_shift(1);
                      if (flags & 1) p.mtime = blob.read_shift(4);
                      /* for some reason, CD flag corresponds to LFH */
                      if (sz > 5) {
                        if (flags & 2) p.atime = blob.read_shift(4);
                        if (flags & 4) p.ctime = blob.read_shift(4);
                      }
                      if (p.mtime) p.mt = new Date(p.mtime * 1000);
                    }
                    break;
                }
                blob.l = tgt;
                o[type] = p;
              }
              return o;
            }
            var fs;
            function get_fs() {
              return fs || (fs = require('fs'));
            }
            function parse(file, options) {
              if (file[0] == 0x50 && file[1] == 0x4b) return parse_zip(file, options);
              if ((file[0] | 0x20) == 0x6d && (file[1] | 0x20) == 0x69) return parse_mad(file, options);
              if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
              var mver = 3;
              var ssz = 512;
              var nmfs = 0; // number of mini FAT sectors
              var difat_sec_cnt = 0;
              var dir_start = 0;
              var minifat_start = 0;
              var difat_start = 0;
              var fat_addrs = []; // locations of FAT sectors

              /* [MS-CFB] 2.2 Compound File Header */
              var blob = file.slice(0, 512);
              prep_blob(blob, 0);

              /* major version */
              var mv = check_get_mver(blob);
              mver = mv[0];
              switch (mver) {
                case 3:
                  ssz = 512;
                  break;
                case 4:
                  ssz = 4096;
                  break;
                case 0:
                  if (mv[1] == 0) return parse_zip(file, options);
                /* falls through */
                default:
                  throw new Error("Major Version: Expected 3 or 4 saw " + mver);
              }

              /* reprocess header */
              if (ssz !== 512) {
                blob = file.slice(0, ssz);
                prep_blob(blob, 28 /* blob.l */);
              }
              /* Save header for final object */
              var header = file.slice(0, ssz);
              check_shifts(blob, mver);

              // Number of Directory Sectors
              var dir_cnt = blob.read_shift(4, 'i');
              if (mver === 3 && dir_cnt !== 0) throw new Error('# Directory Sectors: Expected 0 saw ' + dir_cnt);

              // Number of FAT Sectors
              blob.l += 4;

              // First Directory Sector Location
              dir_start = blob.read_shift(4, 'i');

              // Transaction Signature
              blob.l += 4;

              // Mini Stream Cutoff Size
              blob.chk('00100000', 'Mini Stream Cutoff Size: ');

              // First Mini FAT Sector Location
              minifat_start = blob.read_shift(4, 'i');

              // Number of Mini FAT Sectors
              nmfs = blob.read_shift(4, 'i');

              // First DIFAT sector location
              difat_start = blob.read_shift(4, 'i');

              // Number of DIFAT Sectors
              difat_sec_cnt = blob.read_shift(4, 'i');

              // Grab FAT Sector Locations
              for (var q = -1, j = 0; j < 109; ++j) {
                /* 109 = (512 - blob.l)>>>2; */
                q = blob.read_shift(4, 'i');
                if (q < 0) break;
                fat_addrs[j] = q;
              }

              /** Break the file up into sectors */
              var sectors = sectorify(file, ssz);
              sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);

              /** Chains */
              var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
              sector_list[dir_start].name = "!Directory";
              if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
              sector_list[fat_addrs[0]].name = "!FAT";
              sector_list.fat_addrs = fat_addrs;
              sector_list.ssz = ssz;

              /* [MS-CFB] 2.6.1 Compound File Directory Entry */
              var files = {},
                Paths = [],
                FileIndex = [],
                FullPaths = [];
              read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
              build_full_paths(FileIndex, FullPaths, Paths);
              Paths.shift();
              var o = {
                FileIndex: FileIndex,
                FullPaths: FullPaths
              };

              // $FlowIgnore
              if (options && options.raw) o.raw = {
                header: header,
                sectors: sectors
              };
              return o;
            } // parse

            /* [MS-CFB] 2.2 Compound File Header -- read up to major version */
            function check_get_mver(blob) {
              if (blob[blob.l] == 0x50 && blob[blob.l + 1] == 0x4b) return [0, 0];
              // header signature 8
              blob.chk(HEADER_SIGNATURE, 'Header Signature: ');

              // clsid 16
              //blob.chk(HEADER_CLSID, 'CLSID: ');
              blob.l += 16;

              // minor version 2
              var mver = blob.read_shift(2, 'u');
              return [blob.read_shift(2, 'u'), mver];
            }
            function check_shifts(blob, mver) {
              var shift = 0x09;

              // Byte Order
              //blob.chk('feff', 'Byte Order: '); // note: some writers put 0xffff
              blob.l += 2;

              // Sector Shift
              switch (shift = blob.read_shift(2)) {
                case 0x09:
                  if (mver != 3) throw new Error('Sector Shift: Expected 9 saw ' + shift);
                  break;
                case 0x0c:
                  if (mver != 4) throw new Error('Sector Shift: Expected 12 saw ' + shift);
                  break;
                default:
                  throw new Error('Sector Shift: Expected 9 or 12 saw ' + shift);
              }

              // Mini Sector Shift
              blob.chk('0600', 'Mini Sector Shift: ');

              // Reserved
              blob.chk('000000000000', 'Reserved: ');
            }

            /** Break the file up into sectors */
            function sectorify(file, ssz) {
              var nsectors = Math.ceil(file.length / ssz) - 1;
              var sectors = [];
              for (var i = 1; i < nsectors; ++i) {
                sectors[i - 1] = file.slice(i * ssz, (i + 1) * ssz);
              }
              sectors[nsectors - 1] = file.slice(nsectors * ssz);
              return sectors;
            }

            /* [MS-CFB] 2.6.4 Red-Black Tree */
            function build_full_paths(FI, FP, Paths) {
              var i = 0,
                L = 0,
                R = 0,
                C = 0,
                j = 0,
                pl = Paths.length;
              var dad = [],
                q = [];
              for (; i < pl; ++i) {
                dad[i] = q[i] = i;
                FP[i] = Paths[i];
              }
              for (; j < q.length; ++j) {
                i = q[j];
                L = FI[i].L;
                R = FI[i].R;
                C = FI[i].C;
                if (dad[i] === i) {
                  if (L !== -1 /*NOSTREAM*/ && dad[L] !== L) dad[i] = dad[L];
                  if (R !== -1 && dad[R] !== R) dad[i] = dad[R];
                }
                if (C !== -1 /*NOSTREAM*/) dad[C] = i;
                if (L !== -1 && i != dad[i]) {
                  dad[L] = dad[i];
                  if (q.lastIndexOf(L) < j) q.push(L);
                }
                if (R !== -1 && i != dad[i]) {
                  dad[R] = dad[i];
                  if (q.lastIndexOf(R) < j) q.push(R);
                }
              }
              for (i = 1; i < pl; ++i) {
                if (dad[i] === i) {
                  if (R !== -1 /*NOSTREAM*/ && dad[R] !== R) dad[i] = dad[R];else if (L !== -1 && dad[L] !== L) dad[i] = dad[L];
                }
              }
              for (i = 1; i < pl; ++i) {
                if (FI[i].type === 0 /* unknown */) continue;
                j = i;
                if (j != dad[j]) do {
                  j = dad[j];
                  FP[i] = FP[j] + "/" + FP[i];
                } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
                dad[i] = -1;
              }
              FP[0] += "/";
              for (i = 1; i < pl; ++i) {
                if (FI[i].type !== 2 /* stream */) FP[i] += "/";
              }
            }
            function get_mfat_entry(entry, payload, mini) {
              var start = entry.start,
                size = entry.size;
              //return (payload.slice(start*MSSZ, start*MSSZ + size));
              var o = [];
              var idx = start;
              while (mini && size > 0 && idx >= 0) {
                o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
                size -= MSSZ;
                idx = __readInt32LE(mini, idx * 4);
              }
              if (o.length === 0) return new_buf(0);
              return bconcat(o).slice(0, entry.size);
            }

            /** Chase down the rest of the DIFAT chain to build a comprehensive list
                DIFAT chains by storing the next sector number as the last 32 bits */
            function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
              var q = ENDOFCHAIN;
              if (idx === ENDOFCHAIN) {
                if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
              } else if (idx !== -1 /*FREESECT*/) {
                var sector = sectors[idx],
                  m = (ssz >>> 2) - 1;
                if (!sector) return;
                for (var i = 0; i < m; ++i) {
                  if ((q = __readInt32LE(sector, i * 4)) === ENDOFCHAIN) break;
                  fat_addrs.push(q);
                }
                if (cnt >= 1) sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
              }
            }

            /** Follow the linked list of sectors for a given starting point */
            function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
              var buf = [],
                buf_chain = [];
              if (!chkd) chkd = [];
              var modulus = ssz - 1,
                j = 0,
                jj = 0;
              for (j = start; j >= 0;) {
                chkd[j] = true;
                buf[buf.length] = j;
                buf_chain.push(sectors[j]);
                var addr = fat_addrs[Math.floor(j * 4 / ssz)];
                jj = j * 4 & modulus;
                if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
                if (!sectors[addr]) break;
                j = __readInt32LE(sectors[addr], jj);
              }
              return {
                nodes: buf,
                data: __toBuffer([buf_chain])
              };
            }

            /** Chase down the sector linked lists */
            function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
              var sl = sectors.length,
                sector_list = [];
              var chkd = [],
                buf = [],
                buf_chain = [];
              var modulus = ssz - 1,
                i = 0,
                j = 0,
                k = 0,
                jj = 0;
              for (i = 0; i < sl; ++i) {
                buf = [];
                k = i + dir_start;
                if (k >= sl) k -= sl;
                if (chkd[k]) continue;
                buf_chain = [];
                var seen = [];
                for (j = k; j >= 0;) {
                  seen[j] = true;
                  chkd[j] = true;
                  buf[buf.length] = j;
                  buf_chain.push(sectors[j]);
                  var addr = fat_addrs[Math.floor(j * 4 / ssz)];
                  jj = j * 4 & modulus;
                  if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
                  if (!sectors[addr]) break;
                  j = __readInt32LE(sectors[addr], jj);
                  if (seen[j]) break;
                }
                sector_list[k] = {
                  nodes: buf,
                  data: __toBuffer([buf_chain])
                };
              }
              return sector_list;
            }

            /* [MS-CFB] 2.6.1 Compound File Directory Entry */
            function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
              var minifat_store = 0,
                pl = Paths.length ? 2 : 0;
              var sector = sector_list[dir_start].data;
              var i = 0,
                namelen = 0,
                name;
              for (; i < sector.length; i += 128) {
                var blob = sector.slice(i, i + 128);
                prep_blob(blob, 64);
                namelen = blob.read_shift(2);
                name = __utf16le(blob, 0, namelen - pl);
                Paths.push(name);
                var o = {
                  name: name,
                  type: blob.read_shift(1),
                  color: blob.read_shift(1),
                  L: blob.read_shift(4, 'i'),
                  R: blob.read_shift(4, 'i'),
                  C: blob.read_shift(4, 'i'),
                  clsid: blob.read_shift(16),
                  state: blob.read_shift(4, 'i'),
                  start: 0,
                  size: 0
                };
                var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
                if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);
                var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
                if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);
                o.start = blob.read_shift(4, 'i');
                o.size = blob.read_shift(4, 'i');
                if (o.size < 0 && o.start < 0) {
                  o.size = o.type = 0;
                  o.start = ENDOFCHAIN;
                  o.name = "";
                }
                if (o.type === 5) {
                  /* root */
                  minifat_store = o.start;
                  if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
                  /*minifat_size = o.size;*/
                } else if (o.size >= 4096 /* MSCSZ */) {
                  o.storage = 'fat';
                  if (sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
                  sector_list[o.start].name = o.name;
                  o.content = sector_list[o.start].data.slice(0, o.size);
                } else {
                  o.storage = 'minifat';
                  if (o.size < 0) o.size = 0;else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
                    o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
                  }
                }
                if (o.content) prep_blob(o.content, 0);
                files[name] = o;
                FileIndex.push(o);
              }
            }
            function read_date(blob, offset) {
              return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1000);
            }
            function read_file(filename, options) {
              get_fs();
              return parse(fs.readFileSync(filename), options);
            }
            function read(blob, options) {
              var type = options && options.type;
              if (!type) {
                if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
              }
              switch (type || "base64") {
                case "file":
                  return read_file(blob, options);
                case "base64":
                  return parse(s2a(Base64_decode(blob)), options);
                case "binary":
                  return parse(s2a(blob), options);
              }
              return parse(blob, options);
            }
            function init_cfb(cfb, opts) {
              var o = opts || {},
                root = o.root || "Root Entry";
              if (!cfb.FullPaths) cfb.FullPaths = [];
              if (!cfb.FileIndex) cfb.FileIndex = [];
              if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
              if (cfb.FullPaths.length === 0) {
                cfb.FullPaths[0] = root + "/";
                cfb.FileIndex[0] = {
                  name: root,
                  type: 5
                };
              }
              if (o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;
              seed_cfb(cfb);
            }
            function seed_cfb(cfb) {
              var nm = "\x01Sh33tJ5";
              if (CFB.find(cfb, "/" + nm)) return;
              var p = new_buf(4);
              p[0] = 55;
              p[1] = p[3] = 50;
              p[2] = 54;
              cfb.FileIndex.push({
                name: nm,
                type: 2,
                content: p,
                size: 4,
                L: 69,
                R: 69,
                C: 69
              });
              cfb.FullPaths.push(cfb.FullPaths[0] + nm);
              rebuild_cfb(cfb);
            }
            function rebuild_cfb(cfb, f) {
              init_cfb(cfb);
              var gc = false,
                s = false;
              for (var i = cfb.FullPaths.length - 1; i >= 0; --i) {
                var _file = cfb.FileIndex[i];
                switch (_file.type) {
                  case 0:
                    if (s) gc = true;else {
                      cfb.FileIndex.pop();
                      cfb.FullPaths.pop();
                    }
                    break;
                  case 1:
                  case 2:
                  case 5:
                    s = true;
                    if (isNaN(_file.R * _file.L * _file.C)) gc = true;
                    if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
                    break;
                  default:
                    gc = true;
                    break;
                }
              }
              if (!gc && !f) return;
              var now = new Date(1987, 1, 19),
                j = 0;
              // Track which names exist
              var fullPaths = Object.create ? Object.create(null) : {};
              var data = [];
              for (i = 0; i < cfb.FullPaths.length; ++i) {
                fullPaths[cfb.FullPaths[i]] = true;
                if (cfb.FileIndex[i].type === 0) continue;
                data.push([cfb.FullPaths[i], cfb.FileIndex[i]]);
              }
              for (i = 0; i < data.length; ++i) {
                var dad = dirname(data[i][0]);
                s = fullPaths[dad];
                while (!s) {
                  while (dirname(dad) && !fullPaths[dirname(dad)]) {
                    dad = dirname(dad);
                  }
                  data.push([dad, {
                    name: filename(dad).replace("/", ""),
                    type: 1,
                    clsid: HEADER_CLSID,
                    ct: now,
                    mt: now,
                    content: null
                  }]);

                  // Add name to set
                  fullPaths[dad] = true;
                  dad = dirname(data[i][0]);
                  s = fullPaths[dad];
                }
              }
              data.sort(function (x, y) {
                return namecmp(x[0], y[0]);
              });
              cfb.FullPaths = [];
              cfb.FileIndex = [];
              for (i = 0; i < data.length; ++i) {
                cfb.FullPaths[i] = data[i][0];
                cfb.FileIndex[i] = data[i][1];
              }
              for (i = 0; i < data.length; ++i) {
                var elt = cfb.FileIndex[i];
                var nm = cfb.FullPaths[i];
                elt.name = filename(nm).replace("/", "");
                elt.L = elt.R = elt.C = -(elt.color = 1);
                elt.size = elt.content ? elt.content.length : 0;
                elt.start = 0;
                elt.clsid = elt.clsid || HEADER_CLSID;
                if (i === 0) {
                  elt.C = data.length > 1 ? 1 : -1;
                  elt.size = 0;
                  elt.type = 5;
                } else if (nm.slice(-1) == "/") {
                  for (j = i + 1; j < data.length; ++j) {
                    if (dirname(cfb.FullPaths[j]) == nm) break;
                  }
                  elt.C = j >= data.length ? -1 : j;
                  for (j = i + 1; j < data.length; ++j) {
                    if (dirname(cfb.FullPaths[j]) == dirname(nm)) break;
                  }
                  elt.R = j >= data.length ? -1 : j;
                  elt.type = 1;
                } else {
                  if (dirname(cfb.FullPaths[i + 1] || "") == dirname(nm)) elt.R = i + 1;
                  elt.type = 2;
                }
              }
            }
            function _write(cfb, options) {
              var _opts = options || {};
              /* MAD is order-sensitive, skip rebuild and sort */
              if (_opts.fileType == 'mad') return write_mad(cfb, _opts);
              rebuild_cfb(cfb);
              switch (_opts.fileType) {
                case 'zip':
                  return write_zip(cfb, _opts);
                //case 'mad': return write_mad(cfb, _opts);
              }

              var L = function (cfb) {
                var mini_size = 0,
                  fat_size = 0;
                for (var i = 0; i < cfb.FileIndex.length; ++i) {
                  var file = cfb.FileIndex[i];
                  if (!file.content) continue;
                  var flen = file.content.length;
                  if (flen > 0) {
                    if (flen < 0x1000) mini_size += flen + 0x3F >> 6;else fat_size += flen + 0x01FF >> 9;
                  }
                }
                var dir_cnt = cfb.FullPaths.length + 3 >> 2;
                var mini_cnt = mini_size + 7 >> 3;
                var mfat_cnt = mini_size + 0x7F >> 7;
                var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
                var fat_cnt = fat_base + 0x7F >> 7;
                var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 0x7F);
                while (fat_base + fat_cnt + difat_cnt + 0x7F >> 7 > fat_cnt) {
                  difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 0x7F);
                }
                var L = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
                cfb.FileIndex[0].size = mini_size << 6;
                L[7] = (cfb.FileIndex[0].start = L[0] + L[1] + L[2] + L[3] + L[4] + L[5]) + (L[6] + 7 >> 3);
                return L;
              }(cfb);
              var o = new_buf(L[7] << 9);
              var i = 0,
                T = 0;
              {
                for (i = 0; i < 8; ++i) {
                  o.write_shift(1, HEADER_SIG[i]);
                }
                for (i = 0; i < 8; ++i) {
                  o.write_shift(2, 0);
                }
                o.write_shift(2, 0x003E);
                o.write_shift(2, 0x0003);
                o.write_shift(2, 0xFFFE);
                o.write_shift(2, 0x0009);
                o.write_shift(2, 0x0006);
                for (i = 0; i < 3; ++i) {
                  o.write_shift(2, 0);
                }
                o.write_shift(4, 0);
                o.write_shift(4, L[2]);
                o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
                o.write_shift(4, 0);
                o.write_shift(4, 1 << 12);
                o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
                o.write_shift(4, L[3]);
                o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
                o.write_shift(4, L[1]);
                for (i = 0; i < 109; ++i) {
                  o.write_shift(-4, i < L[2] ? L[1] + i : -1);
                }
              }
              if (L[1]) {
                for (T = 0; T < L[1]; ++T) {
                  for (; i < 236 + T * 127; ++i) {
                    o.write_shift(-4, i < L[2] ? L[1] + i : -1);
                  }
                  o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
                }
              }
              var chainit = function chainit(w) {
                for (T += w; i < T - 1; ++i) {
                  o.write_shift(-4, i + 1);
                }
                if (w) {
                  ++i;
                  o.write_shift(-4, ENDOFCHAIN);
                }
              };
              T = i = 0;
              for (T += L[1]; i < T; ++i) {
                o.write_shift(-4, consts.DIFSECT);
              }
              for (T += L[2]; i < T; ++i) {
                o.write_shift(-4, consts.FATSECT);
              }
              chainit(L[3]);
              chainit(L[4]);
              var j = 0,
                flen = 0;
              var file = cfb.FileIndex[0];
              for (; j < cfb.FileIndex.length; ++j) {
                file = cfb.FileIndex[j];
                if (!file.content) continue;
                flen = file.content.length;
                if (flen < 0x1000) continue;
                file.start = T;
                chainit(flen + 0x01FF >> 9);
              }
              chainit(L[6] + 7 >> 3);
              while (o.l & 0x1FF) {
                o.write_shift(-4, consts.ENDOFCHAIN);
              }
              T = i = 0;
              for (j = 0; j < cfb.FileIndex.length; ++j) {
                file = cfb.FileIndex[j];
                if (!file.content) continue;
                flen = file.content.length;
                if (!flen || flen >= 0x1000) continue;
                file.start = T;
                chainit(flen + 0x3F >> 6);
              }
              while (o.l & 0x1FF) {
                o.write_shift(-4, consts.ENDOFCHAIN);
              }
              for (i = 0; i < L[4] << 2; ++i) {
                var nm = cfb.FullPaths[i];
                if (!nm || nm.length === 0) {
                  for (j = 0; j < 17; ++j) {
                    o.write_shift(4, 0);
                  }
                  for (j = 0; j < 3; ++j) {
                    o.write_shift(4, -1);
                  }
                  for (j = 0; j < 12; ++j) {
                    o.write_shift(4, 0);
                  }
                  continue;
                }
                file = cfb.FileIndex[i];
                if (i === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
                var _nm = i === 0 && _opts.root || file.name;
                if (_nm.length > 32) {
                  console.error("Name " + _nm + " will be truncated to " + _nm.slice(0, 32));
                  _nm = _nm.slice(0, 32);
                }
                flen = 2 * (_nm.length + 1);
                o.write_shift(64, _nm, "utf16le");
                o.write_shift(2, flen);
                o.write_shift(1, file.type);
                o.write_shift(1, file.color);
                o.write_shift(-4, file.L);
                o.write_shift(-4, file.R);
                o.write_shift(-4, file.C);
                if (!file.clsid) for (j = 0; j < 4; ++j) {
                  o.write_shift(4, 0);
                } else o.write_shift(16, file.clsid, "hex");
                o.write_shift(4, file.state || 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, 0);
                o.write_shift(4, file.start);
                o.write_shift(4, file.size);
                o.write_shift(4, 0);
              }
              for (i = 1; i < cfb.FileIndex.length; ++i) {
                file = cfb.FileIndex[i];
                if (file.size >= 0x1000) {
                  o.l = file.start + 1 << 9;
                  if (has_buf && Buffer.isBuffer(file.content)) {
                    file.content.copy(o, o.l, 0, file.size);
                    // o is a 0-filled Buffer so just set next offset
                    o.l += file.size + 511 & -512;
                  } else {
                    for (j = 0; j < file.size; ++j) {
                      o.write_shift(1, file.content[j]);
                    }
                    for (; j & 0x1FF; ++j) {
                      o.write_shift(1, 0);
                    }
                  }
                }
              }
              for (i = 1; i < cfb.FileIndex.length; ++i) {
                file = cfb.FileIndex[i];
                if (file.size > 0 && file.size < 0x1000) {
                  if (has_buf && Buffer.isBuffer(file.content)) {
                    file.content.copy(o, o.l, 0, file.size);
                    // o is a 0-filled Buffer so just set next offset
                    o.l += file.size + 63 & -64;
                  } else {
                    for (j = 0; j < file.size; ++j) {
                      o.write_shift(1, file.content[j]);
                    }
                    for (; j & 0x3F; ++j) {
                      o.write_shift(1, 0);
                    }
                  }
                }
              }
              if (has_buf) {
                o.l = o.length;
              } else {
                // When using Buffer, already 0-filled
                while (o.l < o.length) {
                  o.write_shift(1, 0);
                }
              }
              return o;
            }
            /* [MS-CFB] 2.6.4 (Unicode 3.0.1 case conversion) */
            function find(cfb, path) {
              var UCFullPaths = cfb.FullPaths.map(function (x) {
                return x.toUpperCase();
              });
              var UCPaths = UCFullPaths.map(function (x) {
                var y = x.split("/");
                return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
              });
              var k = false;
              if (path.charCodeAt(0) === 47 /* "/" */) {
                k = true;
                path = UCFullPaths[0].slice(0, -1) + path;
              } else k = path.indexOf("/") !== -1;
              var UCPath = path.toUpperCase();
              var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
              if (w !== -1) return cfb.FileIndex[w];
              var m = !UCPath.match(chr1);
              UCPath = UCPath.replace(chr0, '');
              if (m) UCPath = UCPath.replace(chr1, '!');
              for (w = 0; w < UCFullPaths.length; ++w) {
                if ((m ? UCFullPaths[w].replace(chr1, '!') : UCFullPaths[w]).replace(chr0, '') == UCPath) return cfb.FileIndex[w];
                if ((m ? UCPaths[w].replace(chr1, '!') : UCPaths[w]).replace(chr0, '') == UCPath) return cfb.FileIndex[w];
              }
              return null;
            }
            /** CFB Constants */
            var MSSZ = 64; /* Mini Sector Size = 1<<6 */
            //var MSCSZ = 4096; /* Mini Stream Cutoff Size */
            /* 2.1 Compound File Sector Numbers and Types */
            var ENDOFCHAIN = -2;
            /* 2.2 Compound File Header */
            var HEADER_SIGNATURE = 'd0cf11e0a1b11ae1';
            var HEADER_SIG = [0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];
            var HEADER_CLSID = '00000000000000000000000000000000';
            var consts = {
              /* 2.1 Compund File Sector Numbers and Types */
              MAXREGSECT: -6,
              DIFSECT: -4,
              FATSECT: -3,
              ENDOFCHAIN: ENDOFCHAIN,
              FREESECT: -1,
              /* 2.2 Compound File Header */
              HEADER_SIGNATURE: HEADER_SIGNATURE,
              HEADER_MINOR_VERSION: '3e00',
              MAXREGSID: -6,
              NOSTREAM: -1,
              HEADER_CLSID: HEADER_CLSID,
              /* 2.6.1 Compound File Directory Entry */
              EntryTypes: ['unknown', 'storage', 'stream', 'lockbytes', 'property', 'root']
            };
            function write_file(cfb, filename, options) {
              get_fs();
              var o = _write(cfb, options);
              fs.writeFileSync(filename, o);
            }
            function a2s(o) {
              var out = new Array(o.length);
              for (var i = 0; i < o.length; ++i) {
                out[i] = String.fromCharCode(o[i]);
              }
              return out.join("");
            }
            function write(cfb, options) {
              var o = _write(cfb, options);
              switch (options && options.type || "buffer") {
                case "file":
                  get_fs();
                  fs.writeFileSync(options.filename, o);
                  return o;
                case "binary":
                  return typeof o == "string" ? o : a2s(o);
                case "base64":
                  return Base64_encode(typeof o == "string" ? o : a2s(o));
                case "buffer":
                  if (has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);
                /* falls through */
                case "array":
                  return typeof o == "string" ? s2a(o) : o;
              }
              return o;
            }
            /* node < 8.1 zlib does not expose bytesRead, so default to pure JS */
            var _zlib;
            function use_zlib(zlib) {
              try {
                var InflateRaw = zlib.InflateRaw;
                var InflRaw = new InflateRaw();
                InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
                if (InflRaw.bytesRead) _zlib = zlib;else throw new Error("zlib does not expose bytesRead");
              } catch (e) {
                console.error("cannot use native zlib: " + (e.message || e));
              }
            }
            function _inflateRawSync(payload, usz) {
              if (!_zlib) return _inflate(payload, usz);
              var InflateRaw = _zlib.InflateRaw;
              var InflRaw = new InflateRaw();
              var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
              payload.l += InflRaw.bytesRead;
              return out;
            }
            function _deflateRawSync(payload) {
              return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
            }
            var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

            /*  LEN_ID = [ 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285 ]; */
            var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];

            /*  DST_ID = [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  14,  15,  16,  17,  18,  19,   20,   21,   22,   23,   24,   25,   26,    27,    28,    29 ]; */
            var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
            function bit_swap_8(n) {
              var t = (n << 1 | n << 11) & 0x22110 | (n << 5 | n << 15) & 0x88440;
              return (t >> 16 | t >> 8 | t) & 0xFF;
            }
            var use_typed_arrays = typeof Uint8Array !== 'undefined';
            var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
            for (var q = 0; q < 1 << 8; ++q) {
              bitswap8[q] = bit_swap_8(q);
            }
            function bit_swap_n(n, b) {
              var rev = bitswap8[n & 0xFF];
              if (b <= 8) return rev >>> 8 - b;
              rev = rev << 8 | bitswap8[n >> 8 & 0xFF];
              if (b <= 16) return rev >>> 16 - b;
              rev = rev << 8 | bitswap8[n >> 16 & 0xFF];
              return rev >>> 24 - b;
            }

            /* helpers for unaligned bit reads */
            function read_bits_2(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 0x03;
            }
            function read_bits_3(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 0x07;
            }
            function read_bits_4(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 0x0F;
            }
            function read_bits_5(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 0x1F;
            }
            function read_bits_7(buf, bl) {
              var w = bl & 7,
                h = bl >>> 3;
              return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 0x7F;
            }

            /* works up to n = 3 * 8 + 1 = 25 */
            function read_bits_n(buf, bl, n) {
              var w = bl & 7,
                h = bl >>> 3,
                f = (1 << n) - 1;
              var v = buf[h] >>> w;
              if (n < 8 - w) return v & f;
              v |= buf[h + 1] << 8 - w;
              if (n < 16 - w) return v & f;
              v |= buf[h + 2] << 16 - w;
              if (n < 24 - w) return v & f;
              v |= buf[h + 3] << 24 - w;
              return v & f;
            }

            /* helpers for unaligned bit writes */
            function write_bits_3(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              if (w <= 5) buf[h] |= (v & 7) << w;else {
                buf[h] |= v << w & 0xFF;
                buf[h + 1] = (v & 7) >> 8 - w;
              }
              return bl + 3;
            }
            function write_bits_1(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              v = (v & 1) << w;
              buf[h] |= v;
              return bl + 1;
            }
            function write_bits_8(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              v <<= w;
              buf[h] |= v & 0xFF;
              v >>>= 8;
              buf[h + 1] = v;
              return bl + 8;
            }
            function write_bits_16(buf, bl, v) {
              var w = bl & 7,
                h = bl >>> 3;
              v <<= w;
              buf[h] |= v & 0xFF;
              v >>>= 8;
              buf[h + 1] = v & 0xFF;
              buf[h + 2] = v >>> 8;
              return bl + 16;
            }

            /* until ArrayBuffer#realloc is a thing, fake a realloc */
            function realloc(b, sz) {
              var L = b.length,
                M = 2 * L > sz ? 2 * L : sz + 5,
                i = 0;
              if (L >= sz) return b;
              if (has_buf) {
                var o = new_unsafe_buf(M);
                // $FlowIgnore
                if (b.copy) b.copy(o);else for (; i < b.length; ++i) {
                  o[i] = b[i];
                }
                return o;
              } else if (use_typed_arrays) {
                var a = new Uint8Array(M);
                if (a.set) a.set(b);else for (; i < L; ++i) {
                  a[i] = b[i];
                }
                return a;
              }
              b.length = M;
              return b;
            }

            /* zero-filled arrays for older browsers */
            function zero_fill_array(n) {
              var o = new Array(n);
              for (var i = 0; i < n; ++i) {
                o[i] = 0;
              }
              return o;
            }

            /* build tree (used for literals and lengths) */
            function build_tree(clens, cmap, MAX) {
              var maxlen = 1,
                w = 0,
                i = 0,
                j = 0,
                ccode = 0,
                L = clens.length;
              var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
              for (i = 0; i < 32; ++i) {
                bl_count[i] = 0;
              }
              for (i = L; i < MAX; ++i) {
                clens[i] = 0;
              }
              L = clens.length;
              var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L); // []

              /* build code tree */
              for (i = 0; i < L; ++i) {
                bl_count[w = clens[i]]++;
                if (maxlen < w) maxlen = w;
                ctree[i] = 0;
              }
              bl_count[0] = 0;
              for (i = 1; i <= maxlen; ++i) {
                bl_count[i + 16] = ccode = ccode + bl_count[i - 1] << 1;
              }
              for (i = 0; i < L; ++i) {
                ccode = clens[i];
                if (ccode != 0) ctree[i] = bl_count[ccode + 16]++;
              }

              /* cmap[maxlen + 4 bits] = (off&15) + (lit<<4) reverse mapping */
              var cleni = 0;
              for (i = 0; i < L; ++i) {
                cleni = clens[i];
                if (cleni != 0) {
                  ccode = bit_swap_n(ctree[i], maxlen) >> maxlen - cleni;
                  for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j) {
                    cmap[ccode | j << cleni] = cleni & 15 | i << 4;
                  }
                }
              }
              return maxlen;
            }

            /* Fixed Huffman */
            var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
            var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
            if (!use_typed_arrays) {
              for (var i = 0; i < 512; ++i) {
                fix_lmap[i] = 0;
              }
              for (i = 0; i < 32; ++i) {
                fix_dmap[i] = 0;
              }
            }
            (function () {
              var dlens = [];
              var i = 0;
              for (; i < 32; i++) {
                dlens.push(5);
              }
              build_tree(dlens, fix_dmap, 32);
              var clens = [];
              i = 0;
              for (; i <= 143; i++) {
                clens.push(8);
              }
              for (; i <= 255; i++) {
                clens.push(9);
              }
              for (; i <= 279; i++) {
                clens.push(7);
              }
              for (; i <= 287; i++) {
                clens.push(8);
              }
              build_tree(clens, fix_lmap, 288);
            })();
            var _deflateRaw = function _deflateRawIIFE() {
              var DST_LN_RE = use_typed_arrays ? new Uint8Array(0x8000) : [];
              var j = 0,
                k = 0;
              for (; j < DST_LN.length - 1; ++j) {
                for (; k < DST_LN[j + 1]; ++k) {
                  DST_LN_RE[k] = j;
                }
              }
              for (; k < 32768; ++k) {
                DST_LN_RE[k] = 29;
              }
              var LEN_LN_RE = use_typed_arrays ? new Uint8Array(0x103) : [];
              for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
                for (; k < LEN_LN[j + 1]; ++k) {
                  LEN_LN_RE[k] = j;
                }
              }
              function write_stored(data, out) {
                var boff = 0;
                while (boff < data.length) {
                  var L = Math.min(0xFFFF, data.length - boff);
                  var h = boff + L == data.length;
                  out.write_shift(1, +h);
                  out.write_shift(2, L);
                  out.write_shift(2, ~L & 0xFFFF);
                  while (L-- > 0) {
                    out[out.l++] = data[boff++];
                  }
                }
                return out.l;
              }

              /* Fixed Huffman */
              function write_huff_fixed(data, out) {
                var bl = 0;
                var boff = 0;
                var addrs = use_typed_arrays ? new Uint16Array(0x8000) : [];
                while (boff < data.length) {
                  var L = /* data.length - boff; */Math.min(0xFFFF, data.length - boff);

                  /* write a stored block for short data */
                  if (L < 10) {
                    bl = write_bits_3(out, bl, +!!(boff + L == data.length)); // jshint ignore:line
                    if (bl & 7) bl += 8 - (bl & 7);
                    out.l = bl / 8 | 0;
                    out.write_shift(2, L);
                    out.write_shift(2, ~L & 0xFFFF);
                    while (L-- > 0) {
                      out[out.l++] = data[boff++];
                    }
                    bl = out.l * 8;
                    continue;
                  }
                  bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2); // jshint ignore:line
                  var hash = 0;
                  while (L-- > 0) {
                    var d = data[boff];
                    hash = (hash << 5 ^ d) & 0x7FFF;
                    var match = -1,
                      mlen = 0;
                    if (match = addrs[hash]) {
                      match |= boff & ~0x7FFF;
                      if (match > boff) match -= 0x8000;
                      if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) {
                        ++mlen;
                      }
                    }
                    if (mlen > 2) {
                      /* Copy Token  */
                      d = LEN_LN_RE[mlen];
                      if (d <= 22) bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;else {
                        write_bits_8(out, bl, 3);
                        bl += 5;
                        write_bits_8(out, bl, bitswap8[d - 23] >> 5);
                        bl += 3;
                      }
                      var len_eb = d < 8 ? 0 : d - 4 >> 2;
                      if (len_eb > 0) {
                        write_bits_16(out, bl, mlen - LEN_LN[d]);
                        bl += len_eb;
                      }
                      d = DST_LN_RE[boff - match];
                      bl = write_bits_8(out, bl, bitswap8[d] >> 3);
                      bl -= 3;
                      var dst_eb = d < 4 ? 0 : d - 2 >> 1;
                      if (dst_eb > 0) {
                        write_bits_16(out, bl, boff - match - DST_LN[d]);
                        bl += dst_eb;
                      }
                      for (var q = 0; q < mlen; ++q) {
                        addrs[hash] = boff & 0x7FFF;
                        hash = (hash << 5 ^ data[boff]) & 0x7FFF;
                        ++boff;
                      }
                      L -= mlen - 1;
                    } else {
                      /* Literal Token */
                      if (d <= 143) d = d + 48;else bl = write_bits_1(out, bl, 1);
                      bl = write_bits_8(out, bl, bitswap8[d]);
                      addrs[hash] = boff & 0x7FFF;
                      ++boff;
                    }
                  }
                  bl = write_bits_8(out, bl, 0) - 1;
                }
                out.l = (bl + 7) / 8 | 0;
                return out.l;
              }
              return function _deflateRaw(data, out) {
                if (data.length < 8) return write_stored(data, out);
                return write_huff_fixed(data, out);
              };
            }();
            function _deflate(data) {
              var buf = new_buf(50 + Math.floor(data.length * 1.1));
              var off = _deflateRaw(data, buf);
              return buf.slice(0, off);
            }
            /* modified inflate function also moves original read head */

            var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
            var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
            var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
            var dyn_len_1 = 1,
              dyn_len_2 = 1;

            /* 5.5.3 Expanding Huffman Codes */
            function dyn(data, boff) {
              /* nomenclature from RFC1951 refers to bit values; these are offset by the implicit constant */
              var _HLIT = read_bits_5(data, boff) + 257;
              boff += 5;
              var _HDIST = read_bits_5(data, boff) + 1;
              boff += 5;
              var _HCLEN = read_bits_4(data, boff) + 4;
              boff += 4;
              var w = 0;

              /* grab and store code lengths */
              var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
              var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              var maxlen = 1;
              var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
              var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
              var L = clens.length; /* 19 */
              for (var i = 0; i < _HCLEN; ++i) {
                clens[CLEN_ORDER[i]] = w = read_bits_3(data, boff);
                if (maxlen < w) maxlen = w;
                bl_count[w]++;
                boff += 3;
              }

              /* build code tree */
              var ccode = 0;
              bl_count[0] = 0;
              for (i = 1; i <= maxlen; ++i) {
                next_code[i] = ccode = ccode + bl_count[i - 1] << 1;
              }
              for (i = 0; i < L; ++i) {
                if ((ccode = clens[i]) != 0) ctree[i] = next_code[ccode]++;
              }
              /* cmap[7 bits from stream] = (off&7) + (lit<<3) */
              var cleni = 0;
              for (i = 0; i < L; ++i) {
                cleni = clens[i];
                if (cleni != 0) {
                  ccode = bitswap8[ctree[i]] >> 8 - cleni;
                  for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) {
                    dyn_cmap[ccode | j << cleni] = cleni & 7 | i << 3;
                  }
                }
              }

              /* read literal and dist codes at once */
              var hcodes = [];
              maxlen = 1;
              for (; hcodes.length < _HLIT + _HDIST;) {
                ccode = dyn_cmap[read_bits_7(data, boff)];
                boff += ccode & 7;
                switch (ccode >>>= 3) {
                  case 16:
                    w = 3 + read_bits_2(data, boff);
                    boff += 2;
                    ccode = hcodes[hcodes.length - 1];
                    while (w-- > 0) {
                      hcodes.push(ccode);
                    }
                    break;
                  case 17:
                    w = 3 + read_bits_3(data, boff);
                    boff += 3;
                    while (w-- > 0) {
                      hcodes.push(0);
                    }
                    break;
                  case 18:
                    w = 11 + read_bits_7(data, boff);
                    boff += 7;
                    while (w-- > 0) {
                      hcodes.push(0);
                    }
                    break;
                  default:
                    hcodes.push(ccode);
                    if (maxlen < ccode) maxlen = ccode;
                    break;
                }
              }

              /* build literal / length trees */
              var h1 = hcodes.slice(0, _HLIT),
                h2 = hcodes.slice(_HLIT);
              for (i = _HLIT; i < 286; ++i) {
                h1[i] = 0;
              }
              for (i = _HDIST; i < 30; ++i) {
                h2[i] = 0;
              }
              dyn_len_1 = build_tree(h1, dyn_lmap, 286);
              dyn_len_2 = build_tree(h2, dyn_dmap, 30);
              return boff;
            }

            /* return [ data, bytesRead ] */
            function inflate(data, usz) {
              /* shortcircuit for empty buffer [0x03, 0x00] */
              if (data[0] == 3 && !(data[1] & 0x3)) {
                return [new_raw_buf(usz), 2];
              }

              /* bit offset */
              var boff = 0;

              /* header includes final bit and type bits */
              var header = 0;
              var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
              var woff = 0;
              var OL = outbuf.length >>> 0;
              var max_len_1 = 0,
                max_len_2 = 0;
              while ((header & 1) == 0) {
                header = read_bits_3(data, boff);
                boff += 3;
                if (header >>> 1 == 0) {
                  /* Stored block */
                  if (boff & 7) boff += 8 - (boff & 7);
                  /* 2 bytes sz, 2 bytes bit inverse */
                  var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
                  boff += 32;
                  /* push sz bytes */
                  if (sz > 0) {
                    if (!usz && OL < woff + sz) {
                      outbuf = realloc(outbuf, woff + sz);
                      OL = outbuf.length;
                    }
                    while (sz-- > 0) {
                      outbuf[woff++] = data[boff >>> 3];
                      boff += 8;
                    }
                  }
                  continue;
                } else if (header >> 1 == 1) {
                  /* Fixed Huffman */
                  max_len_1 = 9;
                  max_len_2 = 5;
                } else {
                  /* Dynamic Huffman */
                  boff = dyn(data, boff);
                  max_len_1 = dyn_len_1;
                  max_len_2 = dyn_len_2;
                }
                for (;;) {
                  // while(true) is apparently out of vogue in modern JS circles
                  if (!usz && OL < woff + 32767) {
                    outbuf = realloc(outbuf, woff + 32767);
                    OL = outbuf.length;
                  }
                  /* ingest code and move read head */
                  var bits = read_bits_n(data, boff, max_len_1);
                  var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
                  boff += code & 15;
                  code >>>= 4;
                  /* 0-255 are literals, 256 is end of block token, 257+ are copy tokens */
                  if ((code >>> 8 & 0xFF) === 0) outbuf[woff++] = code;else if (code == 256) break;else {
                    code -= 257;
                    var len_eb = code < 8 ? 0 : code - 4 >> 2;
                    if (len_eb > 5) len_eb = 0;
                    var tgt = woff + LEN_LN[code];
                    /* length extra bits */
                    if (len_eb > 0) {
                      tgt += read_bits_n(data, boff, len_eb);
                      boff += len_eb;
                    }

                    /* dist code */
                    bits = read_bits_n(data, boff, max_len_2);
                    code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
                    boff += code & 15;
                    code >>>= 4;
                    var dst_eb = code < 4 ? 0 : code - 2 >> 1;
                    var dst = DST_LN[code];
                    /* dist extra bits */
                    if (dst_eb > 0) {
                      dst += read_bits_n(data, boff, dst_eb);
                      boff += dst_eb;
                    }

                    /* in the common case, manual byte copy is faster than TA set / Buffer copy */
                    if (!usz && OL < tgt) {
                      outbuf = realloc(outbuf, tgt + 100);
                      OL = outbuf.length;
                    }
                    while (woff < tgt) {
                      outbuf[woff] = outbuf[woff - dst];
                      ++woff;
                    }
                  }
                }
              }
              if (usz) return [outbuf, boff + 7 >>> 3];
              return [outbuf.slice(0, woff), boff + 7 >>> 3];
            }
            function _inflate(payload, usz) {
              var data = payload.slice(payload.l || 0);
              var out = inflate(data, usz);
              payload.l += out[1];
              return out[0];
            }
            function warn_or_throw(wrn, msg) {
              if (wrn) {
                if (typeof console !== 'undefined') console.error(msg);
              } else throw new Error(msg);
            }
            function parse_zip(file, options) {
              var blob = file;
              prep_blob(blob, 0);
              var FileIndex = [],
                FullPaths = [];
              var o = {
                FileIndex: FileIndex,
                FullPaths: FullPaths
              };
              init_cfb(o, {
                root: options.root
              });

              /* find end of central directory, start just after signature */
              var i = blob.length - 4;
              while ((blob[i] != 0x50 || blob[i + 1] != 0x4b || blob[i + 2] != 0x05 || blob[i + 3] != 0x06) && i >= 0) {
                --i;
              }
              blob.l = i + 4;

              /* parse end of central directory */
              blob.l += 4;
              var fcnt = blob.read_shift(2);
              blob.l += 6;
              var start_cd = blob.read_shift(4);

              /* parse central directory */
              blob.l = start_cd;
              for (i = 0; i < fcnt; ++i) {
                /* trust local file header instead of CD entry */
                blob.l += 20;
                var csz = blob.read_shift(4);
                var usz = blob.read_shift(4);
                var namelen = blob.read_shift(2);
                var efsz = blob.read_shift(2);
                var fcsz = blob.read_shift(2);
                blob.l += 8;
                var offset = blob.read_shift(4);
                var EF = parse_extra_field(blob.slice(blob.l + namelen, blob.l + namelen + efsz));
                blob.l += namelen + efsz + fcsz;
                var L = blob.l;
                blob.l = offset + 4;
                parse_local_file(blob, csz, usz, o, EF);
                blob.l = L;
              }
              return o;
            }

            /* head starts just after local file header signature */
            function parse_local_file(blob, csz, usz, o, EF) {
              /* [local file header] */
              blob.l += 2;
              var flags = blob.read_shift(2);
              var meth = blob.read_shift(2);
              var date = parse_dos_date(blob);
              if (flags & 0x2041) throw new Error("Unsupported ZIP encryption");
              var crc32 = blob.read_shift(4);
              var _csz = blob.read_shift(4);
              var _usz = blob.read_shift(4);
              var namelen = blob.read_shift(2);
              var efsz = blob.read_shift(2);

              // TODO: flags & (1<<11) // UTF8
              var name = "";
              for (var i = 0; i < namelen; ++i) {
                name += String.fromCharCode(blob[blob.l++]);
              }
              if (efsz) {
                var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));
                if ((ef[0x5455] || {}).mt) date = ef[0x5455].mt;
                if (((EF || {})[0x5455] || {}).mt) date = EF[0x5455].mt;
              }
              blob.l += efsz;

              /* [encryption header] */

              /* [file data] */
              var data = blob.slice(blob.l, blob.l + _csz);
              switch (meth) {
                case 8:
                  data = _inflateRawSync(blob, _usz);
                  break;
                case 0:
                  break;
                // TODO: scan for magic number
                default:
                  throw new Error("Unsupported ZIP Compression method " + meth);
              }

              /* [data descriptor] */
              var wrn = false;
              if (flags & 8) {
                crc32 = blob.read_shift(4);
                if (crc32 == 0x08074b50) {
                  crc32 = blob.read_shift(4);
                  wrn = true;
                }
                _csz = blob.read_shift(4);
                _usz = blob.read_shift(4);
              }
              if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
              if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
              var _crc32 = CRC32.buf(data, 0);
              if (crc32 >> 0 != _crc32 >> 0) warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);
              cfb_add(o, name, data, {
                unsafe: true,
                mt: date
              });
            }
            function write_zip(cfb, options) {
              var _opts = options || {};
              var out = [],
                cdirs = [];
              var o = new_buf(1);
              var method = _opts.compression ? 8 : 0,
                flags = 0;
              var desc = false;
              if (desc) flags |= 8;
              var i = 0,
                j = 0;
              var start_cd = 0,
                fcnt = 0;
              var root = cfb.FullPaths[0],
                fp = root,
                fi = cfb.FileIndex[0];
              var crcs = [];
              var sz_cd = 0;
              for (i = 1; i < cfb.FullPaths.length; ++i) {
                fp = cfb.FullPaths[i].slice(root.length);
                fi = cfb.FileIndex[i];
                if (!fi.size || !fi.content || fp == "\x01Sh33tJ5") continue;
                var start = start_cd;

                /* TODO: CP437 filename */
                var namebuf = new_buf(fp.length);
                for (j = 0; j < fp.length; ++j) {
                  namebuf.write_shift(1, fp.charCodeAt(j) & 0x7F);
                }
                namebuf = namebuf.slice(0, namebuf.l);
                crcs[fcnt] = CRC32.buf(fi.content, 0);
                var outbuf = fi.content;
                if (method == 8) outbuf = _deflateRawSync(outbuf);

                /* local file header */
                o = new_buf(30);
                o.write_shift(4, 0x04034b50);
                o.write_shift(2, 20);
                o.write_shift(2, flags);
                o.write_shift(2, method);
                /* TODO: last mod file time/date */
                if (fi.mt) write_dos_date(o, fi.mt);else o.write_shift(4, 0);
                o.write_shift(-4, flags & 8 ? 0 : crcs[fcnt]);
                o.write_shift(4, flags & 8 ? 0 : outbuf.length);
                o.write_shift(4, flags & 8 ? 0 : fi.content.length);
                o.write_shift(2, namebuf.length);
                o.write_shift(2, 0);
                start_cd += o.length;
                out.push(o);
                start_cd += namebuf.length;
                out.push(namebuf);

                /* TODO: extra fields? */

                /* TODO: encryption header ? */

                start_cd += outbuf.length;
                out.push(outbuf);

                /* data descriptor */
                if (flags & 8) {
                  o = new_buf(12);
                  o.write_shift(-4, crcs[fcnt]);
                  o.write_shift(4, outbuf.length);
                  o.write_shift(4, fi.content.length);
                  start_cd += o.l;
                  out.push(o);
                }

                /* central directory */
                o = new_buf(46);
                o.write_shift(4, 0x02014b50);
                o.write_shift(2, 0);
                o.write_shift(2, 20);
                o.write_shift(2, flags);
                o.write_shift(2, method);
                o.write_shift(4, 0); /* TODO: last mod file time/date */
                o.write_shift(-4, crcs[fcnt]);
                o.write_shift(4, outbuf.length);
                o.write_shift(4, fi.content.length);
                o.write_shift(2, namebuf.length);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(2, 0);
                o.write_shift(4, 0);
                o.write_shift(4, start);
                sz_cd += o.l;
                cdirs.push(o);
                sz_cd += namebuf.length;
                cdirs.push(namebuf);
                ++fcnt;
              }

              /* end of central directory */
              o = new_buf(22);
              o.write_shift(4, 0x06054b50);
              o.write_shift(2, 0);
              o.write_shift(2, 0);
              o.write_shift(2, fcnt);
              o.write_shift(2, fcnt);
              o.write_shift(4, sz_cd);
              o.write_shift(4, start_cd);
              o.write_shift(2, 0);
              return bconcat([bconcat(out), bconcat(cdirs), o]);
            }
            var ContentTypeMap = {
              "htm": "text/html",
              "xml": "text/xml",
              "gif": "image/gif",
              "jpg": "image/jpeg",
              "png": "image/png",
              "mso": "application/x-mso",
              "thmx": "application/vnd.ms-officetheme",
              "sh33tj5": "application/octet-stream"
            };
            function get_content_type(fi, fp) {
              if (fi.ctype) return fi.ctype;
              var ext = fi.name || "",
                m = ext.match(/\.([^\.]+)$/);
              if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
              if (fp) {
                m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
                if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
              }
              return "application/octet-stream";
            }

            /* 76 character chunks TODO: intertwine encoding */
            function write_base64_76(bstr) {
              var data = Base64_encode(bstr);
              var o = [];
              for (var i = 0; i < data.length; i += 76) {
                o.push(data.slice(i, i + 76));
              }
              return o.join("\r\n") + "\r\n";
            }

            /*
            Rules for QP:
            	- escape =## applies for all non-display characters and literal "="
            	- space or tab at end of line must be encoded
            	- \r\n newlines can be preserved, but bare \r and \n must be escaped
            	- lines must not exceed 76 characters, use soft breaks =\r\n
            
            TODO: Some files from word appear to write line extensions with bare equals:
            
            ```
            <table class=3DMsoTableGrid border=3D1 cellspacing=3D0 cellpadding=3D0 width=
            ="70%"
            ```
            */
            function write_quoted_printable(text) {
              var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function (c) {
                var w = c.charCodeAt(0).toString(16).toUpperCase();
                return "=" + (w.length == 1 ? "0" + w : w);
              });
              encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
              if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
              encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
              var o = [],
                split = encoded.split("\r\n");
              for (var si = 0; si < split.length; ++si) {
                var str = split[si];
                if (str.length == 0) {
                  o.push("");
                  continue;
                }
                for (var i = 0; i < str.length;) {
                  var end = 76;
                  var tmp = str.slice(i, i + end);
                  if (tmp.charAt(end - 1) == "=") end--;else if (tmp.charAt(end - 2) == "=") end -= 2;else if (tmp.charAt(end - 3) == "=") end -= 3;
                  tmp = str.slice(i, i + end);
                  i += end;
                  if (i < str.length) tmp += "=";
                  o.push(tmp);
                }
              }
              return o.join("\r\n");
            }
            function parse_quoted_printable(data) {
              var o = [];

              /* unify long lines */
              for (var di = 0; di < data.length; ++di) {
                var line = data[di];
                while (di <= data.length && line.charAt(line.length - 1) == "=") {
                  line = line.slice(0, line.length - 1) + data[++di];
                }
                o.push(line);
              }

              /* decode */
              for (var oi = 0; oi < o.length; ++oi) {
                o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function ($$) {
                  return String.fromCharCode(parseInt($$.slice(1), 16));
                });
              }
              return s2a(o.join("\r\n"));
            }
            function parse_mime(cfb, data, root) {
              var fname = "",
                cte = "",
                ctype = "",
                fdata;
              var di = 0;
              for (; di < 10; ++di) {
                var line = data[di];
                if (!line || line.match(/^\s*$/)) break;
                var m = line.match(/^(.*?):\s*([^\s].*)$/);
                if (m) switch (m[1].toLowerCase()) {
                  case "content-location":
                    fname = m[2].trim();
                    break;
                  case "content-type":
                    ctype = m[2].trim();
                    break;
                  case "content-transfer-encoding":
                    cte = m[2].trim();
                    break;
                }
              }
              ++di;
              switch (cte.toLowerCase()) {
                case 'base64':
                  fdata = s2a(Base64_decode(data.slice(di).join("")));
                  break;
                case 'quoted-printable':
                  fdata = parse_quoted_printable(data.slice(di));
                  break;
                default:
                  throw new Error("Unsupported Content-Transfer-Encoding " + cte);
              }
              var file = cfb_add(cfb, fname.slice(root.length), fdata, {
                unsafe: true
              });
              if (ctype) file.ctype = ctype;
            }
            function parse_mad(file, options) {
              if (a2s(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
              var root = options && options.root || "";
              // $FlowIgnore
              var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s(file)).split("\r\n");
              var di = 0,
                row = "";

              /* if root is not specified, scan for the common prefix */
              for (di = 0; di < data.length; ++di) {
                row = data[di];
                if (!/^Content-Location:/i.test(row)) continue;
                row = row.slice(row.indexOf("file"));
                if (!root) root = row.slice(0, row.lastIndexOf("/") + 1);
                if (row.slice(0, root.length) == root) continue;
                while (root.length > 0) {
                  root = root.slice(0, root.length - 1);
                  root = root.slice(0, root.lastIndexOf("/") + 1);
                  if (row.slice(0, root.length) == root) break;
                }
              }
              var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
              if (!mboundary) throw new Error("MAD cannot find boundary");
              var boundary = "--" + (mboundary[1] || "");
              var FileIndex = [],
                FullPaths = [];
              var o = {
                FileIndex: FileIndex,
                FullPaths: FullPaths
              };
              init_cfb(o);
              var start_di,
                fcnt = 0;
              for (di = 0; di < data.length; ++di) {
                var line = data[di];
                if (line !== boundary && line !== boundary + "--") continue;
                if (fcnt++) parse_mime(o, data.slice(start_di, di), root);
                start_di = di;
              }
              return o;
            }
            function write_mad(cfb, options) {
              var opts = options || {};
              var boundary = opts.boundary || "SheetJS";
              boundary = '------=' + boundary;
              var out = ['MIME-Version: 1.0', 'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"', '', '', ''];
              var root = cfb.FullPaths[0],
                fp = root,
                fi = cfb.FileIndex[0];
              for (var i = 1; i < cfb.FullPaths.length; ++i) {
                fp = cfb.FullPaths[i].slice(root.length);
                fi = cfb.FileIndex[i];
                if (!fi.size || !fi.content || fp == "\x01Sh33tJ5") continue;

                /* Normalize filename */
                fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function (c) {
                  return "_x" + c.charCodeAt(0).toString(16) + "_";
                }).replace(/[\u0080-\uFFFF]/g, function (u) {
                  return "_u" + u.charCodeAt(0).toString(16) + "_";
                });

                /* Extract content as binary string */
                var ca = fi.content;
                // $FlowIgnore
                var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s(ca);

                /* 4/5 of first 1024 chars ascii -> quoted printable, else base64 */
                var dispcnt = 0,
                  L = Math.min(1024, cstr.length),
                  cc = 0;
                for (var csl = 0; csl <= L; ++csl) {
                  if ((cc = cstr.charCodeAt(csl)) >= 0x20 && cc < 0x80) ++dispcnt;
                }
                var qp = dispcnt >= L * 4 / 5;
                out.push(boundary);
                out.push('Content-Location: ' + (opts.root || 'file:///C:/SheetJS/') + fp);
                out.push('Content-Transfer-Encoding: ' + (qp ? 'quoted-printable' : 'base64'));
                out.push('Content-Type: ' + get_content_type(fi, fp));
                out.push('');
                out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
              }
              out.push(boundary + '--\r\n');
              return out.join("\r\n");
            }
            function cfb_new(opts) {
              var o = {};
              init_cfb(o, opts);
              return o;
            }
            function cfb_add(cfb, name, content, opts) {
              var unsafe = opts && opts.unsafe;
              if (!unsafe) init_cfb(cfb);
              var file = !unsafe && CFB.find(cfb, name);
              if (!file) {
                var fpath = cfb.FullPaths[0];
                if (name.slice(0, fpath.length) == fpath) fpath = name;else {
                  if (fpath.slice(-1) != "/") fpath += "/";
                  fpath = (fpath + name).replace("//", "/");
                }
                file = {
                  name: filename(name),
                  type: 2
                };
                cfb.FileIndex.push(file);
                cfb.FullPaths.push(fpath);
                if (!unsafe) CFB.utils.cfb_gc(cfb);
              }
              file.content = content;
              file.size = content ? content.length : 0;
              if (opts) {
                if (opts.CLSID) file.clsid = opts.CLSID;
                if (opts.mt) file.mt = opts.mt;
                if (opts.ct) file.ct = opts.ct;
              }
              return file;
            }
            function cfb_del(cfb, name) {
              init_cfb(cfb);
              var file = CFB.find(cfb, name);
              if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) {
                if (cfb.FileIndex[j] == file) {
                  cfb.FileIndex.splice(j, 1);
                  cfb.FullPaths.splice(j, 1);
                  return true;
                }
              }
              return false;
            }
            function cfb_mov(cfb, old_name, new_name) {
              init_cfb(cfb);
              var file = CFB.find(cfb, old_name);
              if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) {
                if (cfb.FileIndex[j] == file) {
                  cfb.FileIndex[j].name = filename(new_name);
                  cfb.FullPaths[j] = new_name;
                  return true;
                }
              }
              return false;
            }
            function cfb_gc(cfb) {
              rebuild_cfb(cfb, true);
            }
            exports.find = find;
            exports.read = read;
            exports.parse = parse;
            exports.write = write;
            exports.writeFile = write_file;
            exports.utils = {
              cfb_new: cfb_new,
              cfb_add: cfb_add,
              cfb_del: cfb_del,
              cfb_mov: cfb_mov,
              cfb_gc: cfb_gc,
              ReadShift: ReadShift,
              CheckField: CheckField,
              prep_blob: prep_blob,
              bconcat: bconcat,
              use_zlib: use_zlib,
              _deflateRaw: _deflate,
              _inflateRaw: _inflate,
              consts: consts
            };
            return exports;
          }();
          if (typeof require !== 'undefined' && typeof module !== 'undefined' && typeof DO_NOT_EXPORT_CFB === 'undefined') {
            module.exports = CFB;
          }
        }).call(this);
      }).call(this, require('_process'), require("buffer").Buffer);
    }, {
      "_process": 36,
      "buffer": 7,
      "fs": 5
    }],
    9: [function (require, module, exports) {
      module.exports = require('./lib/eml-format.js');
    }, {
      "./lib/eml-format.js": 10
    }],
    10: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          /******************************************************************************************
           * EML format parser. EML is raw e-mail message header + body as returned by POP3 protocol.
           * RFC 822: http://www.ietf.org/rfc/rfc0822.txt
           * RFC 1521: https://www.ietf.org/rfc/rfc1521.txt
           ******************************************************************************************/

          var iconv = require('iconv-lite');

          //Default character set
          var defaultCharset = 'utf-8'; //to use if charset=... is missing

          //Gets the character encoding name for iconv, e.g. 'iso-8859-2' -> 'iso88592'
          function getCharsetName(charset) {
            return charset.toLowerCase().replace(/[^0-9a-z]/g, "");
          }

          //Generates a random id
          function guid() {
            return 'xxxxxxxxxxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
              var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : r & 0x3 | 0x8;
              return v.toString(16);
            }).replace("-", "");
          }

          //Word-wrap the string 's' to 'i' chars per row
          function wrap(s, i) {
            var a = [];
            do {
              a.push(s.substring(0, i));
            } while ((s = s.substring(i, s.length)) != "");
            return a.join("\r\n");
          }

          //Overridable properties and functions
          var emlformat = {
            verbose: false,
            fileExtensions: {
              "text/plain": ".txt",
              "text/html": ".html",
              "image/png": ".png",
              "image/jpg": ".jpg",
              "image/jpeg": ".jpg"
            },
            //Gets file extension by mime type
            getFileExtension: function getFileExtension(mimeType) {
              return emlformat.fileExtensions[mimeType] || "";
            },
            //Gets the boundary name
            getBoundary: function getBoundary(contentType) {
              var match = /boundary="?(.+?)"?(\s*;[\s\S]*)?$/g.exec(contentType);
              return match ? match[1] : undefined;
            },
            //Gets character set name, e.g. contentType='.....charset="iso-8859-2"....'
            getCharset: function getCharset(contentType) {
              var match = /charset\s*=\W*([\w\-]+)/g.exec(contentType);
              return match ? match[1] : undefined;
            },
            //Gets name and e-mail address from a string, e.g. "PayPal" <noreply@paypal.com> => { name: "PayPal", email: "noreply@paypal.com" }
            getEmailAddress: function getEmailAddress(raw) {
              var list = [];

              //Split around ',' char
              //var parts = raw.split(/,/g); //Will also split ',' inside the quotes
              //var parts = raw.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g); //Ignore ',' within the double quotes
              var parts = raw.match(/("[^"]*")|[^,]+/g); //Ignore ',' within the double quotes

              for (var i = 0; i < parts.length; i++) {
                var address = {};

                //Quoted name but without the e-mail address
                if (/^".*"$/g.test(parts[i])) {
                  address.name = emlformat.unquoteString(parts[i]).replace(/"/g, "").trim();
                  i++; //Shift to another part to capture e-mail address
                }

                var regex = /^(.*?)(\s*\<(.*?)\>)$/g;
                var match = regex.exec(parts[i]);
                if (match) {
                  var name = emlformat.unquoteString(match[1]).replace(/"/g, "").trim();
                  if (name && name.length) {
                    address.name = name;
                  }
                  address.email = match[3].trim();
                  list.push(address);
                } else {
                  //E-mail address only (without the name)
                  address.email = parts[i].trim();
                  list.push(address);
                }
              }

              //Return result
              if (list.length == 0) {
                return null; //No e-mail address
              }

              if (list.length == 1) {
                return list[0]; //Only one record, return as object, required to preserve backward compatibility
              }

              return list; //Multiple e-mail addresses as array
            },

            //Builds e-mail address string, e.g. { name: "PayPal", email: "noreply@paypal.com" } => "PayPal" <noreply@paypal.com>
            toEmailAddress: function toEmailAddress(data) {
              var email = "";
              if (typeof data == "undefined") {
                //No e-mail address
              } else if (typeof data == "string") {
                email = data;
              } else if (_typeof(data) == "object") {
                if (Array.isArray(data)) {
                  for (var i = 0; i < data.length; i++) {
                    email += email.length ? ', ' : '';
                    if (data[i].name) {
                      email += '"' + data[i].name + '"';
                    }
                    if (data[i].email) {
                      email += (email.length ? ' ' : '') + '<' + data[i].email + '>';
                    }
                  }
                } else {
                  if (data.name) {
                    email += '"' + data.name + '"';
                  }
                  if (data.email) {
                    email += (email.length ? ' ' : '') + '<' + data.email + '>';
                  }
                }
              }
              return email;
            },
            //Decodes string by detecting the charset
            unquoteString: function unquoteString(s) {
              var regex = /=\?([^?]+)\?(B|Q)\?(.+?)(\?=)/gi;
              var match = regex.exec(s);
              if (match) {
                var charset = getCharsetName(match[1] || defaultCharset); //eq. match[1] = 'iso-8859-2'; charset = 'iso88592'
                var type = match[2].toUpperCase();
                var value = match[3];
                if (type == "B") {
                  //Base64
                  if (charset == "utf8") {
                    return Buffer.from(value.replace(/\r?\n/g, ""), "base64").toString("utf8");
                  } else {
                    return iconv.decode(Buffer.from(value.replace(/\r?\n/g, ""), "base64"), charset);
                  }
                } else if (type == "Q") {
                  //Quoted printable
                  return emlformat.unquotePrintable(value, charset);
                }
              }
              return s;
            },
            //Decodes string like =?UTF-8?B?V2hhdOKAmXMgeW91ciBvbmxpbmUgc2hvcHBpbmcgc3R5bGU/?= or =?UTF-8?Q?...?=
            unquoteUTF8: function unquoteUTF8(s) {
              var regex = /=\?UTF\-8\?(B|Q)\?(.+?)(\?=)/gi;
              var match = regex.exec(s);
              if (match) {
                var type = match[1].toUpperCase();
                var value = match[2];
                if (type == "B") {
                  //Base64
                  return Buffer.from(value.replace(/\r?\n/g, ""), "base64").toString("utf8");
                } else if (type == "Q") {
                  //Quoted printable
                  return emlformat.unquotePrintable(value);
                }
              }
              return s;
            },
            //Decodes "quoted-printable"
            unquotePrintable: function unquotePrintable(s, charset) {
              //Convert =0D to '\r', =20 to ' ', etc.
              if (!charset || charset == "utf8" || charset == "utf-8") {
                return s.replace(/=([\w\d]{2})=([\w\d]{2})=([\w\d]{2})/gi, function (matcher, p1, p2, p3, offset, string) {
                  return Buffer.from([parseInt(p1, 16), parseInt(p2, 16), parseInt(p3, 16)]).toString("utf8");
                }).replace(/=([\w\d]{2})=([\w\d]{2})/gi, function (matcher, p1, p2, offset, string) {
                  return Buffer.from([parseInt(p1, 16), parseInt(p2, 16)]).toString("utf8");
                }).replace(/=([\w\d]{2})/gi, function (matcher, p1, offset, string) {
                  return String.fromCharCode(parseInt(p1, 16));
                }).replace(/=\r?\n/gi, ""); //Join line
              } else {
                return s.replace(/=([\w\d]{2})=([\w\d]{2})/gi, function (matcher, p1, p2, offset, string) {
                  return iconv.decode(Buffer.from([parseInt(p1, 16), parseInt(p2, 16)]), charset);
                }).replace(/=([\w\d]{2})/gi, function (matcher, p1, offset, string) {
                  return iconv.decode(Buffer.from([parseInt(p1, 16)]), charset);
                }).replace(/=\r?\n/gi, ""); //Join line
              }
            }
          };

          /******************************************************************************************
           * Unpacks EML message and attachments to a directory.
           * @params eml         EML file content or object from 'parse'
           * @params directory   Folder name or directory path where to unpack
           * @params options     Optional parameters: { parsedJsonFile, readJsonFile, simulate }
           * @params callback    Callback function(error)
           ******************************************************************************************/
          emlformat.unpack = function (eml, directory, options, callback) {
            var fs = require("fs");
            var path = require("path");

            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            var result = {
              files: []
            };
            function _unpack(data) {
              try {
                //Create the target directory
                if (!fs.existsSync(directory)) {
                  fs.mkdirSync(directory);
                }

                //Plain text file
                if (typeof data.text == "string") {
                  result.files.push("index.txt");
                  if (options && options.simulate) {
                    //Skip writing to file
                  } else {
                    fs.writeFileSync(path.join(directory, "index.txt"), data.text);
                  }
                }

                //Message in HTML format
                if (typeof data.html == "string") {
                  result.files.push("index.html");
                  if (options && options.simulate) {
                    //Skip writing to file
                  } else {
                    fs.writeFileSync(path.join(directory, "index.html"), data.html);
                  }
                }

                //Attachments
                if (data.attachments && data.attachments.length > 0) {
                  for (var i = 0; i < data.attachments.length; i++) {
                    var attachment = data.attachments[i];
                    var filename = attachment.name;
                    if (!filename) {
                      filename = "attachment_" + (i + 1) + emlformat.getFileExtension(attachment.mimeType);
                    }
                    result.files.push(filename);
                    if (options && options.simulate) continue; //Skip writing to file
                    fs.writeFileSync(path.join(directory, filename), attachment.data);
                  }
                }
                callback(null, result);
              } catch (e) {
                callback(e);
              }
            }

            //Check the directory argument
            if (typeof directory != "string" || directory.length == 0) {
              return callback(new Error("Directory argument is missing!"));
            }

            //Argument as EML file content or "parsed" version of object
            if (typeof eml == "string" || _typeof(eml) == "object" && eml.headers && eml.body) {
              emlformat.parse(eml, function (error, parsed) {
                if (error) return callback(error);

                //Save parsed EML as JSON file
                if (options && options.parsedJsonFile) {
                  var file = path.resolve(directory, options.parsedJsonFile);
                  var dir = path.dirname(file);
                  if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir);
                  }
                  result.files.push(options.parsedJsonFile);
                  fs.writeFileSync(file, JSON.stringify(parsed, " ", 2));
                }

                //Convert parsed EML object to a friendly object with text, html and attachments
                emlformat.read(parsed, function (error, data) {
                  if (error) return callback(error);

                  //Save read structure as JSON file
                  if (options && options.readJsonFile) {
                    var file = path.resolve(directory, options.readJsonFile);
                    var dir = path.dirname(file);
                    if (!fs.existsSync(dir)) {
                      fs.mkdirSync(dir);
                    }
                    result.files.push(options.readJsonFile);
                    var json = data.attachments ? JSON.stringify(data) : JSON.stringify(data, " ", 2); //Attachments may be large, so make a compact JSON string
                    fs.writeFileSync(file, json);
                  }

                  //Extract files from the EML file
                  _unpack(data);
                });
              });
            } else if (_typeof(eml) != "object") {
              return callback(new Error("Expected string or object as argument!"));
            } else {
              _unpack(eml);
            }
          };

          /******************************************************************************************
           * Parses EML file content and return user-friendly object.
           * @params data        EML structure
           * @params options     EML build options
           * @params callback    Callback function(error, data)
           ******************************************************************************************/
          emlformat.build = function (data, options, callback) {
            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            var eml = "";
            var EOL = "\r\n"; //End-of-line

            try {
              if (!data || _typeof(data) != "object") {
                throw new Error("Argument 'data' expected to be an object!");
              }
              if (!data.headers) {
                data.headers = {};
              }
              if (typeof data.subject == "string") {
                data.headers["Subject"] = data.subject;
              }
              if (typeof data.from != "undefined") {
                data.headers["From"] = typeof data.from == "string" ? data.from : emlformat.toEmailAddress(data.from);
              }
              if (typeof data.to != "undefined") {
                data.headers["To"] = typeof data.to == "string" ? data.to : emlformat.toEmailAddress(data.to);
              }
              if (typeof data.cc != "undefined") {
                data.headers["Cc"] = typeof data.cc == "string" ? data.cc : emlformat.toEmailAddress(data.cc);
              }
              if (!data.headers["To"]) {
                throw new Error("Missing 'To' e-mail address!");
              }
              var boundary = "----=" + guid();
              if (typeof data.headers["Content-Type"] == "undefined") {
                data.headers["Content-Type"] = 'multipart/mixed;' + EOL + 'boundary="' + boundary + '"';
              } else {
                var name = emlformat.getBoundary(data.headers["Content-Type"]);
                if (name) {
                  boundary = name;
                }
              }

              //Build headers
              var keys = Object.keys(data.headers);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = data.headers[key];
                if (typeof value == "undefined") {
                  continue; //Skip missing headers
                } else if (typeof value == "string") {
                  eml += key + ": " + value.replace(/\r?\n/g, EOL + "  ") + EOL;
                } else {
                  //Array
                  for (var j = 0; j < value.length; j++) {
                    eml += key + ": " + value[j].replace(/\r?\n/g, EOL + "  ") + EOL;
                  }
                }
              }

              //Start the body
              eml += EOL;

              //Plain text content
              if (data.text) {
                eml += "--" + boundary + EOL;
                eml += "Content-Type: text/plain; charset=utf-8" + EOL;
                eml += EOL;
                eml += data.text;
                eml += EOL + EOL;
              }

              //HTML content
              if (data.html) {
                eml += "--" + boundary + EOL;
                eml += "Content-Type: text/html; charset=utf-8" + EOL;
                eml += EOL;
                eml += data.html;
                eml += EOL + EOL;
              }

              //Append attachments
              if (data.attachments) {
                for (var i = 0; i < data.attachments.length; i++) {
                  var attachment = data.attachments[i];
                  eml += '--' + boundary + EOL;
                  eml += 'Content-Type: ' + (attachment.contentType || "application/octet-stream") + EOL;
                  eml += 'Content-Transfer-Encoding: base64' + EOL;
                  eml += 'Content-Disposition: ' + (attachment.inline ? "inline" : "attachment") + '; filename="' + (attachment.filename || attachment.name || "attachment_" + (i + 1)) + '"' + EOL;
                  if (attachment.cid) {
                    eml += 'Content-ID: <' + attachment.cid + ">" + EOL;
                  }
                  eml += EOL;
                  if (typeof attachment.data == "string") {
                    var content = Buffer.from(attachment.data).toString("base64");
                    eml += wrap(content, 76) + EOL;
                  } else {
                    //Buffer
                    var content = attachment.data.toString("base64");
                    eml += wrap(content, 76) + EOL;
                  }
                  eml += EOL;
                }
              }

              //Finish the boundary
              eml += "--" + boundary + "--" + EOL;
              callback(null, eml);
            } catch (e) {
              callback(e);
            }
          };

          /******************************************************************************************
           * Parses EML file content and return user-friendly object.
           * @params eml         EML file content or object from 'parse'
           * @params options     EML parse options
           * @params callback    Callback function(error, data)
           ******************************************************************************************/
          emlformat.read = function (eml, options, callback) {
            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            function _read(data) {
              try {
                var result = {};
                if (data.headers["Date"]) {
                  result.date = new Date(data.headers["Date"]);
                }
                if (data.headers["Subject"]) {
                  result.subject = emlformat.unquoteString(data.headers["Subject"]);
                }
                if (data.headers["From"]) {
                  result.from = emlformat.getEmailAddress(data.headers["From"]);
                }
                if (data.headers["To"]) {
                  result.to = emlformat.getEmailAddress(data.headers["To"]);
                }
                if (data.headers["CC"]) {
                  result.cc = emlformat.getEmailAddress(data.headers["CC"]);
                }
                if (data.headers["Cc"]) {
                  result.cc = emlformat.getEmailAddress(data.headers["Cc"]);
                }
                result.headers = data.headers;

                //Appends the boundary to the result
                function _append(headers, content) {
                  var contentType = headers["Content-Type"];
                  var charset = getCharsetName(emlformat.getCharset(contentType) || defaultCharset);
                  var encoding = headers["Content-Transfer-Encoding"];
                  if (typeof encoding == "string") {
                    encoding = encoding.toLowerCase();
                  }
                  if (encoding == "base64") {
                    if (contentType.indexOf("gbk") >= 0) {
                      content = new Buffer(iconv.decode(new Buffer(content, 'base64'), 'gb2312'), 'utf8');
                    } else {
                      content = Buffer.from(content.replace(/\r?\n/g, ""), "base64");
                    }
                  } else if (encoding == "quoted-printable") {
                    content = emlformat.unquotePrintable(content, charset);
                  } else if (charset != "utf8" && (encoding.startsWith("binary") || encoding.startsWith("8bit"))) {
                    //"8bit", "binary", "8bitmime", "binarymime"
                    content = iconv.decode(Buffer.from(content, 'binary'), charset);
                  }
                  if (!result.html && contentType && contentType.indexOf("text/html") >= 0) {
                    if (typeof content != "string") {
                      //content = content.toString("utf8");
                      content = iconv.decode(Buffer.from(content), charset);
                    }
                    //Message in HTML format
                    result.html = content;
                  } else if (!result.text && contentType && contentType.indexOf("text/plain") >= 0) {
                    if (typeof content != "string") {
                      //content = content.toString("utf8");
                      content = iconv.decode(Buffer.from(content), charset);
                    }
                    //Plain text message
                    result.text = content;
                  } else {
                    //Get the attachment
                    if (!result.attachments) {
                      result.attachments = [];
                    }
                    var attachment = {};
                    var id = headers["Content-ID"];
                    if (id) {
                      attachment.id = id;
                    }
                    var name = headers["Content-Disposition"] || headers["Content-Type"];
                    if (name) {
                      var match = /name="?(.+?)"?$/gi.exec(name);
                      if (match) {
                        name = match[1];
                      } else {
                        name = null;
                      }
                    }
                    if (name) {
                      attachment.name = name;
                    }
                    var ct = headers["Content-Type"];
                    if (ct) {
                      attachment.contentType = ct;
                    }
                    var cd = headers["Content-Disposition"];
                    if (cd) {
                      attachment.inline = /^\s*inline/g.test(cd);
                    }
                    attachment.data = content;
                    result.attachments.push(attachment);
                  }
                }

                //Content mime type
                var boundary = null;
                var ct = data.headers["Content-Type"];
                if (ct && /^multipart\//g.test(ct)) {
                  var b = emlformat.getBoundary(ct);
                  if (b && b.length) {
                    boundary = b;
                  }
                }
                if (boundary) {
                  for (var i = 0; i < data.body.length; i++) {
                    var b = data.body[i];

                    //Get the message content
                    if (typeof b.part == "undefined") {
                      console.warn("Warning: undefined b.part");
                    } else if (typeof b.part == "string") {
                      result.data = b.part;
                    } else {
                      if (typeof b.part.body == "undefined") {
                        console.warn("Warning: undefined b.part.body");
                      } else if (typeof b.part.body == "string") {
                        b.part.body;
                        var headers = b.part.headers;
                        var content = b.part.body;
                        _append(headers, content);
                      } else {
                        for (var j = 0; j < b.part.body.length; j++) {
                          if (typeof b.part.body[j] == "string") {
                            result.data = b.part.body[j];
                            continue;
                          }
                          var headers = b.part.body[j].part.headers;
                          var content = b.part.body[j].part.body;
                          _append(headers, content);
                        }
                      }
                    }
                  }
                } else if (typeof data.body == "string") {
                  _append(data.headers, data.body);
                }
                callback(null, result);
              } catch (e) {
                callback(e);
              }
            }
            if (typeof eml == "string") {
              emlformat.parse(eml, options, function (error, data) {
                if (error) return callback(error);
                if (!data) return callback(new Error("Cannot parse EML content!"));
                _read(data);
              });
            } else if (_typeof(eml) == "object") {
              _read(eml);
            } else {
              callback(new Error("Missing EML file content!"));
            }
          };

          /******************************************************************************************
           * Parses EML file content and returns object-oriented representation of the content.
           * @params eml         EML file content
           * @params options     EML parse options
           * @params callback    Callback function(error, data)
           ******************************************************************************************/
          emlformat.parse = function (eml, options, callback) {
            //Shift arguments
            if (typeof options == "function" && typeof callback == "undefined") {
              callback = options;
              options = null;
            }
            if (typeof callback != "function") {
              callback = function callback(error, result) {};
            }
            try {
              if (typeof eml != "string") {
                throw new Error("Argument 'eml' expected to be string!");
              }
              var lines = eml.split(/\r?\n/);
              var result = {};
              parseRecursive(lines, 0, result, options);
              callback(null, result);
            } catch (e) {
              callback(e);
            }
          };

          /******************************************************************************************
           * Parses EML file content.
           ******************************************************************************************/
          function parseRecursive(lines, start, parent, options) {
            var boundary = null;
            var lastHeaderName = "";
            var findBoundary = "";
            var insideBody = false;
            var insideBoundary = false;
            var isMultiHeader = false;
            var isMultipart = false;
            parent.headers = {};
            //parent.body = null;

            function complete(boundary) {
              //boundary.part = boundary.lines.join("\r\n");
              boundary.part = {};
              parseRecursive(boundary.lines, 0, boundary.part, options);
              delete boundary.lines;
            }

            //Read line by line
            for (var i = start; i < lines.length; i++) {
              var line = lines[i];

              //Header
              if (!insideBody) {
                //Search for empty line
                if (line == "") {
                  insideBody = true;
                  if (options && options.headersOnly) {
                    break;
                  }

                  //Expected boundary
                  var ct = parent.headers["Content-Type"];
                  if (ct && /^multipart\//g.test(ct)) {
                    var b = emlformat.getBoundary(ct);
                    if (b && b.length) {
                      findBoundary = b;
                      isMultipart = true;
                      parent.body = [];
                    } else {
                      if (emlformat.verbose) {
                        console.warn("Multipart without boundary! " + ct.replace(/\r?\n/g, " "));
                      }
                    }
                  }
                  continue;
                }

                //Header value with new line
                var match = /^\s+([^\r\n]+)/g.exec(line);
                if (match) {
                  if (isMultiHeader) {
                    parent.headers[lastHeaderName][parent.headers[lastHeaderName].length - 1] += "\r\n" + match[1];
                  } else {
                    parent.headers[lastHeaderName] += "\r\n" + match[1];
                  }
                  continue;
                }

                //Header name and value
                var match = /^([\w\d\-]+):\s+([^\r\n]+)/gi.exec(line);
                if (match) {
                  lastHeaderName = match[1];
                  if (parent.headers[lastHeaderName]) {
                    //Multiple headers with the same name
                    isMultiHeader = true;
                    if (typeof parent.headers[lastHeaderName] == "string") {
                      parent.headers[lastHeaderName] = [parent.headers[lastHeaderName]];
                    }
                    parent.headers[lastHeaderName].push(match[2]);
                  } else {
                    //Header first appeared here
                    isMultiHeader = false;
                    parent.headers[lastHeaderName] = match[2];
                  }
                  continue;
                }
              }
              //Body
              else {
                //Multipart body
                if (isMultipart) {
                  //Search for boundary start

                  //Updated on 2019-10-12: A line before the boundary marker is not required to be an empty line
                  //if (lines[i - 1] == "" && line.indexOf("--" + findBoundary) == 0 && !/\-\-(\r?\n)?$/g.test(line)) {
                  if (line.indexOf("--" + findBoundary) == 0 && !/\-\-(\r?\n)?$/g.test(line)) {
                    insideBoundary = true;

                    //Complete the previous boundary
                    if (boundary && boundary.lines) {
                      complete(boundary);
                    }

                    //Start a new boundary
                    var match = /^\-\-([^\r\n]+)(\r?\n)?$/g.exec(line);
                    boundary = {
                      boundary: match[1],
                      lines: []
                    };
                    parent.body.push(boundary);
                    if (emlformat.verbose) {
                      console.log("Found boundary: " + boundary.boundary);
                    }
                    continue;
                  }
                  if (insideBoundary) {
                    //Search for boundary end
                    if (boundary.boundary && lines[i - 1] == "" && line.indexOf("--" + findBoundary + "--") == 0) {
                      insideBoundary = false;
                      complete(boundary);
                      continue;
                    }
                    boundary.lines.push(line);
                  }
                } else {
                  //Solid string body
                  parent.body = lines.splice(i).join("\r\n");
                  break;
                }
              }
            }

            //Complete the last boundary
            if (parent.body && parent.body.length && parent.body[parent.body.length - 1].lines) {
              complete(parent.body[parent.body.length - 1]);
            }
          }
          module.exports = emlformat;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "buffer": 7,
      "fs": 6,
      "iconv-lite": 31,
      "path": 35
    }],
    11: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
      var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === 'function') {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;

      // Backwards-compat with node 0.10.x
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = undefined;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = undefined;

      // By default EventEmitters will print a warning if more than 10 listeners are
      // added to it. This is a useful default which helps finding memory leaks.
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== 'function') {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
        }
      }
      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
        enumerable: true,
        get: function get() {
          return defaultMaxListeners;
        },
        set: function set(arg) {
          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function () {
        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || undefined;
      };

      // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var doError = type === 'error';
        var events = this._events;
        if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

        // If there is no 'error' event listener then throw.
        if (doError) {
          var er;
          if (args.length > 0) er = args[0];
          if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
          }
          // At least give some kind of context to the user
          var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
          err.context = er;
          throw err; // Unhandled 'error' event
        }

        var handler = events[type];
        if (handler === undefined) return false;
        if (typeof handler === 'function') {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            ReflectApply(listeners[i], this, args);
          }
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === undefined) {
          events = target._events = Object.create(null);
          target._eventsCount = 0;
        } else {
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);

            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === undefined) {
          // Optimize the case of one listener. Don't need the extra array object.
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            // If we've already got an array, just append.
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }

          // Check for listener leak
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0) return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = {
          fired: false,
          wrapFn: undefined,
          target: target,
          type: type,
          listener: listener
        };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

      // Emits a 'removeListener' event if and only if the listener was removed.
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === undefined) return this;
        list = events[type];
        if (list === undefined) return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0) this._events = Object.create(null);else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0) return this;
          if (position === 0) list.shift();else {
            spliceOne(list, position);
          }
          if (list.length === 1) events[type] = list[0];
          if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === undefined) return this;

        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === undefined) return [];
        var evlistener = events[type];
        if (evlistener === undefined) return [];
        if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function (emitter, type) {
        if (typeof emitter.listenerCount === 'function') {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== undefined) {
          var evlistener = events[type];
          if (typeof evlistener === 'function') {
            return 1;
          } else if (evlistener !== undefined) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i) {
          copy[i] = arr[i];
        }
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++) {
          list[index] = list[index + 1];
        }
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function (resolve, reject) {
          function eventListener() {
            if (errorListener !== undefined) {
              emitter.removeListener('error', errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          var errorListener;

          // Adding an error listener is not optional because
          // if an error is thrown on an event emitter we cannot
          // guarantee that the actual event we are waiting will
          // be fired. The result could be a silent way to create
          // memory or file descriptor leaks, which is something
          // we should avoid.
          if (name !== 'error') {
            errorListener = function errorListener(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once('error', errorListener);
          }
          emitter.once(name, eventListener);
        });
      }
    }, {}],
    12: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
      // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
      // To save memory and loading time, we read table files only when requested.

      exports._dbcs = DBCSCodec;
      var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START = -10,
        NODE_START = -1000,
        UNASSIGNED_NODE = new Array(0x100),
        DEF_CHAR = -1;
      for (var i = 0; i < 0x100; i++) {
        UNASSIGNED_NODE[i] = UNASSIGNED;
      }

      // Class DBCSCodec reads and initializes mapping tables.
      function DBCSCodec(codecOptions, iconv) {
        this.encodingName = codecOptions.encodingName;
        if (!codecOptions) throw new Error("DBCS codec is called without the data.");
        if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

        // Load tables.
        var mappingTable = codecOptions.table();

        // Decode tables: MBCS -> Unicode.

        // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
        // Trie root is decodeTables[0].
        // Values: >=  0 -> unicode character code. can be > 0xFFFF
        //         == UNASSIGNED -> unknown/unassigned sequence.
        //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
        //         <= NODE_START -> index of the next node in our trie to process next byte.
        //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

        // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
        this.decodeTableSeq = [];

        // Actual mapping tables consist of chunks. Use them to fill up decode tables.
        for (var i = 0; i < mappingTable.length; i++) {
          this._addDecodeChunk(mappingTable[i]);
        }
        this.defaultCharUnicode = iconv.defaultCharUnicode;

        // Encode tables: Unicode -> DBCS.

        // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
        // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
        // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
        //         == UNASSIGNED -> no conversion found. Output a default char.
        //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
        this.encodeTable = [];

        // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
        // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
        // means end of sequence (needed when one sequence is a strict subsequence of another).
        // Objects are kept separately from encodeTable to increase performance.
        this.encodeTableSeq = [];

        // Some chars can be decoded, but need not be encoded.
        var skipEncodeChars = {};
        if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
          var val = codecOptions.encodeSkipVals[i];
          if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) {
            skipEncodeChars[j] = true;
          }
        }

        // Use decode trie to recursively fill out encode tables.
        this._fillEncodeTable(0, 0, skipEncodeChars);

        // Add more encoding pairs when needed.
        if (codecOptions.encodeAdd) {
          for (var uChar in codecOptions.encodeAdd) {
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
          }
        }
        this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

        // Load & create GB18030 tables when needed.
        if (typeof codecOptions.gb18030 === 'function') {
          this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

          // Add GB18030 decode tables.
          var thirdByteNodeIdx = this.decodeTables.length;
          var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
          var fourthByteNodeIdx = this.decodeTables.length;
          var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
          for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++) {
              secondByteNode[j] = NODE_START - thirdByteNodeIdx;
            }
          }
          for (var i = 0x81; i <= 0xFE; i++) {
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
          }
          for (var i = 0x30; i <= 0x39; i++) {
            fourthByteNode[i] = GB18030_CODE;
          }
        }
      }
      DBCSCodec.prototype.encoder = DBCSEncoder;
      DBCSCodec.prototype.decoder = DBCSDecoder;

      // Decoder helpers
      DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
        var bytes = [];
        for (; addr > 0; addr >>= 8) {
          bytes.push(addr & 0xFF);
        }
        if (bytes.length == 0) bytes.push(0);
        var node = this.decodeTables[0];
        for (var i = bytes.length - 1; i > 0; i--) {
          // Traverse nodes deeper into the trie.
          var val = node[bytes[i]];
          if (val == UNASSIGNED) {
            // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
          } else if (val <= NODE_START) {
            // Existing node.
            node = this.decodeTables[NODE_START - val];
          } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
        }
        return node;
      };
      DBCSCodec.prototype._addDecodeChunk = function (chunk) {
        // First element of chunk is the hex mbcs code where we start.
        var curAddr = parseInt(chunk[0], 16);

        // Choose the decoding node where we'll write our chars.
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 0xFF;

        // Write all other elements of the chunk to the table.
        for (var k = 1; k < chunk.length; k++) {
          var part = chunk[k];
          if (typeof part === "string") {
            // String, write as-is.
            for (var l = 0; l < part.length;) {
              var code = part.charCodeAt(l++);
              if (0xD800 <= code && code < 0xDC00) {
                // Decode surrogate
                var codeTrail = part.charCodeAt(l++);
                if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
              } else if (0x0FF0 < code && code <= 0x0FFF) {
                // Character sequence (our own encoding used)
                var len = 0xFFF - code + 2;
                var seq = [];
                for (var m = 0; m < len; m++) {
                  seq.push(part.charCodeAt(l++));
                } // Simple variation: don't support surrogates or subsequences in seq.

                writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                this.decodeTableSeq.push(seq);
              } else writeTable[curAddr++] = code; // Basic char
            }
          } else if (typeof part === "number") {
            // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++) {
              writeTable[curAddr++] = charCode++;
            }
          } else throw new Error("Incorrect type '" + _typeof(part) + "' given in " + this.encodingName + " at chunk " + chunk[0]);
        }
        if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
      };

      // Encoder helpers
      DBCSCodec.prototype._getEncodeBucket = function (uCode) {
        var high = uCode >> 8; // This could be > 0xFF because of astral characters.
        if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
        return this.encodeTable[high];
      };
      DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
        if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
        else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
      };
      DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
        // Get the root of character tree according to first character of the sequence.
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xFF;
        var node;
        if (bucket[low] <= SEQ_START) {
          // There's already a sequence with  - use it.
          node = this.encodeTableSeq[SEQ_START - bucket[low]];
        } else {
          // There was no sequence object - allocate a new one.
          node = {};
          if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
          bucket[low] = SEQ_START - this.encodeTableSeq.length;
          this.encodeTableSeq.push(node);
        }

        // Traverse the character tree, allocating new nodes as needed.
        for (var j = 1; j < seq.length - 1; j++) {
          var oldVal = node[uCode];
          if (_typeof(oldVal) === 'object') node = oldVal;else {
            node = node[uCode] = {};
            if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
          }
        }

        // Set the leaf to given dbcsCode.
        uCode = seq[seq.length - 1];
        node[uCode] = dbcsCode;
      };
      DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
        var node = this.decodeTables[nodeIdx];
        for (var i = 0; i < 0x100; i++) {
          var uCode = node[i];
          var mbCode = prefix + i;
          if (skipEncodeChars[mbCode]) continue;
          if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        }
      };

      // == Encoder ==================================================================

      function DBCSEncoder(options, codec) {
        // Encoder state
        this.leadSurrogate = -1;
        this.seqObj = undefined;

        // Static data
        this.encodeTable = codec.encodeTable;
        this.encodeTableSeq = codec.encodeTableSeq;
        this.defaultCharSingleByte = codec.defCharSB;
        this.gb18030 = codec.gb18030;
      }
      DBCSEncoder.prototype.write = function (str) {
        var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
          leadSurrogate = this.leadSurrogate,
          seqObj = this.seqObj,
          nextChar = -1,
          i = 0,
          j = 0;
        while (true) {
          // 0. Get next character.
          if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
          } else {
            var uCode = nextChar;
            nextChar = -1;
          }

          // 1. Handle surrogates.
          if (0xD800 <= uCode && uCode < 0xE000) {
            // Char is one of surrogates.
            if (uCode < 0xDC00) {
              // We've got lead surrogate.
              if (leadSurrogate === -1) {
                leadSurrogate = uCode;
                continue;
              } else {
                leadSurrogate = uCode;
                // Double lead surrogate found.
                uCode = UNASSIGNED;
              }
            } else {
              // We've got trail surrogate.
              if (leadSurrogate !== -1) {
                uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                leadSurrogate = -1;
              } else {
                // Incomplete surrogate pair - only trail surrogate found.
                uCode = UNASSIGNED;
              }
            }
          } else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode;
            uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
          }

          // 2. Convert uCode character.
          var dbcsCode = UNASSIGNED;
          if (seqObj !== undefined && uCode != UNASSIGNED) {
            // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (_typeof(resCode) === 'object') {
              // Sequence continues.
              seqObj = resCode;
              continue;
            } else if (typeof resCode == 'number') {
              // Sequence finished. Write it.
              dbcsCode = resCode;
            } else if (resCode == undefined) {
              // Current character is not part of the sequence.

              // Try default character for this sequence
              resCode = seqObj[DEF_CHAR];
              if (resCode !== undefined) {
                dbcsCode = resCode; // Found. Write it.
                nextChar = uCode; // Current character will be written too in the next iteration.
              } else {
                // TODO: What if we have no default? (resCode == undefined)
                // Then, we should write first char of the sequence as-is and try the rest recursively.
                // Didn't do it for now because no encoding has this situation yet.
                // Currently, just skip the sequence and write current char.
              }
            }
            seqObj = undefined;
          } else if (uCode >= 0) {
            // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];
            if (dbcsCode <= SEQ_START) {
              // Sequence start
              seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
              continue;
            }
            if (dbcsCode == UNASSIGNED && this.gb18030) {
              // Use GB18030 algorithm to find character(s) to write.
              var idx = findIdx(this.gb18030.uChars, uCode);
              if (idx != -1) {
                var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
                dbcsCode = dbcsCode % 12600;
                newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
                dbcsCode = dbcsCode % 1260;
                newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
                dbcsCode = dbcsCode % 10;
                newBuf[j++] = 0x30 + dbcsCode;
                continue;
              }
            }
          }

          // 3. Write dbcsCode character.
          if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
          if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
          } else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8; // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
          } else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = dbcsCode >> 8 & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
          }
        }
        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
      };
      DBCSEncoder.prototype.end = function () {
        if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

        var newBuf = Buffer.alloc(10),
          j = 0;
        if (this.seqObj) {
          // We're in the sequence.
          var dbcsCode = this.seqObj[DEF_CHAR];
          if (dbcsCode !== undefined) {
            // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
              newBuf[j++] = dbcsCode;
            } else {
              newBuf[j++] = dbcsCode >> 8; // high byte
              newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
          } else {
            // See todo above.
          }
          this.seqObj = undefined;
        }
        if (this.leadSurrogate !== -1) {
          // Incomplete surrogate pair - only lead surrogate found.
          newBuf[j++] = this.defaultCharSingleByte;
          this.leadSurrogate = -1;
        }
        return newBuf.slice(0, j);
      };

      // Export for testing
      DBCSEncoder.prototype.findIdx = findIdx;

      // == Decoder ==================================================================

      function DBCSDecoder(options, codec) {
        // Decoder state
        this.nodeIdx = 0;
        this.prevBuf = Buffer.alloc(0);

        // Static data
        this.decodeTables = codec.decodeTables;
        this.decodeTableSeq = codec.decodeTableSeq;
        this.defaultCharUnicode = codec.defaultCharUnicode;
        this.gb18030 = codec.gb18030;
      }
      DBCSDecoder.prototype.write = function (buf) {
        var newBuf = Buffer.alloc(buf.length * 2),
          nodeIdx = this.nodeIdx,
          prevBuf = this.prevBuf,
          prevBufOffset = this.prevBuf.length,
          seqStart = -this.prevBuf.length,
          // idx of the start of current parsed sequence.
          uCode;
        if (prevBufOffset > 0)
          // Make prev buf overlap a little to make it easier to slice later.
          prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
        for (var i = 0, j = 0; i < buf.length; i++) {
          var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];

          // Lookup in current trie node.
          var uCode = this.decodeTables[nodeIdx][curByte];
          if (uCode >= 0) {
            // Normal character, just use it.
          } else if (uCode === UNASSIGNED) {
            // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
          } else if (uCode === GB18030_CODE) {
            var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
            var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
          } else if (uCode <= NODE_START) {
            // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
          } else if (uCode <= SEQ_START) {
            // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
              uCode = seq[k];
              newBuf[j++] = uCode & 0xFF;
              newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length - 1];
          } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

          // Write the character to buffer, handling higher planes using surrogate pair.
          if (uCode > 0xFFFF) {
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;
            uCode = 0xDC00 + uCode % 0x400;
          }
          newBuf[j++] = uCode & 0xFF;
          newBuf[j++] = uCode >> 8;

          // Reset trie node.
          nodeIdx = 0;
          seqStart = i + 1;
        }
        this.nodeIdx = nodeIdx;
        this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
        return newBuf.slice(0, j).toString('ucs2');
      };
      DBCSDecoder.prototype.end = function () {
        var ret = '';

        // Try to parse all remaining chars.
        while (this.prevBuf.length > 0) {
          // Skip 1 character in the buffer.
          ret += this.defaultCharUnicode;
          var buf = this.prevBuf.slice(1);

          // Parse remaining as usual.
          this.prevBuf = Buffer.alloc(0);
          this.nodeIdx = 0;
          if (buf.length > 0) ret += this.write(buf);
        }
        this.nodeIdx = 0;
        return ret;
      };

      // Binary search for GB18030. Returns largest i such that table[i] <= val.
      function findIdx(table, val) {
        if (table[0] > val) return -1;
        var l = 0,
          r = table.length;
        while (l < r - 1) {
          // always table[l] <= val < table[r]
          var mid = l + Math.floor((r - l + 1) / 2);
          if (table[mid] <= val) l = mid;else r = mid;
        }
        return l;
      }
    }, {
      "safer-buffer": 56
    }],
    13: [function (require, module, exports) {
      "use strict";

      // Description of supported double byte encodings and aliases.
      // Tables are not require()-d until they are needed to speed up library load.
      // require()-s are direct to support Browserify.
      module.exports = {
        // == Japanese/ShiftJIS ====================================================
        // All japanese encodings are based on JIS X set of standards:
        // JIS X 0201 - Single-byte encoding of ASCII + ¥ + Kana chars at 0xA1-0xDF.
        // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
        //              Has several variations in 1978, 1983, 1990 and 1997.
        // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
        // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
        //              2 planes, first is superset of 0208, second - revised 0212.
        //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

        // Byte encodings are:
        //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
        //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
        //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
        //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
        //               0x00-0x7F       - lower part of 0201
        //               0x8E, 0xA1-0xDF - upper part of 0201
        //               (0xA1-0xFE)x2   - 0208 plane (94x94).
        //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
        //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
        //               Used as-is in ISO2022 family.
        //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
        //                0201-1976 Roman, 0208-1978, 0208-1983.
        //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
        //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
        //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
        //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
        //
        // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
        //
        // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

        'shiftjis': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/shiftjis.json');
          },
          encodeAdd: {
            "\xA5": 0x5C,
            "\u203E": 0x7E
          },
          encodeSkipVals: [{
            from: 0xED40,
            to: 0xF940
          }]
        },
        'csshiftjis': 'shiftjis',
        'mskanji': 'shiftjis',
        'sjis': 'shiftjis',
        'windows31j': 'shiftjis',
        'ms31j': 'shiftjis',
        'xsjis': 'shiftjis',
        'windows932': 'shiftjis',
        'ms932': 'shiftjis',
        '932': 'shiftjis',
        'cp932': 'shiftjis',
        'eucjp': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/eucjp.json');
          },
          encodeAdd: {
            "\xA5": 0x5C,
            "\u203E": 0x7E
          }
        },
        // TODO: KDDI extension to Shift_JIS
        // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
        // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

        // == Chinese/GBK ==========================================================
        // http://en.wikipedia.org/wiki/GBK
        // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

        // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
        'gb2312': 'cp936',
        'gb231280': 'cp936',
        'gb23121980': 'cp936',
        'csgb2312': 'cp936',
        'csiso58gb231280': 'cp936',
        'euccn': 'cp936',
        // Microsoft's CP936 is a subset and approximation of GBK.
        'windows936': 'cp936',
        'ms936': 'cp936',
        '936': 'cp936',
        'cp936': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp936.json');
          }
        },
        // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
        'gbk': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp936.json').concat(require('./tables/gbk-added.json'));
          }
        },
        'xgbk': 'gbk',
        'isoir58': 'gbk',
        // GB18030 is an algorithmic extension of GBK.
        // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
        // http://icu-project.org/docs/papers/gb18030.html
        // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
        // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
        'gb18030': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp936.json').concat(require('./tables/gbk-added.json'));
          },
          gb18030: function gb18030() {
            return require('./tables/gb18030-ranges.json');
          },
          encodeSkipVals: [0x80],
          encodeAdd: {
            '€': 0xA2E3
          }
        },
        'chinese': 'gb18030',
        // == Korean ===============================================================
        // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
        'windows949': 'cp949',
        'ms949': 'cp949',
        '949': 'cp949',
        'cp949': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp949.json');
          }
        },
        'cseuckr': 'cp949',
        'csksc56011987': 'cp949',
        'euckr': 'cp949',
        'isoir149': 'cp949',
        'korean': 'cp949',
        'ksc56011987': 'cp949',
        'ksc56011989': 'cp949',
        'ksc5601': 'cp949',
        // == Big5/Taiwan/Hong Kong ================================================
        // There are lots of tables for Big5 and cp950. Please see the following links for history:
        // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
        // Variations, in roughly number of defined chars:
        //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
        //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
        //  * Big5-2003 (Taiwan standard) almost superset of cp950.
        //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
        //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
        //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
        //    Plus, it has 4 combining sequences.
        //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
        //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
        //    Implementations are not consistent within browsers; sometimes labeled as just big5.
        //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
        //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
        //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
        //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
        //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
        // 
        // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
        // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

        'windows950': 'cp950',
        'ms950': 'cp950',
        '950': 'cp950',
        'cp950': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp950.json');
          }
        },
        // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
        'big5': 'big5hkscs',
        'big5hkscs': {
          type: '_dbcs',
          table: function table() {
            return require('./tables/cp950.json').concat(require('./tables/big5-added.json'));
          },
          encodeSkipVals: [0xa2cc]
        },
        'cnbig5': 'big5hkscs',
        'csbig5': 'big5hkscs',
        'xxbig5': 'big5hkscs'
      };
    }, {
      "./tables/big5-added.json": 19,
      "./tables/cp936.json": 20,
      "./tables/cp949.json": 21,
      "./tables/cp950.json": 22,
      "./tables/eucjp.json": 23,
      "./tables/gb18030-ranges.json": 24,
      "./tables/gbk-added.json": 25,
      "./tables/shiftjis.json": 26
    }],
    14: [function (require, module, exports) {
      "use strict";

      // Update this array if you add/rename/remove files in this directory.
      // We support Browserify by skipping automatic module discovery and requiring modules directly.
      var modules = [require("./internal"), require("./utf32"), require("./utf16"), require("./utf7"), require("./sbcs-codec"), require("./sbcs-data"), require("./sbcs-data-generated"), require("./dbcs-codec"), require("./dbcs-data")];

      // Put all encoding/alias/codec definitions to single object and export it.
      for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module) {
          if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
        }
      }
    }, {
      "./dbcs-codec": 12,
      "./dbcs-data": 13,
      "./internal": 15,
      "./sbcs-codec": 16,
      "./sbcs-data": 18,
      "./sbcs-data-generated": 17,
      "./utf16": 27,
      "./utf32": 28,
      "./utf7": 29
    }],
    15: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Export Node.js internal encodings.

      module.exports = {
        // Encodings
        utf8: {
          type: "_internal",
          bomAware: true
        },
        cesu8: {
          type: "_internal",
          bomAware: true
        },
        unicode11utf8: "utf8",
        ucs2: {
          type: "_internal",
          bomAware: true
        },
        utf16le: "ucs2",
        binary: {
          type: "_internal"
        },
        base64: {
          type: "_internal"
        },
        hex: {
          type: "_internal"
        },
        // Codec.
        _internal: InternalCodec
      };

      //------------------------------------------------------------------------------

      function InternalCodec(codecOptions, iconv) {
        this.enc = codecOptions.encodingName;
        this.bomAware = codecOptions.bomAware;
        if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
          this.enc = "utf8"; // Use utf8 for decoding.
          this.encoder = InternalEncoderCesu8;

          // Add decoder for versions of Node not supporting CESU-8
          if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '💩') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
          }
        }
      }
      InternalCodec.prototype.encoder = InternalEncoder;
      InternalCodec.prototype.decoder = InternalDecoder;

      //------------------------------------------------------------------------------

      // We use node.js internal decoder. Its signature is the same as ours.
      var StringDecoder = require('string_decoder').StringDecoder;
      if (!StringDecoder.prototype.end)
        // Node v0.8 doesn't have this method.
        StringDecoder.prototype.end = function () {};
      function InternalDecoder(options, codec) {
        StringDecoder.call(this, codec.enc);
      }
      InternalDecoder.prototype = StringDecoder.prototype;

      //------------------------------------------------------------------------------
      // Encoder is mostly trivial

      function InternalEncoder(options, codec) {
        this.enc = codec.enc;
      }
      InternalEncoder.prototype.write = function (str) {
        return Buffer.from(str, this.enc);
      };
      InternalEncoder.prototype.end = function () {};

      //------------------------------------------------------------------------------
      // Except base64 encoder, which must keep its state.

      function InternalEncoderBase64(options, codec) {
        this.prevStr = '';
      }
      InternalEncoderBase64.prototype.write = function (str) {
        str = this.prevStr + str;
        var completeQuads = str.length - str.length % 4;
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);
        return Buffer.from(str, "base64");
      };
      InternalEncoderBase64.prototype.end = function () {
        return Buffer.from(this.prevStr, "base64");
      };

      //------------------------------------------------------------------------------
      // CESU-8 encoder is also special.

      function InternalEncoderCesu8(options, codec) {}
      InternalEncoderCesu8.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length * 3),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var charCode = str.charCodeAt(i);
          // Naive implementation, but it works because CESU-8 is especially easy
          // to convert from UTF-16 (which all JS strings are encoded in).
          if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
          } else {
            // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
          }
        }
        return buf.slice(0, bufIdx);
      };
      InternalEncoderCesu8.prototype.end = function () {};

      //------------------------------------------------------------------------------
      // CESU-8 decoder is not implemented in Node v4.0+

      function InternalDecoderCesu8(options, codec) {
        this.acc = 0;
        this.contBytes = 0;
        this.accBytes = 0;
        this.defaultCharUnicode = codec.defaultCharUnicode;
      }
      InternalDecoderCesu8.prototype.write = function (buf) {
        var acc = this.acc,
          contBytes = this.contBytes,
          accBytes = this.accBytes,
          res = '';
        for (var i = 0; i < buf.length; i++) {
          var curByte = buf[i];
          if ((curByte & 0xC0) !== 0x80) {
            // Leading byte
            if (contBytes > 0) {
              // Previous code is invalid
              res += this.defaultCharUnicode;
              contBytes = 0;
            }
            if (curByte < 0x80) {
              // Single-byte code
              res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) {
              // Two-byte code
              acc = curByte & 0x1F;
              contBytes = 1;
              accBytes = 1;
            } else if (curByte < 0xF0) {
              // Three-byte code
              acc = curByte & 0x0F;
              contBytes = 2;
              accBytes = 1;
            } else {
              // Four or more are not supported for CESU-8.
              res += this.defaultCharUnicode;
            }
          } else {
            // Continuation byte
            if (contBytes > 0) {
              // We're waiting for it.
              acc = acc << 6 | curByte & 0x3f;
              contBytes--;
              accBytes++;
              if (contBytes === 0) {
                // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
                  // Actually add character.
                  res += String.fromCharCode(acc);
              }
            } else {
              // Unexpected continuation byte
              res += this.defaultCharUnicode;
            }
          }
        }
        this.acc = acc;
        this.contBytes = contBytes;
        this.accBytes = accBytes;
        return res;
      };
      InternalDecoderCesu8.prototype.end = function () {
        var res = 0;
        if (this.contBytes > 0) res += this.defaultCharUnicode;
        return res;
      };
    }, {
      "safer-buffer": 56,
      "string_decoder": 72
    }],
    16: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
      // correspond to encoded bytes (if 128 - then lower half is ASCII). 

      exports._sbcs = SBCSCodec;
      function SBCSCodec(codecOptions, iconv) {
        if (!codecOptions) throw new Error("SBCS codec is called without the data.");

        // Prepare char buffer for decoding.
        if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
        if (codecOptions.chars.length === 128) {
          var asciiString = "";
          for (var i = 0; i < 128; i++) {
            asciiString += String.fromCharCode(i);
          }
          codecOptions.chars = asciiString + codecOptions.chars;
        }
        this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');

        // Encoding buffer.
        var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
        for (var i = 0; i < codecOptions.chars.length; i++) {
          encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
        }
        this.encodeBuf = encodeBuf;
      }
      SBCSCodec.prototype.encoder = SBCSEncoder;
      SBCSCodec.prototype.decoder = SBCSDecoder;
      function SBCSEncoder(options, codec) {
        this.encodeBuf = codec.encodeBuf;
      }
      SBCSEncoder.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length);
        for (var i = 0; i < str.length; i++) {
          buf[i] = this.encodeBuf[str.charCodeAt(i)];
        }
        return buf;
      };
      SBCSEncoder.prototype.end = function () {};
      function SBCSDecoder(options, codec) {
        this.decodeBuf = codec.decodeBuf;
      }
      SBCSDecoder.prototype.write = function (buf) {
        // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
        var decodeBuf = this.decodeBuf;
        var newBuf = Buffer.alloc(buf.length * 2);
        var idx1 = 0,
          idx2 = 0;
        for (var i = 0; i < buf.length; i++) {
          idx1 = buf[i] * 2;
          idx2 = i * 2;
          newBuf[idx2] = decodeBuf[idx1];
          newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
        }
        return newBuf.toString('ucs2');
      };
      SBCSDecoder.prototype.end = function () {};
    }, {
      "safer-buffer": 56
    }],
    17: [function (require, module, exports) {
      "use strict";

      // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
      module.exports = {
        "437": "cp437",
        "737": "cp737",
        "775": "cp775",
        "850": "cp850",
        "852": "cp852",
        "855": "cp855",
        "856": "cp856",
        "857": "cp857",
        "858": "cp858",
        "860": "cp860",
        "861": "cp861",
        "862": "cp862",
        "863": "cp863",
        "864": "cp864",
        "865": "cp865",
        "866": "cp866",
        "869": "cp869",
        "874": "windows874",
        "922": "cp922",
        "1046": "cp1046",
        "1124": "cp1124",
        "1125": "cp1125",
        "1129": "cp1129",
        "1133": "cp1133",
        "1161": "cp1161",
        "1162": "cp1162",
        "1163": "cp1163",
        "1250": "windows1250",
        "1251": "windows1251",
        "1252": "windows1252",
        "1253": "windows1253",
        "1254": "windows1254",
        "1255": "windows1255",
        "1256": "windows1256",
        "1257": "windows1257",
        "1258": "windows1258",
        "28591": "iso88591",
        "28592": "iso88592",
        "28593": "iso88593",
        "28594": "iso88594",
        "28595": "iso88595",
        "28596": "iso88596",
        "28597": "iso88597",
        "28598": "iso88598",
        "28599": "iso88599",
        "28600": "iso885910",
        "28601": "iso885911",
        "28603": "iso885913",
        "28604": "iso885914",
        "28605": "iso885915",
        "28606": "iso885916",
        "windows874": {
          "type": "_sbcs",
          "chars": "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
        },
        "win874": "windows874",
        "cp874": "windows874",
        "windows1250": {
          "type": "_sbcs",
          "chars": "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
        },
        "win1250": "windows1250",
        "cp1250": "windows1250",
        "windows1251": {
          "type": "_sbcs",
          "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
        },
        "win1251": "windows1251",
        "cp1251": "windows1251",
        "windows1252": {
          "type": "_sbcs",
          "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
        },
        "win1252": "windows1252",
        "cp1252": "windows1252",
        "windows1253": {
          "type": "_sbcs",
          "chars": "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
        },
        "win1253": "windows1253",
        "cp1253": "windows1253",
        "windows1254": {
          "type": "_sbcs",
          "chars": "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
        },
        "win1254": "windows1254",
        "cp1254": "windows1254",
        "windows1255": {
          "type": "_sbcs",
          "chars": "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹֺֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
        },
        "win1255": "windows1255",
        "cp1255": "windows1255",
        "windows1256": {
          "type": "_sbcs",
          "chars": "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے"
        },
        "win1256": "windows1256",
        "cp1256": "windows1256",
        "windows1257": {
          "type": "_sbcs",
          "chars": "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙"
        },
        "win1257": "windows1257",
        "cp1257": "windows1257",
        "windows1258": {
          "type": "_sbcs",
          "chars": "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
        },
        "win1258": "windows1258",
        "cp1258": "windows1258",
        "iso88591": {
          "type": "_sbcs",
          "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
        },
        "cp28591": "iso88591",
        "iso88592": {
          "type": "_sbcs",
          "chars": " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
        },
        "cp28592": "iso88592",
        "iso88593": {
          "type": "_sbcs",
          "chars": " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙"
        },
        "cp28593": "iso88593",
        "iso88594": {
          "type": "_sbcs",
          "chars": " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙"
        },
        "cp28594": "iso88594",
        "iso88595": {
          "type": "_sbcs",
          "chars": " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ"
        },
        "cp28595": "iso88595",
        "iso88596": {
          "type": "_sbcs",
          "chars": " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������"
        },
        "cp28596": "iso88596",
        "iso88597": {
          "type": "_sbcs",
          "chars": " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
        },
        "cp28597": "iso88597",
        "iso88598": {
          "type": "_sbcs",
          "chars": " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
        },
        "cp28598": "iso88598",
        "iso88599": {
          "type": "_sbcs",
          "chars": " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
        },
        "cp28599": "iso88599",
        "iso885910": {
          "type": "_sbcs",
          "chars": " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ"
        },
        "cp28600": "iso885910",
        "iso885911": {
          "type": "_sbcs",
          "chars": " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
        },
        "cp28601": "iso885911",
        "iso885913": {
          "type": "_sbcs",
          "chars": " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’"
        },
        "cp28603": "iso885913",
        "iso885914": {
          "type": "_sbcs",
          "chars": " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ"
        },
        "cp28604": "iso885914",
        "iso885915": {
          "type": "_sbcs",
          "chars": " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
        },
        "cp28605": "iso885915",
        "iso885916": {
          "type": "_sbcs",
          "chars": " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ"
        },
        "cp28606": "iso885916",
        "cp437": {
          "type": "_sbcs",
          "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
        },
        "ibm437": "cp437",
        "csibm437": "cp437",
        "cp737": {
          "type": "_sbcs",
          "chars": "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ "
        },
        "ibm737": "cp737",
        "csibm737": "cp737",
        "cp775": {
          "type": "_sbcs",
          "chars": "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ "
        },
        "ibm775": "cp775",
        "csibm775": "cp775",
        "cp850": {
          "type": "_sbcs",
          "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
        },
        "ibm850": "cp850",
        "csibm850": "cp850",
        "cp852": {
          "type": "_sbcs",
          "chars": "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ "
        },
        "ibm852": "cp852",
        "csibm852": "cp852",
        "cp855": {
          "type": "_sbcs",
          "chars": "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ "
        },
        "ibm855": "cp855",
        "csibm855": "cp855",
        "cp856": {
          "type": "_sbcs",
          "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ "
        },
        "ibm856": "cp856",
        "csibm856": "cp856",
        "cp857": {
          "type": "_sbcs",
          "chars": "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ "
        },
        "ibm857": "cp857",
        "csibm857": "cp857",
        "cp858": {
          "type": "_sbcs",
          "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
        },
        "ibm858": "cp858",
        "csibm858": "cp858",
        "cp860": {
          "type": "_sbcs",
          "chars": "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
        },
        "ibm860": "cp860",
        "csibm860": "cp860",
        "cp861": {
          "type": "_sbcs",
          "chars": "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
        },
        "ibm861": "cp861",
        "csibm861": "cp861",
        "cp862": {
          "type": "_sbcs",
          "chars": "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
        },
        "ibm862": "cp862",
        "csibm862": "cp862",
        "cp863": {
          "type": "_sbcs",
          "chars": "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
        },
        "ibm863": "cp863",
        "csibm863": "cp863",
        "cp864": {
          "type": "_sbcs",
          "chars": "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
        },
        "ibm864": "cp864",
        "csibm864": "cp864",
        "cp865": {
          "type": "_sbcs",
          "chars": "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
        },
        "ibm865": "cp865",
        "csibm865": "cp865",
        "cp866": {
          "type": "_sbcs",
          "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ "
        },
        "ibm866": "cp866",
        "csibm866": "cp866",
        "cp869": {
          "type": "_sbcs",
          "chars": "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ "
        },
        "ibm869": "cp869",
        "csibm869": "cp869",
        "cp922": {
          "type": "_sbcs",
          "chars": " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ"
        },
        "ibm922": "cp922",
        "csibm922": "cp922",
        "cp1046": {
          "type": "_sbcs",
          "chars": "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�"
        },
        "ibm1046": "cp1046",
        "csibm1046": "cp1046",
        "cp1124": {
          "type": "_sbcs",
          "chars": " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ"
        },
        "ibm1124": "cp1124",
        "csibm1124": "cp1124",
        "cp1125": {
          "type": "_sbcs",
          "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ "
        },
        "ibm1125": "cp1125",
        "csibm1125": "cp1125",
        "cp1129": {
          "type": "_sbcs",
          "chars": " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
        },
        "ibm1129": "cp1129",
        "csibm1129": "cp1129",
        "cp1133": {
          "type": "_sbcs",
          "chars": " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�"
        },
        "ibm1133": "cp1133",
        "csibm1133": "cp1133",
        "cp1161": {
          "type": "_sbcs",
          "chars": "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ "
        },
        "ibm1161": "cp1161",
        "csibm1161": "cp1161",
        "cp1162": {
          "type": "_sbcs",
          "chars": "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
        },
        "ibm1162": "cp1162",
        "csibm1162": "cp1162",
        "cp1163": {
          "type": "_sbcs",
          "chars": " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
        },
        "ibm1163": "cp1163",
        "csibm1163": "cp1163",
        "maccroatian": {
          "type": "_sbcs",
          "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
        },
        "maccyrillic": {
          "type": "_sbcs",
          "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
        },
        "macgreek": {
          "type": "_sbcs",
          "chars": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�"
        },
        "maciceland": {
          "type": "_sbcs",
          "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
        },
        "macroman": {
          "type": "_sbcs",
          "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
        },
        "macromania": {
          "type": "_sbcs",
          "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
        },
        "macthai": {
          "type": "_sbcs",
          "chars": "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู﻿​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����"
        },
        "macturkish": {
          "type": "_sbcs",
          "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ"
        },
        "macukraine": {
          "type": "_sbcs",
          "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
        },
        "koi8r": {
          "type": "_sbcs",
          "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
        },
        "koi8u": {
          "type": "_sbcs",
          "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
        },
        "koi8ru": {
          "type": "_sbcs",
          "chars": "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
        },
        "koi8t": {
          "type": "_sbcs",
          "chars": "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
        },
        "armscii8": {
          "type": "_sbcs",
          "chars": " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�"
        },
        "rk1048": {
          "type": "_sbcs",
          "chars": "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
        },
        "tcvn": {
          "type": "_sbcs",
          "chars": "\0\xDA\u1EE4\x03\u1EEA\u1EEC\u1EEE\x07\b\t\n\x0B\f\r\x0E\x0F\x10\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
        },
        "georgianacademy": {
          "type": "_sbcs",
          "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
        },
        "georgianps": {
          "type": "_sbcs",
          "chars": "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
        },
        "pt154": {
          "type": "_sbcs",
          "chars": "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
        },
        "viscii": {
          "type": "_sbcs",
          "chars": "\0\x01\u1EB2\x03\x04\u1EB4\u1EAA\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\u1EF6\x15\x16\x17\x18\u1EF8\x1A\x1B\x1C\x1D\u1EF4\x1F !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
        },
        "iso646cn": {
          "type": "_sbcs",
          "chars": "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
        },
        "iso646jp": {
          "type": "_sbcs",
          "chars": "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0B\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
        },
        "hproman8": {
          "type": "_sbcs",
          "chars": " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�"
        },
        "macintosh": {
          "type": "_sbcs",
          "chars": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
        },
        "ascii": {
          "type": "_sbcs",
          "chars": "��������������������������������������������������������������������������������������������������������������������������������"
        },
        "tis620": {
          "type": "_sbcs",
          "chars": "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
        }
      };
    }, {}],
    18: [function (require, module, exports) {
      "use strict";

      // Manually added data to be used by sbcs codec in addition to generated one.
      module.exports = {
        // Not supported by iconv, not sure why.
        "10029": "maccenteuro",
        "maccenteuro": {
          "type": "_sbcs",
          "chars": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
        },
        "808": "cp808",
        "ibm808": "cp808",
        "cp808": {
          "type": "_sbcs",
          "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ "
        },
        "mik": {
          "type": "_sbcs",
          "chars": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя└┴┬├─┼╣║╚╔╩╦╠═╬┐░▒▓│┤№§╗╝┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
        },
        "cp720": {
          "type": "_sbcs",
          "chars": "\x80\x81\xE9\xE2\x84\xE0\x86\xE7\xEA\xEB\xE8\xEF\xEE\x8D\x8E\x8F\x90\u0651\u0652\xF4\xA4\u0640\xFB\xF9\u0621\u0622\u0623\u0624\xA3\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0636\u0637\u0638\u0639\u063A\u0641\xB5\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u2261\u064B\u064C\u064D\u064E\u064F\u0650\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
        },
        // Aliases of generated encodings.
        "ascii8bit": "ascii",
        "usascii": "ascii",
        "ansix34": "ascii",
        "ansix341968": "ascii",
        "ansix341986": "ascii",
        "csascii": "ascii",
        "cp367": "ascii",
        "ibm367": "ascii",
        "isoir6": "ascii",
        "iso646us": "ascii",
        "iso646irv": "ascii",
        "us": "ascii",
        "latin1": "iso88591",
        "latin2": "iso88592",
        "latin3": "iso88593",
        "latin4": "iso88594",
        "latin5": "iso88599",
        "latin6": "iso885910",
        "latin7": "iso885913",
        "latin8": "iso885914",
        "latin9": "iso885915",
        "latin10": "iso885916",
        "csisolatin1": "iso88591",
        "csisolatin2": "iso88592",
        "csisolatin3": "iso88593",
        "csisolatin4": "iso88594",
        "csisolatincyrillic": "iso88595",
        "csisolatinarabic": "iso88596",
        "csisolatingreek": "iso88597",
        "csisolatinhebrew": "iso88598",
        "csisolatin5": "iso88599",
        "csisolatin6": "iso885910",
        "l1": "iso88591",
        "l2": "iso88592",
        "l3": "iso88593",
        "l4": "iso88594",
        "l5": "iso88599",
        "l6": "iso885910",
        "l7": "iso885913",
        "l8": "iso885914",
        "l9": "iso885915",
        "l10": "iso885916",
        "isoir14": "iso646jp",
        "isoir57": "iso646cn",
        "isoir100": "iso88591",
        "isoir101": "iso88592",
        "isoir109": "iso88593",
        "isoir110": "iso88594",
        "isoir144": "iso88595",
        "isoir127": "iso88596",
        "isoir126": "iso88597",
        "isoir138": "iso88598",
        "isoir148": "iso88599",
        "isoir157": "iso885910",
        "isoir166": "tis620",
        "isoir179": "iso885913",
        "isoir199": "iso885914",
        "isoir203": "iso885915",
        "isoir226": "iso885916",
        "cp819": "iso88591",
        "ibm819": "iso88591",
        "cyrillic": "iso88595",
        "arabic": "iso88596",
        "arabic8": "iso88596",
        "ecma114": "iso88596",
        "asmo708": "iso88596",
        "greek": "iso88597",
        "greek8": "iso88597",
        "ecma118": "iso88597",
        "elot928": "iso88597",
        "hebrew": "iso88598",
        "hebrew8": "iso88598",
        "turkish": "iso88599",
        "turkish8": "iso88599",
        "thai": "iso885911",
        "thai8": "iso885911",
        "celtic": "iso885914",
        "celtic8": "iso885914",
        "isoceltic": "iso885914",
        "tis6200": "tis620",
        "tis62025291": "tis620",
        "tis62025330": "tis620",
        "10000": "macroman",
        "10006": "macgreek",
        "10007": "maccyrillic",
        "10079": "maciceland",
        "10081": "macturkish",
        "cspc8codepage437": "cp437",
        "cspc775baltic": "cp775",
        "cspc850multilingual": "cp850",
        "cspcp852": "cp852",
        "cspc862latinhebrew": "cp862",
        "cpgr": "cp869",
        "msee": "cp1250",
        "mscyrl": "cp1251",
        "msansi": "cp1252",
        "msgreek": "cp1253",
        "msturk": "cp1254",
        "mshebr": "cp1255",
        "msarab": "cp1256",
        "winbaltrim": "cp1257",
        "cp20866": "koi8r",
        "20866": "koi8r",
        "ibm878": "koi8r",
        "cskoi8r": "koi8r",
        "cp21866": "koi8u",
        "21866": "koi8u",
        "ibm1168": "koi8u",
        "strk10482002": "rk1048",
        "tcvn5712": "tcvn",
        "tcvn57121": "tcvn",
        "gb198880": "iso646cn",
        "cn": "iso646cn",
        "csiso14jisc6220ro": "iso646jp",
        "jisc62201969ro": "iso646jp",
        "jp": "iso646jp",
        "cshproman8": "hproman8",
        "r8": "hproman8",
        "roman8": "hproman8",
        "xroman8": "hproman8",
        "ibm1051": "hproman8",
        "mac": "macintosh",
        "csmacintosh": "macintosh"
      };
    }, {}],
    19: [function (require, module, exports) {
      module.exports = [["8740", "䏰䰲䘃䖦䕸𧉧䵷䖳𧲱䳢𧳅㮕䜶䝄䱇䱀𤊿𣘗𧍒𦺋𧃒䱗𪍑䝏䗚䲅𧱬䴇䪤䚡𦬣爥𥩔𡩣𣸆𣽡晍囻"], ["8767", "綕夝𨮹㷴霴𧯯寛𡵞媤㘥𩺰嫑宷峼杮薓𩥅瑡璝㡵𡵓𣚞𦀡㻬"], ["87a1", "𥣞㫵竼龗𤅡𨤍𣇪𠪊𣉞䌊蒄龖鐯䤰蘓墖靊鈘秐稲晠権袝瑌篅枂稬剏遆㓦珄𥶹瓆鿇垳䤯呌䄱𣚎堘穲𧭥讏䚮𦺈䆁𥶙箮𢒼鿈𢓁𢓉𢓌鿉蔄𣖻䂴鿊䓡𪷿拁灮鿋"], ["8840", "㇀", 4, "𠄌㇅𠃑𠃍㇆㇇𠃋𡿨㇈𠃊㇉㇊㇋㇌𠄎㇍㇎ĀÁǍÀĒÉĚÈŌÓǑÒ࿿Ê̄Ế࿿Ê̌ỀÊāáǎàɑēéěèīíǐìōóǒòūúǔùǖǘǚ"], ["88a1", "ǜü࿿ê̄ế࿿ê̌ềêɡ⏚⏛"], ["8940", "𪎩𡅅"], ["8943", "攊"], ["8946", "丽滝鵎釟"], ["894c", "𧜵撑会伨侨兖兴农凤务动医华发变团声处备夲头学实実岚庆总斉柾栄桥济炼电纤纬纺织经统缆缷艺苏药视设询车轧轮"], ["89a1", "琑糼緍楆竉刧"], ["89ab", "醌碸酞肼"], ["89b0", "贋胶𠧧"], ["89b5", "肟黇䳍鷉鸌䰾𩷶𧀎鸊𪄳㗁"], ["89c1", "溚舾甙"], ["89c5", "䤑马骏龙禇𨑬𡷊𠗐𢫦两亁亀亇亿仫伷㑌侽㹈倃傈㑽㒓㒥円夅凛凼刅争剹劐匧㗇厩㕑厰㕓参吣㕭㕲㚁咓咣咴咹哐哯唘唣唨㖘唿㖥㖿嗗㗅"], ["8a40", "𧶄唥"], ["8a43", "𠱂𠴕𥄫喐𢳆㧬𠍁蹆𤶸𩓥䁓𨂾睺𢰸㨴䟕𨅝𦧲𤷪擝𠵼𠾴𠳕𡃴撍蹾𠺖𠰋𠽤𢲩𨉖𤓓"], ["8a64", "𠵆𩩍𨃩䟴𤺧𢳂骲㩧𩗴㿭㔆𥋇𩟔𧣈𢵄鵮頕"], ["8a76", "䏙𦂥撴哣𢵌𢯊𡁷㧻𡁯"], ["8aa1", "𦛚𦜖𧦠擪𥁒𠱃蹨𢆡𨭌𠜱"], ["8aac", "䠋𠆩㿺塳𢶍"], ["8ab2", "𤗈𠓼𦂗𠽌𠶖啹䂻䎺"], ["8abb", "䪴𢩦𡂝膪飵𠶜捹㧾𢝵跀嚡摼㹃"], ["8ac9", "𪘁𠸉𢫏𢳉"], ["8ace", "𡃈𣧂㦒㨆𨊛㕸𥹉𢃇噒𠼱𢲲𩜠㒼氽𤸻"], ["8adf", "𧕴𢺋𢈈𪙛𨳍𠹺𠰴𦠜羓𡃏𢠃𢤹㗻𥇣𠺌𠾍𠺪㾓𠼰𠵇𡅏𠹌"], ["8af6", "𠺫𠮩𠵈𡃀𡄽㿹𢚖搲𠾭"], ["8b40", "𣏴𧘹𢯎𠵾𠵿𢱑𢱕㨘𠺘𡃇𠼮𪘲𦭐𨳒𨶙𨳊閪哌苄喹"], ["8b55", "𩻃鰦骶𧝞𢷮煀腭胬尜𦕲脴㞗卟𨂽醶𠻺𠸏𠹷𠻻㗝𤷫㘉𠳖嚯𢞵𡃉𠸐𠹸𡁸𡅈𨈇𡑕𠹹𤹐𢶤婔𡀝𡀞𡃵𡃶垜𠸑"], ["8ba1", "𧚔𨋍𠾵𠹻𥅾㜃𠾶𡆀𥋘𪊽𤧚𡠺𤅷𨉼墙剨㘚𥜽箲孨䠀䬬鼧䧧鰟鮍𥭴𣄽嗻㗲嚉丨夂𡯁屮靑𠂆乛亻㔾尣彑忄㣺扌攵歺氵氺灬爫丬犭𤣩罒礻糹罓𦉪㓁"], ["8bde", "𦍋耂肀𦘒𦥑卝衤见𧢲讠贝钅镸长门𨸏韦页风飞饣𩠐鱼鸟黄歯龜丷𠂇阝户钢"], ["8c40", "倻淾𩱳龦㷉袏𤅎灷峵䬠𥇍㕙𥴰愢𨨲辧釶熑朙玺𣊁𪄇㲋𡦀䬐磤琂冮𨜏䀉橣𪊺䈣蘏𠩯稪𩥇𨫪靕灍匤𢁾鏴盙𨧣龧矝亣俰傼丯众龨吴綋墒壐𡶶庒庙忂𢜒斋"], ["8ca1", "𣏹椙橃𣱣泿"], ["8ca7", "爀𤔅玌㻛𤨓嬕璹讃𥲤𥚕窓篬糃繬苸薗龩袐龪躹龫迏蕟駠鈡龬𨶹𡐿䁱䊢娚"], ["8cc9", "顨杫䉶圽"], ["8cce", "藖𤥻芿𧄍䲁𦵴嵻𦬕𦾾龭龮宖龯曧繛湗秊㶈䓃𣉖𢞖䎚䔶"], ["8ce6", "峕𣬚諹屸㴒𣕑嵸龲煗䕘𤃬𡸣䱷㥸㑊𠆤𦱁諌侴𠈹妿腬顖𩣺弻"], ["8d40", "𠮟"], ["8d42", "𢇁𨥭䄂䚻𩁹㼇龳𪆵䃸㟖䛷𦱆䅼𨚲𧏿䕭㣔𥒚䕡䔛䶉䱻䵶䗪㿈𤬏㙡䓞䒽䇭崾嵈嵖㷼㠏嶤嶹㠠㠸幂庽弥徃㤈㤔㤿㥍惗愽峥㦉憷憹懏㦸戬抐拥挘㧸嚱"], ["8da1", "㨃揢揻搇摚㩋擀崕嘡龟㪗斆㪽旿晓㫲暒㬢朖㭂枤栀㭘桊梄㭲㭱㭻椉楃牜楤榟榅㮼槖㯝橥橴橱檂㯬檙㯲檫檵櫔櫶殁毁毪汵沪㳋洂洆洦涁㳯涤涱渕渘温溆𨧀溻滢滚齿滨滩漤漴㵆𣽁澁澾㵪㵵熷岙㶊瀬㶑灐灔灯灿炉𠌥䏁㗱𠻘"], ["8e40", "𣻗垾𦻓焾𥟠㙎榢𨯩孴穉𥣡𩓙穥穽𥦬窻窰竂竃燑𦒍䇊竚竝竪䇯咲𥰁笋筕笩𥌎𥳾箢筯莜𥮴𦱿篐萡箒箸𥴠㶭𥱥蒒篺簆簵𥳁籄粃𤢂粦晽𤕸糉糇糦籴糳糵糎"], ["8ea1", "繧䔝𦹄絝𦻖璍綉綫焵綳緒𤁗𦀩緤㴓緵𡟹緥𨍭縝𦄡𦅚繮纒䌫鑬縧罀罁罇礶𦋐駡羗𦍑羣𡙡𠁨䕜𣝦䔃𨌺翺𦒉者耈耝耨耯𪂇𦳃耻耼聡𢜔䦉𦘦𣷣𦛨朥肧𨩈脇脚墰𢛶汿𦒘𤾸擧𡒊舘𡡞橓𤩥𤪕䑺舩𠬍𦩒𣵾俹𡓽蓢荢𦬊𤦧𣔰𡝳𣷸芪椛芳䇛"], ["8f40", "蕋苐茚𠸖𡞴㛁𣅽𣕚艻苢茘𣺋𦶣𦬅𦮗𣗎㶿茝嗬莅䔋𦶥莬菁菓㑾𦻔橗蕚㒖𦹂𢻯葘𥯤葱㷓䓤檧葊𣲵祘蒨𦮖𦹷𦹃蓞萏莑䒠蒓蓤𥲑䉀𥳀䕃蔴嫲𦺙䔧蕳䔖枿蘖"], ["8fa1", "𨘥𨘻藁𧂈蘂𡖂𧃍䕫䕪蘨㙈𡢢号𧎚虾蝱𪃸蟮𢰧螱蟚蠏噡虬桖䘏衅衆𧗠𣶹𧗤衞袜䙛袴袵揁装睷𧜏覇覊覦覩覧覼𨨥觧𧤤𧪽誜瞓釾誐𧩙竩𧬺𣾏䜓𧬸煼謌謟𥐰𥕥謿譌譍誩𤩺讐讛誯𡛟䘕衏貛𧵔𧶏貫㜥𧵓賖𧶘𧶽贒贃𡤐賛灜贑𤳉㻐起"], ["9040", "趩𨀂𡀔𤦊㭼𨆼𧄌竧躭躶軃鋔輙輭𨍥𨐒辥錃𪊟𠩐辳䤪𨧞𨔽𣶻廸𣉢迹𪀔𨚼𨔁𢌥㦀𦻗逷𨔼𧪾遡𨕬𨘋邨𨜓郄𨛦邮都酧㫰醩釄粬𨤳𡺉鈎沟鉁鉢𥖹銹𨫆𣲛𨬌𥗛"], ["90a1", "𠴱錬鍫𨫡𨯫炏嫃𨫢𨫥䥥鉄𨯬𨰹𨯿鍳鑛躼閅閦鐦閠濶䊹𢙺𨛘𡉼𣸮䧟氜陻隖䅬隣𦻕懚隶磵𨫠隽双䦡𦲸𠉴𦐐𩂯𩃥𤫑𡤕𣌊霱虂霶䨏䔽䖅𤫩灵孁霛靜𩇕靗孊𩇫靟鐥僐𣂷𣂼鞉鞟鞱鞾韀韒韠𥑬韮琜𩐳響韵𩐝𧥺䫑頴頳顋顦㬎𧅵㵑𠘰𤅜"], ["9140", "𥜆飊颷飈飇䫿𦴧𡛓喰飡飦飬鍸餹𤨩䭲𩡗𩤅駵騌騻騐驘𥜥㛄𩂱𩯕髠髢𩬅髴䰎鬔鬭𨘀倴鬴𦦨㣃𣁽魐魀𩴾婅𡡣鮎𤉋鰂鯿鰌𩹨鷔𩾷𪆒𪆫𪃡𪄣𪇟鵾鶃𪄴鸎梈"], ["91a1", "鷄𢅛𪆓𪈠𡤻𪈳鴹𪂹𪊴麐麕麞麢䴴麪麯𤍤黁㭠㧥㴝伲㞾𨰫鼂鼈䮖鐤𦶢鼗鼖鼹嚟嚊齅馸𩂋韲葿齢齩竜龎爖䮾𤥵𤦻煷𤧸𤍈𤩑玞𨯚𡣺禟𨥾𨸶鍩鏳𨩄鋬鎁鏋𨥬𤒹爗㻫睲穃烐𤑳𤏸煾𡟯炣𡢾𣖙㻇𡢅𥐯𡟸㜢𡛻𡠹㛡𡝴𡣑𥽋㜣𡛀坛𤨥𡏾𡊨"], ["9240", "𡏆𡒶蔃𣚦蔃葕𤦔𧅥𣸱𥕜𣻻𧁒䓴𣛮𩦝𦼦柹㜳㰕㷧塬𡤢栐䁗𣜿𤃡𤂋𤄏𦰡哋嚞𦚱嚒𠿟𠮨𠸍鏆𨬓鎜仸儫㠙𤐶亼𠑥𠍿佋侊𥙑婨𠆫𠏋㦙𠌊𠐔㐵伩𠋀𨺳𠉵諚𠈌亘"], ["92a1", "働儍侢伃𤨎𣺊佂倮偬傁俌俥偘僼兙兛兝兞湶𣖕𣸹𣺿浲𡢄𣺉冨凃𠗠䓝𠒣𠒒𠒑赺𨪜𠜎剙劤𠡳勡鍮䙺熌𤎌𠰠𤦬𡃤槑𠸝瑹㻞璙琔瑖玘䮎𤪼𤂍叐㖄爏𤃉喴𠍅响𠯆圝鉝雴鍦埝垍坿㘾壋媙𨩆𡛺𡝯𡜐娬妸銏婾嫏娒𥥆𡧳𡡡𤊕㛵洅瑃娡𥺃"], ["9340", "媁𨯗𠐓鏠璌𡌃焅䥲鐈𨧻鎽㞠尞岞幞幈𡦖𡥼𣫮廍孏𡤃𡤄㜁𡢠㛝𡛾㛓脪𨩇𡶺𣑲𨦨弌弎𡤧𡞫婫𡜻孄蘔𧗽衠恾𢡠𢘫忛㺸𢖯𢖾𩂈𦽳懀𠀾𠁆𢘛憙憘恵𢲛𢴇𤛔𩅍"], ["93a1", "摱𤙥𢭪㨩𢬢𣑐𩣪𢹸挷𪑛撶挱揑𤧣𢵧护𢲡搻敫楲㯴𣂎𣊭𤦉𣊫唍𣋠𡣙𩐿曎𣊉𣆳㫠䆐𥖄𨬢𥖏𡛼𥕛𥐥磮𣄃𡠪𣈴㑤𣈏𣆂𤋉暎𦴤晫䮓昰𧡰𡷫晣𣋒𣋡昞𥡲㣑𣠺𣞼㮙𣞢𣏾瓐㮖枏𤘪梶栞㯄檾㡣𣟕𤒇樳橒櫉欅𡤒攑梘橌㯗橺歗𣿀𣲚鎠鋲𨯪𨫋"], ["9440", "銉𨀞𨧜鑧涥漋𤧬浧𣽿㶏渄𤀼娽渊塇洤硂焻𤌚𤉶烱牐犇犔𤞏𤜥兹𤪤𠗫瑺𣻸𣙟𤩊𤤗𥿡㼆㺱𤫟𨰣𣼵悧㻳瓌琼鎇琷䒟𦷪䕑疃㽣𤳙𤴆㽘畕癳𪗆㬙瑨𨫌𤦫𤦎㫻"], ["94a1", "㷍𤩎㻿𤧅𤣳釺圲鍂𨫣𡡤僟𥈡𥇧睸𣈲眎眏睻𤚗𣞁㩞𤣰琸璛㺿𤪺𤫇䃈𤪖𦆮錇𥖁砞碍碈磒珐祙𧝁𥛣䄎禛蒖禥樭𣻺稺秴䅮𡛦䄲鈵秱𠵌𤦌𠊙𣶺𡝮㖗啫㕰㚪𠇔𠰍竢婙𢛵𥪯𥪜娍𠉛磰娪𥯆竾䇹籝籭䈑𥮳𥺼𥺦糍𤧹𡞰粎籼粮檲緜縇緓罎𦉡"], ["9540", "𦅜𧭈綗𥺂䉪𦭵𠤖柖𠁎𣗏埄𦐒𦏸𤥢翝笧𠠬𥫩𥵃笌𥸎駦虅驣樜𣐿㧢𤧷𦖭騟𦖠蒀𧄧𦳑䓪脷䐂胆脉腂𦞴飃𦩂艢艥𦩑葓𦶧蘐𧈛媆䅿𡡀嬫𡢡嫤𡣘蚠蜨𣶏蠭𧐢娂"], ["95a1", "衮佅袇袿裦襥襍𥚃襔𧞅𧞄𨯵𨯙𨮜𨧹㺭蒣䛵䛏㟲訽訜𩑈彍鈫𤊄旔焩烄𡡅鵭貟賩𧷜妚矃姰䍮㛔踪躧𤰉輰轊䋴汘澻𢌡䢛潹溋𡟚鯩㚵𤤯邻邗啱䤆醻鐄𨩋䁢𨫼鐧𨰝𨰻蓥訫閙閧閗閖𨴴瑅㻂𤣿𤩂𤏪㻧𣈥随𨻧𨹦𨹥㻌𤧭𤩸𣿮琒瑫㻼靁𩂰"], ["9640", "桇䨝𩂓𥟟靝鍨𨦉𨰦𨬯𦎾銺嬑譩䤼珹𤈛鞛靱餸𠼦巁𨯅𤪲頟𩓚鋶𩗗釥䓀𨭐𤩧𨭤飜𨩅㼀鈪䤥萔餻饍𧬆㷽馛䭯馪驜𨭥𥣈檏騡嫾騯𩣱䮐𩥈馼䮽䮗鍽塲𡌂堢𤦸"], ["96a1", "𡓨硄𢜟𣶸棅㵽鑘㤧慐𢞁𢥫愇鱏鱓鱻鰵鰐魿鯏𩸭鮟𪇵𪃾鴡䲮𤄄鸘䲰鴌𪆴𪃭𪃳𩤯鶥蒽𦸒𦿟𦮂藼䔳𦶤𦺄𦷰萠藮𦸀𣟗𦁤秢𣖜𣙀䤭𤧞㵢鏛銾鍈𠊿碹鉷鑍俤㑀遤𥕝砽硔碶硋𡝗𣇉𤥁㚚佲濚濙瀞瀞吔𤆵垻壳垊鴖埗焴㒯𤆬燫𦱀𤾗嬨𡞵𨩉"], ["9740", "愌嫎娋䊼𤒈㜬䭻𨧼鎻鎸𡣖𠼝葲𦳀𡐓𤋺𢰦𤏁妔𣶷𦝁綨𦅛𦂤𤦹𤦋𨧺鋥珢㻩璴𨭣𡢟㻡𤪳櫘珳珻㻖𤨾𤪔𡟙𤩦𠎧𡐤𤧥瑈𤤖炥𤥶銄珦鍟𠓾錱𨫎𨨖鎆𨯧𥗕䤵𨪂煫"], ["97a1", "𤥃𠳿嚤𠘚𠯫𠲸唂秄𡟺緾𡛂𤩐𡡒䔮鐁㜊𨫀𤦭妰𡢿𡢃𧒄媡㛢𣵛㚰鉟婹𨪁𡡢鍴㳍𠪴䪖㦊僴㵩㵌𡎜煵䋻𨈘渏𩃤䓫浗𧹏灧沯㳖𣿭𣸭渂漌㵯𠏵畑㚼㓈䚀㻚䡱姄鉮䤾轁𨰜𦯀堒埈㛖𡑒烾𤍢𤩱𢿣𡊰𢎽梹楧𡎘𣓥𧯴𣛟𨪃𣟖𣏺𤲟樚𣚭𦲷萾䓟䓎"], ["9840", "𦴦𦵑𦲂𦿞漗𧄉茽𡜺菭𦲀𧁓𡟛妉媂𡞳婡婱𡤅𤇼㜭姯𡜼㛇熎鎐暚𤊥婮娫𤊓樫𣻹𧜶𤑛𤋊焝𤉙𨧡侰𦴨峂𤓎𧹍𤎽樌𤉖𡌄炦焳𤏩㶥泟勇𤩏繥姫崯㷳彜𤩝𡟟綤萦"], ["98a1", "咅𣫺𣌀𠈔坾𠣕𠘙㿥𡾞𪊶瀃𩅛嵰玏糓𨩙𩐠俈翧狍猐𧫴猸猹𥛶獁獈㺩𧬘遬燵𤣲珡臶㻊県㻑沢国琙琞琟㻢㻰㻴㻺瓓㼎㽓畂畭畲疍㽼痈痜㿀癍㿗癴㿜発𤽜熈嘣覀塩䀝睃䀹条䁅㗛瞘䁪䁯属瞾矋売砘点砜䂨砹硇硑硦葈𥔵礳栃礲䄃"], ["9940", "䄉禑禙辻稆込䅧窑䆲窼艹䇄竏竛䇏両筢筬筻簒簛䉠䉺类粜䊌粸䊔糭输烀𠳏総緔緐緽羮羴犟䎗耠耥笹耮耱联㷌垴炠肷胩䏭脌猪脎脒畠脔䐁㬹腖腙腚"], ["99a1", "䐓堺腼膄䐥膓䐭膥埯臁臤艔䒏芦艶苊苘苿䒰荗险榊萅烵葤惣蒈䔄蒾蓡蓸蔐蔸蕒䔻蕯蕰藠䕷虲蚒蚲蛯际螋䘆䘗袮裿褤襇覑𧥧訩訸誔誴豑賔賲贜䞘塟跃䟭仮踺嗘坔蹱嗵躰䠷軎転軤軭軲辷迁迊迌逳駄䢭飠鈓䤞鈨鉘鉫銱銮銿"], ["9a40", "鋣鋫鋳鋴鋽鍃鎄鎭䥅䥑麿鐗匁鐝鐭鐾䥪鑔鑹锭関䦧间阳䧥枠䨤靀䨵鞲韂噔䫤惨颹䬙飱塄餎餙冴餜餷饂饝饢䭰駅䮝騼鬏窃魩鮁鯝鯱鯴䱭鰠㝯𡯂鵉鰺"], ["9aa1", "黾噐鶓鶽鷀鷼银辶鹻麬麱麽黆铜黢黱黸竈齄𠂔𠊷𠎠椚铃妬𠓗塀铁㞹𠗕𠘕𠙶𡚺块煳𠫂𠫍𠮿呪吆𠯋咞𠯻𠰻𠱓𠱥𠱼惧𠲍噺𠲵𠳝𠳭𠵯𠶲𠷈楕鰯螥𠸄𠸎𠻗𠾐𠼭𠹳尠𠾼帋𡁜𡁏𡁶朞𡁻𡂈𡂖㙇𡂿𡃓𡄯𡄻卤蒭𡋣𡍵𡌶讁𡕷𡘙𡟃𡟇乸炻𡠭𡥪"], ["9b40", "𡨭𡩅𡰪𡱰𡲬𡻈拃𡻕𡼕熘桕𢁅槩㛈𢉼𢏗𢏺𢜪𢡱𢥏苽𢥧𢦓𢫕覥𢫨辠𢬎鞸𢬿顇骽𢱌"], ["9b62", "𢲈𢲷𥯨𢴈𢴒𢶷𢶕𢹂𢽴𢿌𣀳𣁦𣌟𣏞徱晈暿𧩹𣕧𣗳爁𤦺矗𣘚𣜖纇𠍆墵朎"], ["9ba1", "椘𣪧𧙗𥿢𣸑𣺹𧗾𢂚䣐䪸𤄙𨪚𤋮𤌍𤀻𤌴𤎖𤩅𠗊凒𠘑妟𡺨㮾𣳿𤐄𤓖垈𤙴㦛𤜯𨗨𩧉㝢𢇃譞𨭎駖𤠒𤣻𤨕爉𤫀𠱸奥𤺥𤾆𠝹軚𥀬劏圿煱𥊙𥐙𣽊𤪧喼𥑆𥑮𦭒釔㑳𥔿𧘲𥕞䜘𥕢𥕦𥟇𤤿𥡝偦㓻𣏌惞𥤃䝼𨥈𥪮𥮉𥰆𡶐垡煑澶𦄂𧰒遖𦆲𤾚譢𦐂𦑊"], ["9c40", "嵛𦯷輶𦒄𡤜諪𤧶𦒈𣿯𦔒䯀𦖿𦚵𢜛鑥𥟡憕娧晉侻嚹𤔡𦛼乪𤤴陖涏𦲽㘘襷𦞙𦡮𦐑𦡞營𦣇筂𩃀𠨑𦤦鄄𦤹穅鷰𦧺騦𦨭㙟𦑩𠀡禃𦨴𦭛崬𣔙菏𦮝䛐𦲤画补𦶮墶"], ["9ca1", "㜜𢖍𧁋𧇍㱔𧊀𧊅銁𢅺𧊋錰𧋦𤧐氹钟𧑐𠻸蠧裵𢤦𨑳𡞱溸𤨪𡠠㦤㚹尐秣䔿暶𩲭𩢤襃𧟌𧡘囖䃟𡘊㦡𣜯𨃨𡏅熭荦𧧝𩆨婧䲷𧂯𨦫𧧽𧨊𧬋𧵦𤅺筃祾𨀉澵𪋟樃𨌘厢𦸇鎿栶靝𨅯𨀣𦦵𡏭𣈯𨁈嶅𨰰𨂃圕頣𨥉嶫𤦈斾槕叒𤪥𣾁㰑朶𨂐𨃴𨄮𡾡𨅏"], ["9d40", "𨆉𨆯𨈚𨌆𨌯𨎊㗊𨑨𨚪䣺揦𨥖砈鉕𨦸䏲𨧧䏟𨧨𨭆𨯔姸𨰉輋𨿅𩃬筑𩄐𩄼㷷𩅞𤫊运犏嚋𩓧𩗩𩖰𩖸𩜲𩣑𩥉𩥪𩧃𩨨𩬎𩵚𩶛纟𩻸𩼣䲤镇𪊓熢𪋿䶑递𪗋䶜𠲜达嗁"], ["9da1", "辺𢒰边𤪓䔉繿潖檱仪㓤𨬬𧢝㜺躀𡟵𨀤𨭬𨮙𧨾𦚯㷫𧙕𣲷𥘵𥥖亚𥺁𦉘嚿𠹭踎孭𣺈𤲞揞拐𡟶𡡻攰嘭𥱊吚𥌑㷆𩶘䱽嘢嘞罉𥻘奵𣵀蝰东𠿪𠵉𣚺脗鵞贘瘻鱅癎瞹鍅吲腈苷嘥脲萘肽嗪祢噃吖𠺝㗎嘅嗱曱𨋢㘭甴嗰喺咗啲𠱁𠲖廐𥅈𠹶𢱢"], ["9e40", "𠺢麫絚嗞𡁵抝靭咔賍燶酶揼掹揾啩𢭃鱲𢺳冚㓟𠶧冧呍唞唓癦踭𦢊疱肶蠄螆裇膶萜𡃁䓬猄𤜆宐茋𦢓噻𢛴𧴯𤆣𧵳𦻐𧊶酰𡇙鈈𣳼𪚩𠺬𠻹牦𡲢䝎𤿂𧿹𠿫䃺"], ["9ea1", "鱝攟𢶠䣳𤟠𩵼𠿬𠸊恢𧖣𠿭"], ["9ead", "𦁈𡆇熣纎鵐业丄㕷嬍沲卧㚬㧜卽㚥𤘘墚𤭮舭呋垪𥪕𠥹"], ["9ec5", "㩒𢑥獴𩺬䴉鯭𣳾𩼰䱛𤾩𩖞𩿞葜𣶶𧊲𦞳𣜠挮紥𣻷𣸬㨪逈勌㹴㙺䗩𠒎癀嫰𠺶硺𧼮墧䂿噼鮋嵴癔𪐴麅䳡痹㟻愙𣃚𤏲"], ["9ef5", "噝𡊩垧𤥣𩸆刴𧂮㖭汊鵼"], ["9f40", "籖鬹埞𡝬屓擓𩓐𦌵𧅤蚭𠴨𦴢𤫢𠵱"], ["9f4f", "凾𡼏嶎霃𡷑麁遌笟鬂峑箣扨挵髿篏鬪籾鬮籂粆鰕篼鬉鼗鰛𤤾齚啳寃俽麘俲剠㸆勑坧偖妷帒韈鶫轜呩鞴饀鞺匬愰"], ["9fa1", "椬叚鰊鴂䰻陁榀傦畆𡝭駚剳"], ["9fae", "酙隁酜"], ["9fb2", "酑𨺗捿𦴣櫊嘑醎畺抅𠏼獏籰𥰡𣳽"], ["9fc1", "𤤙盖鮝个𠳔莾衂"], ["9fc9", "届槀僭坺刟巵从氱𠇲伹咜哚劚趂㗾弌㗳"], ["9fdb", "歒酼龥鮗頮颴骺麨麄煺笔"], ["9fe7", "毺蠘罸"], ["9feb", "嘠𪙊蹷齓"], ["9ff0", "跔蹏鸜踁抂𨍽踨蹵竓𤩷稾磘泪詧瘇"], ["a040", "𨩚鼦泎蟖痃𪊲硓咢贌狢獱謭猂瓱賫𤪻蘯徺袠䒷"], ["a055", "𡠻𦸅"], ["a058", "詾𢔛"], ["a05b", "惽癧髗鵄鍮鮏蟵"], ["a063", "蠏賷猬霡鮰㗖犲䰇籑饊𦅙慙䰄麖慽"], ["a073", "坟慯抦戹拎㩜懢厪𣏵捤栂㗒"], ["a0a1", "嵗𨯂迚𨸹"], ["a0a6", "僙𡵆礆匲阸𠼻䁥"], ["a0ae", "矾"], ["a0b0", "糂𥼚糚稭聦聣絍甅瓲覔舚朌聢𧒆聛瓰脃眤覉𦟌畓𦻑螩蟎臈螌詉貭譃眫瓸蓚㘵榲趦"], ["a0d4", "覩瑨涹蟁𤀑瓧㷛煶悤憜㳑煢恷"], ["a0e2", "罱𨬭牐惩䭾删㰘𣳇𥻗𧙖𥔱𡥄𡋾𩤃𦷜𧂭峁𦆭𨨏𣙷𠃮𦡆𤼎䕢嬟𦍌齐麦𦉫"], ["a3c0", "␀", 31, "␡"], ["c6a1", "①", 9, "⑴", 9, "ⅰ", 9, "丶丿亅亠冂冖冫勹匸卩厶夊宀巛⼳广廴彐彡攴无疒癶辵隶¨ˆヽヾゝゞ〃仝々〆〇ー［］✽ぁ", 23], ["c740", "す", 58, "ァアィイ"], ["c7a1", "ゥ", 81, "А", 5, "ЁЖ", 4], ["c840", "Л", 26, "ёж", 25, "⇧↸↹㇏𠃌乚𠂊刂䒑"], ["c8a1", "龰冈龱𧘇"], ["c8cd", "￢￤＇＂㈱№℡゛゜⺀⺄⺆⺇⺈⺊⺌⺍⺕⺜⺝⺥⺧⺪⺬⺮⺶⺼⺾⻆⻊⻌⻍⻏⻖⻗⻞⻣"], ["c8f5", "ʃɐɛɔɵœøŋʊɪ"], ["f9fe", "￭"], ["fa40", "𠕇鋛𠗟𣿅蕌䊵珯况㙉𤥂𨧤鍄𡧛苮𣳈砼杄拟𤤳𨦪𠊠𦮳𡌅侫𢓭倈𦴩𧪄𣘀𤪱𢔓倩𠍾徤𠎀𠍇滛𠐟偽儁㑺儎顬㝃萖𤦤𠒇兠𣎴兪𠯿𢃼𠋥𢔰𠖎𣈳𡦃宂蝽𠖳𣲙冲冸"], ["faa1", "鴴凉减凑㳜凓𤪦决凢卂凭菍椾𣜭彻刋刦刼劵剗劔効勅簕蕂勠蘍𦬓包𨫞啉滙𣾀𠥔𣿬匳卄𠯢泋𡜦栛珕恊㺪㣌𡛨燝䒢卭却𨚫卾卿𡖖𡘓矦厓𨪛厠厫厮玧𥝲㽙玜叁叅汉义埾叙㪫𠮏叠𣿫𢶣叶𠱷吓灹唫晗浛呭𦭓𠵴啝咏咤䞦𡜍𠻝㶴𠵍"], ["fb40", "𨦼𢚘啇䳭启琗喆喩嘅𡣗𤀺䕒𤐵暳𡂴嘷曍𣊊暤暭噍噏磱囱鞇叾圀囯园𨭦㘣𡉏坆𤆥汮炋坂㚱𦱾埦𡐖堃𡑔𤍣堦𤯵塜墪㕡壠壜𡈼壻寿坃𪅐𤉸鏓㖡够梦㛃湙"], ["fba1", "𡘾娤啓𡚒蔅姉𠵎𦲁𦴪𡟜姙𡟻𡞲𦶦浱𡠨𡛕姹𦹅媫婣㛦𤦩婷㜈媖瑥嫓𦾡𢕔㶅𡤑㜲𡚸広勐孶斈孼𧨎䀄䡝𠈄寕慠𡨴𥧌𠖥寳宝䴐尅𡭄尓珎尔𡲥𦬨屉䣝岅峩峯嶋𡷹𡸷崐崘嵆𡺤岺巗苼㠭𤤁𢁉𢅳芇㠶㯂帮檊幵幺𤒼𠳓厦亷廐厨𡝱帉廴𨒂"], ["fc40", "廹廻㢠廼栾鐛弍𠇁弢㫞䢮𡌺强𦢈𢏐彘𢑱彣鞽𦹮彲鍀𨨶徧嶶㵟𥉐𡽪𧃸𢙨釖𠊞𨨩怱暅𡡷㥣㷇㘹垐𢞴祱㹀悞悤悳𤦂𤦏𧩓璤僡媠慤萤慂慈𦻒憁凴𠙖憇宪𣾷"], ["fca1", "𢡟懓𨮝𩥝懐㤲𢦀𢣁怣慜攞掋𠄘担𡝰拕𢸍捬𤧟㨗搸揸𡎎𡟼撐澊𢸶頔𤂌𥜝擡擥鑻㩦携㩗敍漖𤨨𤨣斅敭敟𣁾斵𤥀䬷旑䃘𡠩无旣忟𣐀昘𣇷𣇸晄𣆤𣆥晋𠹵晧𥇦晳晴𡸽𣈱𨗴𣇈𥌓矅𢣷馤朂𤎜𤨡㬫槺𣟂杞杧杢𤇍𩃭柗䓩栢湐鈼栁𣏦𦶠桝"], ["fd40", "𣑯槡樋𨫟楳棃𣗍椁椀㴲㨁𣘼㮀枬楡𨩊䋼椶榘㮡𠏉荣傐槹𣙙𢄪橅𣜃檝㯳枱櫈𩆜㰍欝𠤣惞欵歴𢟍溵𣫛𠎵𡥘㝀吡𣭚毡𣻼毜氷𢒋𤣱𦭑汚舦汹𣶼䓅𣶽𤆤𤤌𤤀"], ["fda1", "𣳉㛥㳫𠴲鮃𣇹𢒑羏样𦴥𦶡𦷫涖浜湼漄𤥿𤂅𦹲蔳𦽴凇沜渝萮𨬡港𣸯瑓𣾂秌湏媑𣁋濸㜍澝𣸰滺𡒗𤀽䕕鏰潄潜㵎潴𩅰㴻澟𤅄濓𤂑𤅕𤀹𣿰𣾴𤄿凟𤅖𤅗𤅀𦇝灋灾炧炁烌烕烖烟䄄㷨熴熖𤉷焫煅媈煊煮岜𤍥煏鍢𤋁焬𤑚𤨧𤨢熺𨯨炽爎"], ["fe40", "鑂爕夑鑃爤鍁𥘅爮牀𤥴梽牕牗㹕𣁄栍漽犂猪猫𤠣𨠫䣭𨠄猨献珏玪𠰺𦨮珉瑉𤇢𡛧𤨤昣㛅𤦷𤦍𤧻珷琕椃𤨦琹𠗃㻗瑜𢢭瑠𨺲瑇珤瑶莹瑬㜰瑴鏱樬璂䥓𤪌"], ["fea1", "𤅟𤩹𨮏孆𨰃𡢞瓈𡦈甎瓩甞𨻙𡩋寗𨺬鎅畍畊畧畮𤾂㼄𤴓疎瑝疞疴瘂瘬癑癏癯癶𦏵皐臯㟸𦤑𦤎皡皥皷盌𦾟葢𥂝𥅽𡸜眞眦着撯𥈠睘𣊬瞯𨥤𨥨𡛁矴砉𡍶𤨒棊碯磇磓隥礮𥗠磗礴碱𧘌辸袄𨬫𦂃𢘜禆褀椂禀𥡗禝𧬹礼禩渪𧄦㺨秆𩄍秔"]];
    }, {}],
    20: [function (require, module, exports) {
      module.exports = [["0", "\0", 127, "€"], ["8140", "丂丄丅丆丏丒丗丟丠両丣並丩丮丯丱丳丵丷丼乀乁乂乄乆乊乑乕乗乚乛乢乣乤乥乧乨乪", 5, "乲乴", 9, "乿", 6, "亇亊"], ["8180", "亐亖亗亙亜亝亞亣亪亯亰亱亴亶亷亸亹亼亽亾仈仌仏仐仒仚仛仜仠仢仦仧仩仭仮仯仱仴仸仹仺仼仾伀伂", 6, "伋伌伒", 4, "伜伝伡伣伨伩伬伭伮伱伳伵伷伹伻伾", 4, "佄佅佇", 5, "佒佔佖佡佢佦佨佪佫佭佮佱佲併佷佸佹佺佽侀侁侂侅來侇侊侌侎侐侒侓侕侖侘侙侚侜侞侟価侢"], ["8240", "侤侫侭侰", 4, "侶", 8, "俀俁係俆俇俈俉俋俌俍俒", 4, "俙俛俠俢俤俥俧俫俬俰俲俴俵俶俷俹俻俼俽俿", 11], ["8280", "個倎倐們倓倕倖倗倛倝倞倠倢倣値倧倫倯", 10, "倻倽倿偀偁偂偄偅偆偉偊偋偍偐", 4, "偖偗偘偙偛偝", 7, "偦", 5, "偭", 8, "偸偹偺偼偽傁傂傃傄傆傇傉傊傋傌傎", 20, "傤傦傪傫傭", 4, "傳", 6, "傼"], ["8340", "傽", 17, "僐", 5, "僗僘僙僛", 10, "僨僩僪僫僯僰僱僲僴僶", 4, "僼", 9, "儈"], ["8380", "儉儊儌", 5, "儓", 13, "儢", 28, "兂兇兊兌兎兏児兒兓兗兘兙兛兝", 4, "兣兤兦內兩兪兯兲兺兾兿冃冄円冇冊冋冎冏冐冑冓冔冘冚冝冞冟冡冣冦", 4, "冭冮冴冸冹冺冾冿凁凂凃凅凈凊凍凎凐凒", 5], ["8440", "凘凙凚凜凞凟凢凣凥", 5, "凬凮凱凲凴凷凾刄刅刉刋刌刏刐刓刔刕刜刞刟刡刢刣別刦刧刪刬刯刱刲刴刵刼刾剄", 5, "剋剎剏剒剓剕剗剘"], ["8480", "剙剚剛剝剟剠剢剣剤剦剨剫剬剭剮剰剱剳", 9, "剾劀劃", 4, "劉", 6, "劑劒劔", 6, "劜劤劥劦劧劮劯劰労", 9, "勀勁勂勄勅勆勈勊勌勍勎勏勑勓勔動勗務", 5, "勠勡勢勣勥", 10, "勱", 7, "勻勼勽匁匂匃匄匇匉匊匋匌匎"], ["8540", "匑匒匓匔匘匛匜匞匟匢匤匥匧匨匩匫匬匭匯", 9, "匼匽區卂卄卆卋卌卍卐協単卙卛卝卥卨卪卬卭卲卶卹卻卼卽卾厀厁厃厇厈厊厎厏"], ["8580", "厐", 4, "厖厗厙厛厜厞厠厡厤厧厪厫厬厭厯", 6, "厷厸厹厺厼厽厾叀參", 4, "収叏叐叒叓叕叚叜叝叞叡叢叧叴叺叾叿吀吂吅吇吋吔吘吙吚吜吢吤吥吪吰吳吶吷吺吽吿呁呂呄呅呇呉呌呍呎呏呑呚呝", 4, "呣呥呧呩", 7, "呴呹呺呾呿咁咃咅咇咈咉咊咍咑咓咗咘咜咞咟咠咡"], ["8640", "咢咥咮咰咲咵咶咷咹咺咼咾哃哅哊哋哖哘哛哠", 4, "哫哬哯哰哱哴", 5, "哻哾唀唂唃唄唅唈唊", 4, "唒唓唕", 5, "唜唝唞唟唡唥唦"], ["8680", "唨唩唫唭唲唴唵唶唸唹唺唻唽啀啂啅啇啈啋", 4, "啑啒啓啔啗", 4, "啝啞啟啠啢啣啨啩啫啯", 5, "啹啺啽啿喅喆喌喍喎喐喒喓喕喖喗喚喛喞喠", 6, "喨", 8, "喲喴営喸喺喼喿", 4, "嗆嗇嗈嗊嗋嗎嗏嗐嗕嗗", 4, "嗞嗠嗢嗧嗩嗭嗮嗰嗱嗴嗶嗸", 4, "嗿嘂嘃嘄嘅"], ["8740", "嘆嘇嘊嘋嘍嘐", 7, "嘙嘚嘜嘝嘠嘡嘢嘥嘦嘨嘩嘪嘫嘮嘯嘰嘳嘵嘷嘸嘺嘼嘽嘾噀", 11, "噏", 4, "噕噖噚噛噝", 4], ["8780", "噣噥噦噧噭噮噯噰噲噳噴噵噷噸噹噺噽", 7, "嚇", 6, "嚐嚑嚒嚔", 14, "嚤", 10, "嚰", 6, "嚸嚹嚺嚻嚽", 12, "囋", 8, "囕囖囘囙囜団囥", 5, "囬囮囯囲図囶囷囸囻囼圀圁圂圅圇國", 6], ["8840", "園", 9, "圝圞圠圡圢圤圥圦圧圫圱圲圴", 4, "圼圽圿坁坃坄坅坆坈坉坋坒", 4, "坘坙坢坣坥坧坬坮坰坱坲坴坵坸坹坺坽坾坿垀"], ["8880", "垁垇垈垉垊垍", 4, "垔", 6, "垜垝垞垟垥垨垪垬垯垰垱垳垵垶垷垹", 8, "埄", 6, "埌埍埐埑埓埖埗埛埜埞埡埢埣埥", 7, "埮埰埱埲埳埵埶執埻埼埾埿堁堃堄堅堈堉堊堌堎堏堐堒堓堔堖堗堘堚堛堜堝堟堢堣堥", 4, "堫", 4, "報堲堳場堶", 7], ["8940", "堾", 5, "塅", 6, "塎塏塐塒塓塕塖塗塙", 4, "塟", 5, "塦", 4, "塭", 16, "塿墂墄墆墇墈墊墋墌"], ["8980", "墍", 4, "墔", 4, "墛墜墝墠", 7, "墪", 17, "墽墾墿壀壂壃壄壆", 10, "壒壓壔壖", 13, "壥", 5, "壭壯壱売壴壵壷壸壺", 7, "夃夅夆夈", 4, "夎夐夑夒夓夗夘夛夝夞夠夡夢夣夦夨夬夰夲夳夵夶夻"], ["8a40", "夽夾夿奀奃奅奆奊奌奍奐奒奓奙奛", 4, "奡奣奤奦", 12, "奵奷奺奻奼奾奿妀妅妉妋妌妎妏妐妑妔妕妘妚妛妜妝妟妠妡妢妦"], ["8a80", "妧妬妭妰妱妳", 5, "妺妼妽妿", 6, "姇姈姉姌姍姎姏姕姖姙姛姞", 4, "姤姦姧姩姪姫姭", 11, "姺姼姽姾娀娂娊娋娍娎娏娐娒娔娕娖娗娙娚娛娝娞娡娢娤娦娧娨娪", 6, "娳娵娷", 4, "娽娾娿婁", 4, "婇婈婋", 9, "婖婗婘婙婛", 5], ["8b40", "婡婣婤婥婦婨婩婫", 8, "婸婹婻婼婽婾媀", 17, "媓", 6, "媜", 13, "媫媬"], ["8b80", "媭", 4, "媴媶媷媹", 4, "媿嫀嫃", 5, "嫊嫋嫍", 4, "嫓嫕嫗嫙嫚嫛嫝嫞嫟嫢嫤嫥嫧嫨嫪嫬", 4, "嫲", 22, "嬊", 11, "嬘", 25, "嬳嬵嬶嬸", 7, "孁", 6], ["8c40", "孈", 7, "孒孖孞孠孡孧孨孫孭孮孯孲孴孶孷學孹孻孼孾孿宂宆宊宍宎宐宑宒宔宖実宧宨宩宬宭宮宯宱宲宷宺宻宼寀寁寃寈寉寊寋寍寎寏"], ["8c80", "寑寔", 8, "寠寢寣實寧審", 4, "寯寱", 6, "寽対尀専尃尅將專尋尌對導尐尒尓尗尙尛尞尟尠尡尣尦尨尩尪尫尭尮尯尰尲尳尵尶尷屃屄屆屇屌屍屒屓屔屖屗屘屚屛屜屝屟屢層屧", 6, "屰屲", 6, "屻屼屽屾岀岃", 4, "岉岊岋岎岏岒岓岕岝", 4, "岤", 4], ["8d40", "岪岮岯岰岲岴岶岹岺岻岼岾峀峂峃峅", 5, "峌", 5, "峓", 5, "峚", 6, "峢峣峧峩峫峬峮峯峱", 9, "峼", 4], ["8d80", "崁崄崅崈", 5, "崏", 4, "崕崗崘崙崚崜崝崟", 4, "崥崨崪崫崬崯", 4, "崵", 7, "崿", 7, "嵈嵉嵍", 10, "嵙嵚嵜嵞", 10, "嵪嵭嵮嵰嵱嵲嵳嵵", 12, "嶃", 21, "嶚嶛嶜嶞嶟嶠"], ["8e40", "嶡", 21, "嶸", 12, "巆", 6, "巎", 12, "巜巟巠巣巤巪巬巭"], ["8e80", "巰巵巶巸", 4, "巿帀帄帇帉帊帋帍帎帒帓帗帞", 7, "帨", 4, "帯帰帲", 4, "帹帺帾帿幀幁幃幆", 5, "幍", 6, "幖", 4, "幜幝幟幠幣", 14, "幵幷幹幾庁庂広庅庈庉庌庍庎庒庘庛庝庡庢庣庤庨", 4, "庮", 4, "庴庺庻庼庽庿", 6], ["8f40", "廆廇廈廋", 5, "廔廕廗廘廙廚廜", 11, "廩廫", 8, "廵廸廹廻廼廽弅弆弇弉弌弍弎弐弒弔弖弙弚弜弝弞弡弢弣弤"], ["8f80", "弨弫弬弮弰弲", 6, "弻弽弾弿彁", 14, "彑彔彙彚彛彜彞彟彠彣彥彧彨彫彮彯彲彴彵彶彸彺彽彾彿徃徆徍徎徏徑従徔徖徚徛徝從徟徠徢", 5, "復徫徬徯", 5, "徶徸徹徺徻徾", 4, "忇忈忊忋忎忓忔忕忚忛応忞忟忢忣忥忦忨忩忬忯忰忲忳忴忶忷忹忺忼怇"], ["9040", "怈怉怋怌怐怑怓怗怘怚怞怟怢怣怤怬怭怮怰", 4, "怶", 4, "怽怾恀恄", 6, "恌恎恏恑恓恔恖恗恘恛恜恞恟恠恡恥恦恮恱恲恴恵恷恾悀"], ["9080", "悁悂悅悆悇悈悊悋悎悏悐悑悓悕悗悘悙悜悞悡悢悤悥悧悩悪悮悰悳悵悶悷悹悺悽", 7, "惇惈惉惌", 4, "惒惓惔惖惗惙惛惞惡", 4, "惪惱惲惵惷惸惻", 4, "愂愃愄愅愇愊愋愌愐", 4, "愖愗愘愙愛愜愝愞愡愢愥愨愩愪愬", 18, "慀", 6], ["9140", "慇慉態慍慏慐慒慓慔慖", 6, "慞慟慠慡慣慤慥慦慩", 6, "慱慲慳慴慶慸", 18, "憌憍憏", 4, "憕"], ["9180", "憖", 6, "憞", 8, "憪憫憭", 9, "憸", 5, "憿懀懁懃", 4, "應懌", 4, "懓懕", 16, "懧", 13, "懶", 8, "戀", 5, "戇戉戓戔戙戜戝戞戠戣戦戧戨戩戫戭戯戰戱戲戵戶戸", 4, "扂扄扅扆扊"], ["9240", "扏扐払扖扗扙扚扜", 6, "扤扥扨扱扲扴扵扷扸扺扻扽抁抂抃抅抆抇抈抋", 5, "抔抙抜抝択抣抦抧抩抪抭抮抯抰抲抳抴抶抷抸抺抾拀拁"], ["9280", "拃拋拏拑拕拝拞拠拡拤拪拫拰拲拵拸拹拺拻挀挃挄挅挆挊挋挌挍挏挐挒挓挔挕挗挘挙挜挦挧挩挬挭挮挰挱挳", 5, "挻挼挾挿捀捁捄捇捈捊捑捒捓捔捖", 7, "捠捤捥捦捨捪捫捬捯捰捲捳捴捵捸捹捼捽捾捿掁掃掄掅掆掋掍掑掓掔掕掗掙", 6, "採掤掦掫掯掱掲掵掶掹掻掽掿揀"], ["9340", "揁揂揃揅揇揈揊揋揌揑揓揔揕揗", 6, "揟揢揤", 4, "揫揬揮揯揰揱揳揵揷揹揺揻揼揾搃搄搆", 4, "損搎搑搒搕", 5, "搝搟搢搣搤"], ["9380", "搥搧搨搩搫搮", 5, "搵", 4, "搻搼搾摀摂摃摉摋", 6, "摓摕摖摗摙", 4, "摟", 7, "摨摪摫摬摮", 9, "摻", 6, "撃撆撈", 8, "撓撔撗撘撚撛撜撝撟", 4, "撥撦撧撨撪撫撯撱撲撳撴撶撹撻撽撾撿擁擃擄擆", 6, "擏擑擓擔擕擖擙據"], ["9440", "擛擜擝擟擠擡擣擥擧", 24, "攁", 7, "攊", 7, "攓", 4, "攙", 8], ["9480", "攢攣攤攦", 4, "攬攭攰攱攲攳攷攺攼攽敀", 4, "敆敇敊敋敍敎敐敒敓敔敗敘敚敜敟敠敡敤敥敧敨敩敪敭敮敯敱敳敵敶數", 14, "斈斉斊斍斎斏斒斔斕斖斘斚斝斞斠斢斣斦斨斪斬斮斱", 7, "斺斻斾斿旀旂旇旈旉旊旍旐旑旓旔旕旘", 7, "旡旣旤旪旫"], ["9540", "旲旳旴旵旸旹旻", 4, "昁昄昅昇昈昉昋昍昐昑昒昖昗昘昚昛昜昞昡昢昣昤昦昩昪昫昬昮昰昲昳昷", 4, "昽昿晀時晄", 6, "晍晎晐晑晘"], ["9580", "晙晛晜晝晞晠晢晣晥晧晩", 4, "晱晲晳晵晸晹晻晼晽晿暀暁暃暅暆暈暉暊暋暍暎暏暐暒暓暔暕暘", 4, "暞", 8, "暩", 4, "暯", 4, "暵暶暷暸暺暻暼暽暿", 25, "曚曞", 7, "曧曨曪", 5, "曱曵曶書曺曻曽朁朂會"], ["9640", "朄朅朆朇朌朎朏朑朒朓朖朘朙朚朜朞朠", 5, "朧朩朮朰朲朳朶朷朸朹朻朼朾朿杁杄杅杇杊杋杍杒杔杕杗", 4, "杝杢杣杤杦杧杫杬杮東杴杶"], ["9680", "杸杹杺杻杽枀枂枃枅枆枈枊枌枍枎枏枑枒枓枔枖枙枛枟枠枡枤枦枩枬枮枱枲枴枹", 7, "柂柅", 9, "柕柖柗柛柟柡柣柤柦柧柨柪柫柭柮柲柵", 7, "柾栁栂栃栄栆栍栐栒栔栕栘", 4, "栞栟栠栢", 6, "栫", 6, "栴栵栶栺栻栿桇桋桍桏桒桖", 5], ["9740", "桜桝桞桟桪桬", 7, "桵桸", 8, "梂梄梇", 7, "梐梑梒梔梕梖梘", 9, "梣梤梥梩梪梫梬梮梱梲梴梶梷梸"], ["9780", "梹", 6, "棁棃", 5, "棊棌棎棏棐棑棓棔棖棗棙棛", 4, "棡棢棤", 9, "棯棲棳棴棶棷棸棻棽棾棿椀椂椃椄椆", 4, "椌椏椑椓", 11, "椡椢椣椥", 7, "椮椯椱椲椳椵椶椷椸椺椻椼椾楀楁楃", 16, "楕楖楘楙楛楜楟"], ["9840", "楡楢楤楥楧楨楩楪楬業楯楰楲", 4, "楺楻楽楾楿榁榃榅榊榋榌榎", 5, "榖榗榙榚榝", 9, "榩榪榬榮榯榰榲榳榵榶榸榹榺榼榽"], ["9880", "榾榿槀槂", 7, "構槍槏槑槒槓槕", 5, "槜槝槞槡", 11, "槮槯槰槱槳", 9, "槾樀", 9, "樋", 11, "標", 5, "樠樢", 5, "権樫樬樭樮樰樲樳樴樶", 6, "樿", 4, "橅橆橈", 7, "橑", 6, "橚"], ["9940", "橜", 4, "橢橣橤橦", 10, "橲", 6, "橺橻橽橾橿檁檂檃檅", 8, "檏檒", 4, "檘", 7, "檡", 5], ["9980", "檧檨檪檭", 114, "欥欦欨", 6], ["9a40", "欯欰欱欳欴欵欶欸欻欼欽欿歀歁歂歄歅歈歊歋歍", 11, "歚", 7, "歨歩歫", 13, "歺歽歾歿殀殅殈"], ["9a80", "殌殎殏殐殑殔殕殗殘殙殜", 4, "殢", 7, "殫", 7, "殶殸", 6, "毀毃毄毆", 4, "毌毎毐毑毘毚毜", 4, "毢", 7, "毬毭毮毰毱毲毴毶毷毸毺毻毼毾", 6, "氈", 4, "氎氒気氜氝氞氠氣氥氫氬氭氱氳氶氷氹氺氻氼氾氿汃汄汅汈汋", 4, "汑汒汓汖汘"], ["9b40", "汙汚汢汣汥汦汧汫", 4, "汱汳汵汷汸決汻汼汿沀沄沇沊沋沍沎沑沒沕沖沗沘沚沜沝沞沠沢沨沬沯沰沴沵沶沷沺泀況泂泃泆泇泈泋泍泎泏泑泒泘"], ["9b80", "泙泚泜泝泟泤泦泧泩泬泭泲泴泹泿洀洂洃洅洆洈洉洊洍洏洐洑洓洔洕洖洘洜洝洟", 5, "洦洨洩洬洭洯洰洴洶洷洸洺洿浀浂浄浉浌浐浕浖浗浘浛浝浟浡浢浤浥浧浨浫浬浭浰浱浲浳浵浶浹浺浻浽", 4, "涃涄涆涇涊涋涍涏涐涒涖", 4, "涜涢涥涬涭涰涱涳涴涶涷涹", 5, "淁淂淃淈淉淊"], ["9c40", "淍淎淏淐淒淓淔淕淗淚淛淜淟淢淣淥淧淨淩淪淭淯淰淲淴淵淶淸淺淽", 7, "渆渇済渉渋渏渒渓渕渘渙減渜渞渟渢渦渧渨渪測渮渰渱渳渵"], ["9c80", "渶渷渹渻", 7, "湅", 7, "湏湐湑湒湕湗湙湚湜湝湞湠", 10, "湬湭湯", 14, "満溁溂溄溇溈溊", 4, "溑", 6, "溙溚溛溝溞溠溡溣溤溦溨溩溫溬溭溮溰溳溵溸溹溼溾溿滀滃滄滅滆滈滉滊滌滍滎滐滒滖滘滙滛滜滝滣滧滪", 5], ["9d40", "滰滱滲滳滵滶滷滸滺", 7, "漃漄漅漇漈漊", 4, "漐漑漒漖", 9, "漡漢漣漥漦漧漨漬漮漰漲漴漵漷", 6, "漿潀潁潂"], ["9d80", "潃潄潅潈潉潊潌潎", 9, "潙潚潛潝潟潠潡潣潤潥潧", 5, "潯潰潱潳潵潶潷潹潻潽", 6, "澅澆澇澊澋澏", 12, "澝澞澟澠澢", 4, "澨", 10, "澴澵澷澸澺", 5, "濁濃", 5, "濊", 6, "濓", 10, "濟濢濣濤濥"], ["9e40", "濦", 7, "濰", 32, "瀒", 7, "瀜", 6, "瀤", 6], ["9e80", "瀫", 9, "瀶瀷瀸瀺", 17, "灍灎灐", 13, "灟", 11, "灮灱灲灳灴灷灹灺灻災炁炂炃炄炆炇炈炋炌炍炏炐炑炓炗炘炚炛炞", 12, "炰炲炴炵炶為炾炿烄烅烆烇烉烋", 12, "烚"], ["9f40", "烜烝烞烠烡烢烣烥烪烮烰", 6, "烸烺烻烼烾", 10, "焋", 4, "焑焒焔焗焛", 10, "焧", 7, "焲焳焴"], ["9f80", "焵焷", 13, "煆煇煈煉煋煍煏", 12, "煝煟", 4, "煥煩", 4, "煯煰煱煴煵煶煷煹煻煼煾", 5, "熅", 4, "熋熌熍熎熐熑熒熓熕熖熗熚", 4, "熡", 6, "熩熪熫熭", 5, "熴熶熷熸熺", 8, "燄", 9, "燏", 4], ["a040", "燖", 9, "燡燢燣燤燦燨", 5, "燯", 9, "燺", 11, "爇", 19], ["a080", "爛爜爞", 9, "爩爫爭爮爯爲爳爴爺爼爾牀", 6, "牉牊牋牎牏牐牑牓牔牕牗牘牚牜牞牠牣牤牥牨牪牫牬牭牰牱牳牴牶牷牸牻牼牽犂犃犅", 4, "犌犎犐犑犓", 11, "犠", 11, "犮犱犲犳犵犺", 6, "狅狆狇狉狊狋狌狏狑狓狔狕狖狘狚狛"], ["a1a1", "　、。·ˉˇ¨〃々—～‖…‘’“”〔〕〈", 7, "〖〗【】±×÷∶∧∨∑∏∪∩∈∷√⊥∥∠⌒⊙∫∮≡≌≈∽∝≠≮≯≤≥∞∵∴♂♀°′″℃＄¤￠￡‰§№☆★○●◎◇◆□■△▲※→←↑↓〓"], ["a2a1", "ⅰ", 9], ["a2b1", "⒈", 19, "⑴", 19, "①", 9], ["a2e5", "㈠", 9], ["a2f1", "Ⅰ", 11], ["a3a1", "！＂＃￥％", 88, "￣"], ["a4a1", "ぁ", 82], ["a5a1", "ァ", 85], ["a6a1", "Α", 16, "Σ", 6], ["a6c1", "α", 16, "σ", 6], ["a6e0", "︵︶︹︺︿﹀︽︾﹁﹂﹃﹄"], ["a6ee", "︻︼︷︸︱"], ["a6f4", "︳︴"], ["a7a1", "А", 5, "ЁЖ", 25], ["a7d1", "а", 5, "ёж", 25], ["a840", "ˊˋ˙–―‥‵℅℉↖↗↘↙∕∟∣≒≦≧⊿═", 35, "▁", 6], ["a880", "█", 7, "▓▔▕▼▽◢◣◤◥☉⊕〒〝〞"], ["a8a1", "āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜüêɑ"], ["a8bd", "ńň"], ["a8c0", "ɡ"], ["a8c5", "ㄅ", 36], ["a940", "〡", 8, "㊣㎎㎏㎜㎝㎞㎡㏄㏎㏑㏒㏕︰￢￤"], ["a959", "℡㈱"], ["a95c", "‐"], ["a960", "ー゛゜ヽヾ〆ゝゞ﹉", 9, "﹔﹕﹖﹗﹙", 8], ["a980", "﹢", 4, "﹨﹩﹪﹫"], ["a996", "〇"], ["a9a4", "─", 75], ["aa40", "狜狝狟狢", 5, "狪狫狵狶狹狽狾狿猀猂猄", 5, "猋猌猍猏猐猑猒猔猘猙猚猟猠猣猤猦猧猨猭猯猰猲猳猵猶猺猻猼猽獀", 8], ["aa80", "獉獊獋獌獎獏獑獓獔獕獖獘", 7, "獡", 10, "獮獰獱"], ["ab40", "獲", 11, "獿", 4, "玅玆玈玊玌玍玏玐玒玓玔玕玗玘玙玚玜玝玞玠玡玣", 5, "玪玬玭玱玴玵玶玸玹玼玽玾玿珁珃", 4], ["ab80", "珋珌珎珒", 6, "珚珛珜珝珟珡珢珣珤珦珨珪珫珬珮珯珰珱珳", 4], ["ac40", "珸", 10, "琄琇琈琋琌琍琎琑", 8, "琜", 5, "琣琤琧琩琫琭琯琱琲琷", 4, "琽琾琿瑀瑂", 11], ["ac80", "瑎", 6, "瑖瑘瑝瑠", 12, "瑮瑯瑱", 4, "瑸瑹瑺"], ["ad40", "瑻瑼瑽瑿璂璄璅璆璈璉璊璌璍璏璑", 10, "璝璟", 7, "璪", 15, "璻", 12], ["ad80", "瓈", 9, "瓓", 8, "瓝瓟瓡瓥瓧", 6, "瓰瓱瓲"], ["ae40", "瓳瓵瓸", 6, "甀甁甂甃甅", 7, "甎甐甒甔甕甖甗甛甝甞甠", 4, "甦甧甪甮甴甶甹甼甽甿畁畂畃畄畆畇畉畊畍畐畑畒畓畕畖畗畘"], ["ae80", "畝", 7, "畧畨畩畫", 6, "畳畵當畷畺", 4, "疀疁疂疄疅疇"], ["af40", "疈疉疊疌疍疎疐疓疕疘疛疜疞疢疦", 4, "疭疶疷疺疻疿痀痁痆痋痌痎痏痐痑痓痗痙痚痜痝痟痠痡痥痩痬痭痮痯痲痳痵痶痷痸痺痻痽痾瘂瘄瘆瘇"], ["af80", "瘈瘉瘋瘍瘎瘏瘑瘒瘓瘔瘖瘚瘜瘝瘞瘡瘣瘧瘨瘬瘮瘯瘱瘲瘶瘷瘹瘺瘻瘽癁療癄"], ["b040", "癅", 6, "癎", 5, "癕癗", 4, "癝癟癠癡癢癤", 6, "癬癭癮癰", 7, "癹発發癿皀皁皃皅皉皊皌皍皏皐皒皔皕皗皘皚皛"], ["b080", "皜", 7, "皥", 8, "皯皰皳皵", 9, "盀盁盃啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥"], ["b140", "盄盇盉盋盌盓盕盙盚盜盝盞盠", 4, "盦", 7, "盰盳盵盶盷盺盻盽盿眀眂眃眅眆眊県眎", 10, "眛眜眝眞眡眣眤眥眧眪眫"], ["b180", "眬眮眰", 4, "眹眻眽眾眿睂睄睅睆睈", 7, "睒", 7, "睜薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳"], ["b240", "睝睞睟睠睤睧睩睪睭", 11, "睺睻睼瞁瞂瞃瞆", 5, "瞏瞐瞓", 11, "瞡瞣瞤瞦瞨瞫瞭瞮瞯瞱瞲瞴瞶", 4], ["b280", "瞼瞾矀", 12, "矎", 8, "矘矙矚矝", 4, "矤病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖"], ["b340", "矦矨矪矯矰矱矲矴矵矷矹矺矻矼砃", 5, "砊砋砎砏砐砓砕砙砛砞砠砡砢砤砨砪砫砮砯砱砲砳砵砶砽砿硁硂硃硄硆硈硉硊硋硍硏硑硓硔硘硙硚"], ["b380", "硛硜硞", 11, "硯", 7, "硸硹硺硻硽", 6, "场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚"], ["b440", "碄碅碆碈碊碋碏碐碒碔碕碖碙碝碞碠碢碤碦碨", 7, "碵碶碷碸確碻碼碽碿磀磂磃磄磆磇磈磌磍磎磏磑磒磓磖磗磘磚", 9], ["b480", "磤磥磦磧磩磪磫磭", 4, "磳磵磶磸磹磻", 5, "礂礃礄礆", 6, "础储矗搐触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮"], ["b540", "礍", 5, "礔", 9, "礟", 4, "礥", 14, "礵", 4, "礽礿祂祃祄祅祇祊", 8, "祔祕祘祙祡祣"], ["b580", "祤祦祩祪祫祬祮祰", 6, "祹祻", 4, "禂禃禆禇禈禉禋禌禍禎禐禑禒怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠"], ["b640", "禓", 6, "禛", 11, "禨", 10, "禴", 4, "禼禿秂秄秅秇秈秊秌秎秏秐秓秔秖秗秙", 5, "秠秡秢秥秨秪"], ["b680", "秬秮秱", 6, "秹秺秼秾秿稁稄稅稇稈稉稊稌稏", 4, "稕稖稘稙稛稜丁盯叮钉顶鼎锭定订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二"], ["b740", "稝稟稡稢稤", 14, "稴稵稶稸稺稾穀", 5, "穇", 9, "穒", 4, "穘", 16], ["b780", "穩", 6, "穱穲穳穵穻穼穽穾窂窅窇窉窊窋窌窎窏窐窓窔窙窚窛窞窡窢贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服"], ["b840", "窣窤窧窩窪窫窮", 4, "窴", 10, "竀", 10, "竌", 9, "竗竘竚竛竜竝竡竢竤竧", 5, "竮竰竱竲竳"], ["b880", "竴", 4, "竻竼竾笀笁笂笅笇笉笌笍笎笐笒笓笖笗笘笚笜笝笟笡笢笣笧笩笭浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳疙割革葛格蛤阁隔铬个各给根跟耕更庚羹"], ["b940", "笯笰笲笴笵笶笷笹笻笽笿", 5, "筆筈筊筍筎筓筕筗筙筜筞筟筡筣", 10, "筯筰筳筴筶筸筺筼筽筿箁箂箃箄箆", 6, "箎箏"], ["b980", "箑箒箓箖箘箙箚箛箞箟箠箣箤箥箮箯箰箲箳箵箶箷箹", 7, "篂篃範埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮瓜剐寡挂褂乖拐怪棺关官冠观管馆罐惯灌贯光广逛瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽辊滚棍锅郭国果裹过哈"], ["ba40", "篅篈築篊篋篍篎篏篐篒篔", 4, "篛篜篞篟篠篢篣篤篧篨篩篫篬篭篯篰篲", 4, "篸篹篺篻篽篿", 7, "簈簉簊簍簎簐", 5, "簗簘簙"], ["ba80", "簚", 4, "簠", 5, "簨簩簫", 12, "簹", 5, "籂骸孩海氦亥害骇酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉夯杭航壕嚎豪毫郝好耗号浩呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺嘿黑痕很狠恨哼亨横衡恒轰哄烘虹鸿洪宏弘红喉侯猴吼厚候后呼乎忽瑚壶葫胡蝴狐糊湖"], ["bb40", "籃", 9, "籎", 36, "籵", 5, "籾", 9], ["bb80", "粈粊", 6, "粓粔粖粙粚粛粠粡粣粦粧粨粩粫粬粭粯粰粴", 4, "粺粻弧虎唬护互沪户花哗华猾滑画划化话槐徊怀淮坏欢环桓还缓换患唤痪豢焕涣宦幻荒慌黄磺蝗簧皇凰惶煌晃幌恍谎灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘荤昏婚魂浑混豁活伙火获或惑霍货祸击圾基机畸稽积箕"], ["bc40", "粿糀糂糃糄糆糉糋糎", 6, "糘糚糛糝糞糡", 6, "糩", 5, "糰", 7, "糹糺糼", 13, "紋", 5], ["bc80", "紑", 14, "紡紣紤紥紦紨紩紪紬紭紮細", 6, "肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件"], ["bd40", "紷", 54, "絯", 7], ["bd80", "絸", 32, "健舰剑饯渐溅涧建僵姜将浆江疆蒋桨奖讲匠酱降蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸"], ["be40", "継", 12, "綧", 6, "綯", 42], ["be80", "線", 32, "尽劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净炯窘揪究纠玖韭久灸九酒厩救旧臼舅咎就疚鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧捐鹃娟倦眷卷绢撅攫抉掘倔爵觉决诀绝均菌钧军君峻"], ["bf40", "緻", 62], ["bf80", "縺縼", 4, "繂", 4, "繈", 21, "俊竣浚郡骏喀咖卡咯开揩楷凯慨刊堪勘坎砍看康慷糠扛抗亢炕考拷烤靠坷苛柯棵磕颗科壳咳可渴克刻客课肯啃垦恳坑吭空恐孔控抠口扣寇枯哭窟苦酷库裤夸垮挎跨胯块筷侩快宽款匡筐狂框矿眶旷况亏盔岿窥葵奎魁傀"], ["c040", "繞", 35, "纃", 23, "纜纝纞"], ["c080", "纮纴纻纼绖绤绬绹缊缐缞缷缹缻", 6, "罃罆", 9, "罒罓馈愧溃坤昆捆困括扩廓阔垃拉喇蜡腊辣啦莱来赖蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥琅榔狼廊郎朗浪捞劳牢老佬姥酪烙涝勒乐雷镭蕾磊累儡垒擂肋类泪棱楞冷厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐"], ["c140", "罖罙罛罜罝罞罠罣", 4, "罫罬罭罯罰罳罵罶罷罸罺罻罼罽罿羀羂", 7, "羋羍羏", 4, "羕", 4, "羛羜羠羢羣羥羦羨", 6, "羱"], ["c180", "羳", 4, "羺羻羾翀翂翃翄翆翇翈翉翋翍翏", 4, "翖翗翙", 5, "翢翣痢立粒沥隶力璃哩俩联莲连镰廉怜涟帘敛脸链恋炼练粮凉梁粱良两辆量晾亮谅撩聊僚疗燎寥辽潦了撂镣廖料列裂烈劣猎琳林磷霖临邻鳞淋凛赁吝拎玲菱零龄铃伶羚凌灵陵岭领另令溜琉榴硫馏留刘瘤流柳六龙聋咙笼窿"], ["c240", "翤翧翨翪翫翬翭翯翲翴", 6, "翽翾翿耂耇耈耉耊耎耏耑耓耚耛耝耞耟耡耣耤耫", 5, "耲耴耹耺耼耾聀聁聄聅聇聈聉聎聏聐聑聓聕聖聗"], ["c280", "聙聛", 13, "聫", 5, "聲", 11, "隆垄拢陇楼娄搂篓漏陋芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮驴吕铝侣旅履屡缕虑氯律率滤绿峦挛孪滦卵乱掠略抡轮伦仑沦纶论萝螺罗逻锣箩骡裸落洛骆络妈麻玛码蚂马骂嘛吗埋买麦卖迈脉瞒馒蛮满蔓曼慢漫"], ["c340", "聾肁肂肅肈肊肍", 5, "肔肕肗肙肞肣肦肧肨肬肰肳肵肶肸肹肻胅胇", 4, "胏", 6, "胘胟胠胢胣胦胮胵胷胹胻胾胿脀脁脃脄脅脇脈脋"], ["c380", "脌脕脗脙脛脜脝脟", 12, "脭脮脰脳脴脵脷脹", 4, "脿谩芒茫盲氓忙莽猫茅锚毛矛铆卯茂冒帽貌贸么玫枚梅酶霉煤没眉媒镁每美昧寐妹媚门闷们萌蒙檬盟锰猛梦孟眯醚靡糜迷谜弥米秘觅泌蜜密幂棉眠绵冕免勉娩缅面苗描瞄藐秒渺庙妙蔑灭民抿皿敏悯闽明螟鸣铭名命谬摸"], ["c440", "腀", 5, "腇腉腍腎腏腒腖腗腘腛", 4, "腡腢腣腤腦腨腪腫腬腯腲腳腵腶腷腸膁膃", 4, "膉膋膌膍膎膐膒", 5, "膙膚膞", 4, "膤膥"], ["c480", "膧膩膫", 7, "膴", 5, "膼膽膾膿臄臅臇臈臉臋臍", 6, "摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谋牟某拇牡亩姆母墓暮幕募慕木目睦牧穆拿哪呐钠那娜纳氖乃奶耐奈南男难囊挠脑恼闹淖呢馁内嫩能妮霓倪泥尼拟你匿腻逆溺蔫拈年碾撵捻念娘酿鸟尿捏聂孽啮镊镍涅您柠狞凝宁"], ["c540", "臔", 14, "臤臥臦臨臩臫臮", 4, "臵", 5, "臽臿舃與", 4, "舎舏舑舓舕", 5, "舝舠舤舥舦舧舩舮舲舺舼舽舿"], ["c580", "艀艁艂艃艅艆艈艊艌艍艎艐", 7, "艙艛艜艝艞艠", 7, "艩拧泞牛扭钮纽脓浓农弄奴努怒女暖虐疟挪懦糯诺哦欧鸥殴藕呕偶沤啪趴爬帕怕琶拍排牌徘湃派攀潘盘磐盼畔判叛乓庞旁耪胖抛咆刨炮袍跑泡呸胚培裴赔陪配佩沛喷盆砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯砒霹批披劈琵毗"], ["c640", "艪艫艬艭艱艵艶艷艸艻艼芀芁芃芅芆芇芉芌芐芓芔芕芖芚芛芞芠芢芣芧芲芵芶芺芻芼芿苀苂苃苅苆苉苐苖苙苚苝苢苧苨苩苪苬苭苮苰苲苳苵苶苸"], ["c680", "苺苼", 4, "茊茋茍茐茒茓茖茘茙茝", 9, "茩茪茮茰茲茷茻茽啤脾疲皮匹痞僻屁譬篇偏片骗飘漂瓢票撇瞥拼频贫品聘乒坪苹萍平凭瓶评屏坡泼颇婆破魄迫粕剖扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫掐"], ["c740", "茾茿荁荂荄荅荈荊", 4, "荓荕", 4, "荝荢荰", 6, "荹荺荾", 6, "莇莈莊莋莌莍莏莐莑莔莕莖莗莙莚莝莟莡", 6, "莬莭莮"], ["c780", "莯莵莻莾莿菂菃菄菆菈菉菋菍菎菐菑菒菓菕菗菙菚菛菞菢菣菤菦菧菨菫菬菭恰洽牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉枪呛腔羌墙蔷强抢橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍切茄且怯窃钦侵亲秦琴勤芹擒禽寝沁青轻氢倾卿清擎晴氰情顷请庆琼穷秋丘邱球求囚酋泅趋区蛆曲躯屈驱渠"], ["c840", "菮華菳", 4, "菺菻菼菾菿萀萂萅萇萈萉萊萐萒", 5, "萙萚萛萞", 5, "萩", 7, "萲", 5, "萹萺萻萾", 7, "葇葈葉"], ["c880", "葊", 6, "葒", 4, "葘葝葞葟葠葢葤", 4, "葪葮葯葰葲葴葷葹葻葼取娶龋趣去圈颧权醛泉全痊拳犬券劝缺炔瘸却鹊榷确雀裙群然燃冉染瓤壤攘嚷让饶扰绕惹热壬仁人忍韧任认刃妊纫扔仍日戎茸蓉荣融熔溶容绒冗揉柔肉茹蠕儒孺如辱乳汝入褥软阮蕊瑞锐闰润若弱撒洒萨腮鳃塞赛三叁"], ["c940", "葽", 4, "蒃蒄蒅蒆蒊蒍蒏", 7, "蒘蒚蒛蒝蒞蒟蒠蒢", 12, "蒰蒱蒳蒵蒶蒷蒻蒼蒾蓀蓂蓃蓅蓆蓇蓈蓋蓌蓎蓏蓒蓔蓕蓗"], ["c980", "蓘", 4, "蓞蓡蓢蓤蓧", 4, "蓭蓮蓯蓱", 10, "蓽蓾蔀蔁蔂伞散桑嗓丧搔骚扫嫂瑟色涩森僧莎砂杀刹沙纱傻啥煞筛晒珊苫杉山删煽衫闪陕擅赡膳善汕扇缮墒伤商赏晌上尚裳梢捎稍烧芍勺韶少哨邵绍奢赊蛇舌舍赦摄射慑涉社设砷申呻伸身深娠绅神沈审婶甚肾慎渗声生甥牲升绳"], ["ca40", "蔃", 8, "蔍蔎蔏蔐蔒蔔蔕蔖蔘蔙蔛蔜蔝蔞蔠蔢", 8, "蔭", 9, "蔾", 4, "蕄蕅蕆蕇蕋", 10], ["ca80", "蕗蕘蕚蕛蕜蕝蕟", 4, "蕥蕦蕧蕩", 8, "蕳蕵蕶蕷蕸蕼蕽蕿薀薁省盛剩胜圣师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试收手首守寿授售受瘦兽蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱"], ["cb40", "薂薃薆薈", 6, "薐", 10, "薝", 6, "薥薦薧薩薫薬薭薱", 5, "薸薺", 6, "藂", 6, "藊", 4, "藑藒"], ["cb80", "藔藖", 5, "藝", 6, "藥藦藧藨藪", 14, "恕刷耍摔衰甩帅栓拴霜双爽谁水睡税吮瞬顺舜说硕朔烁斯撕嘶思私司丝死肆寺嗣四伺似饲巳松耸怂颂送宋讼诵搜艘擞嗽苏酥俗素速粟僳塑溯宿诉肃酸蒜算虽隋随绥髓碎岁穗遂隧祟孙损笋蓑梭唆缩琐索锁所塌他它她塔"], ["cc40", "藹藺藼藽藾蘀", 4, "蘆", 10, "蘒蘓蘔蘕蘗", 15, "蘨蘪", 13, "蘹蘺蘻蘽蘾蘿虀"], ["cc80", "虁", 11, "虒虓處", 4, "虛虜虝號虠虡虣", 7, "獭挞蹋踏胎苔抬台泰酞太态汰坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭汤塘搪堂棠膛唐糖倘躺淌趟烫掏涛滔绦萄桃逃淘陶讨套特藤腾疼誊梯剔踢锑提题蹄啼体替嚏惕涕剃屉天添填田甜恬舔腆挑条迢眺跳贴铁帖厅听烃"], ["cd40", "虭虯虰虲", 6, "蚃", 6, "蚎", 4, "蚔蚖", 5, "蚞", 4, "蚥蚦蚫蚭蚮蚲蚳蚷蚸蚹蚻", 4, "蛁蛂蛃蛅蛈蛌蛍蛒蛓蛕蛖蛗蛚蛜"], ["cd80", "蛝蛠蛡蛢蛣蛥蛦蛧蛨蛪蛫蛬蛯蛵蛶蛷蛺蛻蛼蛽蛿蜁蜄蜅蜆蜋蜌蜎蜏蜐蜑蜔蜖汀廷停亭庭挺艇通桐酮瞳同铜彤童桶捅筒统痛偷投头透凸秃突图徒途涂屠土吐兔湍团推颓腿蜕褪退吞屯臀拖托脱鸵陀驮驼椭妥拓唾挖哇蛙洼娃瓦袜歪外豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕汪王亡枉网往旺望忘妄威"], ["ce40", "蜙蜛蜝蜟蜠蜤蜦蜧蜨蜪蜫蜬蜭蜯蜰蜲蜳蜵蜶蜸蜹蜺蜼蜽蝀", 6, "蝊蝋蝍蝏蝐蝑蝒蝔蝕蝖蝘蝚", 5, "蝡蝢蝦", 7, "蝯蝱蝲蝳蝵"], ["ce80", "蝷蝸蝹蝺蝿螀螁螄螆螇螉螊螌螎", 4, "螔螕螖螘", 6, "螠", 4, "巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫瘟温蚊文闻纹吻稳紊问嗡翁瓮挝蜗涡窝我斡卧握沃巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误昔熙析西硒矽晰嘻吸锡牺"], ["cf40", "螥螦螧螩螪螮螰螱螲螴螶螷螸螹螻螼螾螿蟁", 4, "蟇蟈蟉蟌", 4, "蟔", 6, "蟜蟝蟞蟟蟡蟢蟣蟤蟦蟧蟨蟩蟫蟬蟭蟯", 9], ["cf80", "蟺蟻蟼蟽蟿蠀蠁蠂蠄", 5, "蠋", 7, "蠔蠗蠘蠙蠚蠜", 4, "蠣稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细瞎虾匣霞辖暇峡侠狭下厦夏吓掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象萧硝霄削哮嚣销消宵淆晓"], ["d040", "蠤", 13, "蠳", 5, "蠺蠻蠽蠾蠿衁衂衃衆", 5, "衎", 5, "衕衖衘衚", 6, "衦衧衪衭衯衱衳衴衵衶衸衹衺"], ["d080", "衻衼袀袃袆袇袉袊袌袎袏袐袑袓袔袕袗", 4, "袝", 4, "袣袥", 5, "小孝校肖啸笑效楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑薪芯锌欣辛新忻心信衅星腥猩惺兴刑型形邢行醒幸杏性姓兄凶胸匈汹雄熊休修羞朽嗅锈秀袖绣墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续轩喧宣悬旋玄"], ["d140", "袬袮袯袰袲", 4, "袸袹袺袻袽袾袿裀裃裄裇裈裊裋裌裍裏裐裑裓裖裗裚", 4, "裠裡裦裧裩", 6, "裲裵裶裷裺裻製裿褀褁褃", 5], ["d180", "褉褋", 4, "褑褔", 4, "褜", 4, "褢褣褤褦褧褨褩褬褭褮褯褱褲褳褵褷选癣眩绚靴薛学穴雪血勋熏循旬询寻驯巡殉汛训讯逊迅压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾邀腰妖瑶"], ["d240", "褸", 8, "襂襃襅", 24, "襠", 5, "襧", 19, "襼"], ["d280", "襽襾覀覂覄覅覇", 26, "摇尧遥窑谣姚咬舀药要耀椰噎耶爷野冶也页掖业叶曳腋夜液一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎茵荫因殷音阴姻吟银淫寅饮尹引隐"], ["d340", "覢", 30, "觃觍觓觔觕觗觘觙觛觝觟觠觡觢觤觧觨觩觪觬觭觮觰觱觲觴", 6], ["d380", "觻", 4, "訁", 5, "計", 21, "印英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映哟拥佣臃痈庸雍踊蛹咏泳涌永恿勇用幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉"], ["d440", "訞", 31, "訿", 8, "詉", 21], ["d480", "詟", 25, "詺", 6, "浴寓裕预豫驭鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院曰约越跃钥岳粤月悦阅耘云郧匀陨允运蕴酝晕韵孕匝砸杂栽哉灾宰载再在咱攒暂赞赃脏葬遭糟凿藻枣早澡蚤躁噪造皂灶燥责择则泽贼怎增憎曾赠扎喳渣札轧"], ["d540", "誁", 7, "誋", 7, "誔", 46], ["d580", "諃", 32, "铡闸眨栅榨咋乍炸诈摘斋宅窄债寨瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽樟章彰漳张掌涨杖丈帐账仗胀瘴障招昭找沼赵照罩兆肇召遮折哲蛰辙者锗蔗这浙珍斟真甄砧臻贞针侦枕疹诊震振镇阵蒸挣睁征狰争怔整拯正政"], ["d640", "諤", 34, "謈", 27], ["d680", "謤謥謧", 30, "帧症郑证芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒中盅忠钟衷终种肿重仲众舟周州洲诌粥轴肘帚咒皱宙昼骤珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑"], ["d740", "譆", 31, "譧", 4, "譭", 25], ["d780", "讇", 24, "讬讱讻诇诐诪谉谞住注祝驻抓爪拽专砖转撰赚篆桩庄装妆撞壮状椎锥追赘坠缀谆准捉拙卓桌琢茁酌啄着灼浊兹咨资姿滋淄孜紫仔籽滓子自渍字鬃棕踪宗综总纵邹走奏揍租足卒族祖诅阻组钻纂嘴醉最罪尊遵昨左佐柞做作坐座"], ["d840", "谸", 8, "豂豃豄豅豈豊豋豍", 7, "豖豗豘豙豛", 5, "豣", 6, "豬", 6, "豴豵豶豷豻", 6, "貃貄貆貇"], ["d880", "貈貋貍", 6, "貕貖貗貙", 20, "亍丌兀丐廿卅丕亘丞鬲孬噩丨禺丿匕乇夭爻卮氐囟胤馗毓睾鼗丶亟鼐乜乩亓芈孛啬嘏仄厍厝厣厥厮靥赝匚叵匦匮匾赜卦卣刂刈刎刭刳刿剀剌剞剡剜蒯剽劂劁劐劓冂罔亻仃仉仂仨仡仫仞伛仳伢佤仵伥伧伉伫佞佧攸佚佝"], ["d940", "貮", 62], ["d980", "賭", 32, "佟佗伲伽佶佴侑侉侃侏佾佻侪佼侬侔俦俨俪俅俚俣俜俑俟俸倩偌俳倬倏倮倭俾倜倌倥倨偾偃偕偈偎偬偻傥傧傩傺僖儆僭僬僦僮儇儋仝氽佘佥俎龠汆籴兮巽黉馘冁夔勹匍訇匐凫夙兕亠兖亳衮袤亵脔裒禀嬴蠃羸冫冱冽冼"], ["da40", "贎", 14, "贠赑赒赗赟赥赨赩赪赬赮赯赱赲赸", 8, "趂趃趆趇趈趉趌", 4, "趒趓趕", 9, "趠趡"], ["da80", "趢趤", 12, "趲趶趷趹趻趽跀跁跂跅跇跈跉跊跍跐跒跓跔凇冖冢冥讠讦讧讪讴讵讷诂诃诋诏诎诒诓诔诖诘诙诜诟诠诤诨诩诮诰诳诶诹诼诿谀谂谄谇谌谏谑谒谔谕谖谙谛谘谝谟谠谡谥谧谪谫谮谯谲谳谵谶卩卺阝阢阡阱阪阽阼陂陉陔陟陧陬陲陴隈隍隗隰邗邛邝邙邬邡邴邳邶邺"], ["db40", "跕跘跙跜跠跡跢跥跦跧跩跭跮跰跱跲跴跶跼跾", 6, "踆踇踈踋踍踎踐踑踒踓踕", 7, "踠踡踤", 4, "踫踭踰踲踳踴踶踷踸踻踼踾"], ["db80", "踿蹃蹅蹆蹌", 4, "蹓", 5, "蹚", 11, "蹧蹨蹪蹫蹮蹱邸邰郏郅邾郐郄郇郓郦郢郜郗郛郫郯郾鄄鄢鄞鄣鄱鄯鄹酃酆刍奂劢劬劭劾哿勐勖勰叟燮矍廴凵凼鬯厶弁畚巯坌垩垡塾墼壅壑圩圬圪圳圹圮圯坜圻坂坩垅坫垆坼坻坨坭坶坳垭垤垌垲埏垧垴垓垠埕埘埚埙埒垸埴埯埸埤埝"], ["dc40", "蹳蹵蹷", 4, "蹽蹾躀躂躃躄躆躈", 6, "躑躒躓躕", 6, "躝躟", 11, "躭躮躰躱躳", 6, "躻", 7], ["dc80", "軃", 10, "軏", 21, "堋堍埽埭堀堞堙塄堠塥塬墁墉墚墀馨鼙懿艹艽艿芏芊芨芄芎芑芗芙芫芸芾芰苈苊苣芘芷芮苋苌苁芩芴芡芪芟苄苎芤苡茉苷苤茏茇苜苴苒苘茌苻苓茑茚茆茔茕苠苕茜荑荛荜茈莒茼茴茱莛荞茯荏荇荃荟荀茗荠茭茺茳荦荥"], ["dd40", "軥", 62], ["dd80", "輤", 32, "荨茛荩荬荪荭荮莰荸莳莴莠莪莓莜莅荼莶莩荽莸荻莘莞莨莺莼菁萁菥菘堇萘萋菝菽菖萜萸萑萆菔菟萏萃菸菹菪菅菀萦菰菡葜葑葚葙葳蒇蒈葺蒉葸萼葆葩葶蒌蒎萱葭蓁蓍蓐蓦蒽蓓蓊蒿蒺蓠蒡蒹蒴蒗蓥蓣蔌甍蔸蓰蔹蔟蔺"], ["de40", "轅", 32, "轪辀辌辒辝辠辡辢辤辥辦辧辪辬辭辮辯農辳辴辵辷辸辺辻込辿迀迃迆"], ["de80", "迉", 4, "迏迒迖迗迚迠迡迣迧迬迯迱迲迴迵迶迺迻迼迾迿逇逈逌逎逓逕逘蕖蔻蓿蓼蕙蕈蕨蕤蕞蕺瞢蕃蕲蕻薤薨薇薏蕹薮薜薅薹薷薰藓藁藜藿蘧蘅蘩蘖蘼廾弈夼奁耷奕奚奘匏尢尥尬尴扌扪抟抻拊拚拗拮挢拶挹捋捃掭揶捱捺掎掴捭掬掊捩掮掼揲揸揠揿揄揞揎摒揆掾摅摁搋搛搠搌搦搡摞撄摭撖"], ["df40", "這逜連逤逥逧", 5, "逰", 4, "逷逹逺逽逿遀遃遅遆遈", 4, "過達違遖遙遚遜", 5, "遤遦遧適遪遫遬遯", 4, "遶", 6, "遾邁"], ["df80", "還邅邆邇邉邊邌", 4, "邒邔邖邘邚邜邞邟邠邤邥邧邨邩邫邭邲邷邼邽邿郀摺撷撸撙撺擀擐擗擤擢攉攥攮弋忒甙弑卟叱叽叩叨叻吒吖吆呋呒呓呔呖呃吡呗呙吣吲咂咔呷呱呤咚咛咄呶呦咝哐咭哂咴哒咧咦哓哔呲咣哕咻咿哌哙哚哜咩咪咤哝哏哞唛哧唠哽唔哳唢唣唏唑唧唪啧喏喵啉啭啁啕唿啐唼"], ["e040", "郂郃郆郈郉郋郌郍郒郔郕郖郘郙郚郞郟郠郣郤郥郩郪郬郮郰郱郲郳郵郶郷郹郺郻郼郿鄀鄁鄃鄅", 19, "鄚鄛鄜"], ["e080", "鄝鄟鄠鄡鄤", 10, "鄰鄲", 6, "鄺", 8, "酄唷啖啵啶啷唳唰啜喋嗒喃喱喹喈喁喟啾嗖喑啻嗟喽喾喔喙嗪嗷嗉嘟嗑嗫嗬嗔嗦嗝嗄嗯嗥嗲嗳嗌嗍嗨嗵嗤辔嘞嘈嘌嘁嘤嘣嗾嘀嘧嘭噘嘹噗嘬噍噢噙噜噌噔嚆噤噱噫噻噼嚅嚓嚯囔囗囝囡囵囫囹囿圄圊圉圜帏帙帔帑帱帻帼"], ["e140", "酅酇酈酑酓酔酕酖酘酙酛酜酟酠酦酧酨酫酭酳酺酻酼醀", 4, "醆醈醊醎醏醓", 6, "醜", 5, "醤", 5, "醫醬醰醱醲醳醶醷醸醹醻"], ["e180", "醼", 10, "釈釋釐釒", 9, "針", 8, "帷幄幔幛幞幡岌屺岍岐岖岈岘岙岑岚岜岵岢岽岬岫岱岣峁岷峄峒峤峋峥崂崃崧崦崮崤崞崆崛嵘崾崴崽嵬嵛嵯嵝嵫嵋嵊嵩嵴嶂嶙嶝豳嶷巅彳彷徂徇徉後徕徙徜徨徭徵徼衢彡犭犰犴犷犸狃狁狎狍狒狨狯狩狲狴狷猁狳猃狺"], ["e240", "釦", 62], ["e280", "鈥", 32, "狻猗猓猡猊猞猝猕猢猹猥猬猸猱獐獍獗獠獬獯獾舛夥飧夤夂饣饧", 5, "饴饷饽馀馄馇馊馍馐馑馓馔馕庀庑庋庖庥庠庹庵庾庳赓廒廑廛廨廪膺忄忉忖忏怃忮怄忡忤忾怅怆忪忭忸怙怵怦怛怏怍怩怫怊怿怡恸恹恻恺恂"], ["e340", "鉆", 45, "鉵", 16], ["e380", "銆", 7, "銏", 24, "恪恽悖悚悭悝悃悒悌悛惬悻悱惝惘惆惚悴愠愦愕愣惴愀愎愫慊慵憬憔憧憷懔懵忝隳闩闫闱闳闵闶闼闾阃阄阆阈阊阋阌阍阏阒阕阖阗阙阚丬爿戕氵汔汜汊沣沅沐沔沌汨汩汴汶沆沩泐泔沭泷泸泱泗沲泠泖泺泫泮沱泓泯泾"], ["e440", "銨", 5, "銯", 24, "鋉", 31], ["e480", "鋩", 32, "洹洧洌浃浈洇洄洙洎洫浍洮洵洚浏浒浔洳涑浯涞涠浞涓涔浜浠浼浣渚淇淅淞渎涿淠渑淦淝淙渖涫渌涮渫湮湎湫溲湟溆湓湔渲渥湄滟溱溘滠漭滢溥溧溽溻溷滗溴滏溏滂溟潢潆潇漤漕滹漯漶潋潴漪漉漩澉澍澌潸潲潼潺濑"], ["e540", "錊", 51, "錿", 10], ["e580", "鍊", 31, "鍫濉澧澹澶濂濡濮濞濠濯瀚瀣瀛瀹瀵灏灞宀宄宕宓宥宸甯骞搴寤寮褰寰蹇謇辶迓迕迥迮迤迩迦迳迨逅逄逋逦逑逍逖逡逵逶逭逯遄遑遒遐遨遘遢遛暹遴遽邂邈邃邋彐彗彖彘尻咫屐屙孱屣屦羼弪弩弭艴弼鬻屮妁妃妍妩妪妣"], ["e640", "鍬", 34, "鎐", 27], ["e680", "鎬", 29, "鏋鏌鏍妗姊妫妞妤姒妲妯姗妾娅娆姝娈姣姘姹娌娉娲娴娑娣娓婀婧婊婕娼婢婵胬媪媛婷婺媾嫫媲嫒嫔媸嫠嫣嫱嫖嫦嫘嫜嬉嬗嬖嬲嬷孀尕尜孚孥孳孑孓孢驵驷驸驺驿驽骀骁骅骈骊骐骒骓骖骘骛骜骝骟骠骢骣骥骧纟纡纣纥纨纩"], ["e740", "鏎", 7, "鏗", 54], ["e780", "鐎", 32, "纭纰纾绀绁绂绉绋绌绐绔绗绛绠绡绨绫绮绯绱绲缍绶绺绻绾缁缂缃缇缈缋缌缏缑缒缗缙缜缛缟缡", 6, "缪缫缬缭缯", 4, "缵幺畿巛甾邕玎玑玮玢玟珏珂珑玷玳珀珉珈珥珙顼琊珩珧珞玺珲琏琪瑛琦琥琨琰琮琬"], ["e840", "鐯", 14, "鐿", 43, "鑬鑭鑮鑯"], ["e880", "鑰", 20, "钑钖钘铇铏铓铔铚铦铻锜锠琛琚瑁瑜瑗瑕瑙瑷瑭瑾璜璎璀璁璇璋璞璨璩璐璧瓒璺韪韫韬杌杓杞杈杩枥枇杪杳枘枧杵枨枞枭枋杷杼柰栉柘栊柩枰栌柙枵柚枳柝栀柃枸柢栎柁柽栲栳桠桡桎桢桄桤梃栝桕桦桁桧桀栾桊桉栩梵梏桴桷梓桫棂楮棼椟椠棹"], ["e940", "锧锳锽镃镈镋镕镚镠镮镴镵長", 7, "門", 42], ["e980", "閫", 32, "椤棰椋椁楗棣椐楱椹楠楂楝榄楫榀榘楸椴槌榇榈槎榉楦楣楹榛榧榻榫榭槔榱槁槊槟榕槠榍槿樯槭樗樘橥槲橄樾檠橐橛樵檎橹樽樨橘橼檑檐檩檗檫猷獒殁殂殇殄殒殓殍殚殛殡殪轫轭轱轲轳轵轶轸轷轹轺轼轾辁辂辄辇辋"], ["ea40", "闌", 27, "闬闿阇阓阘阛阞阠阣", 6, "阫阬阭阯阰阷阸阹阺阾陁陃陊陎陏陑陒陓陖陗"], ["ea80", "陘陙陚陜陝陞陠陣陥陦陫陭", 4, "陳陸", 12, "隇隉隊辍辎辏辘辚軎戋戗戛戟戢戡戥戤戬臧瓯瓴瓿甏甑甓攴旮旯旰昊昙杲昃昕昀炅曷昝昴昱昶昵耆晟晔晁晏晖晡晗晷暄暌暧暝暾曛曜曦曩贲贳贶贻贽赀赅赆赈赉赇赍赕赙觇觊觋觌觎觏觐觑牮犟牝牦牯牾牿犄犋犍犏犒挈挲掰"], ["eb40", "隌階隑隒隓隕隖隚際隝", 9, "隨", 7, "隱隲隴隵隷隸隺隻隿雂雃雈雊雋雐雑雓雔雖", 9, "雡", 6, "雫"], ["eb80", "雬雭雮雰雱雲雴雵雸雺電雼雽雿霂霃霅霊霋霌霐霑霒霔霕霗", 4, "霝霟霠搿擘耄毪毳毽毵毹氅氇氆氍氕氘氙氚氡氩氤氪氲攵敕敫牍牒牖爰虢刖肟肜肓肼朊肽肱肫肭肴肷胧胨胩胪胛胂胄胙胍胗朐胝胫胱胴胭脍脎胲胼朕脒豚脶脞脬脘脲腈腌腓腴腙腚腱腠腩腼腽腭腧塍媵膈膂膑滕膣膪臌朦臊膻"], ["ec40", "霡", 8, "霫霬霮霯霱霳", 4, "霺霻霼霽霿", 18, "靔靕靗靘靚靜靝靟靣靤靦靧靨靪", 7], ["ec80", "靲靵靷", 4, "靽", 7, "鞆", 4, "鞌鞎鞏鞐鞓鞕鞖鞗鞙", 4, "臁膦欤欷欹歃歆歙飑飒飓飕飙飚殳彀毂觳斐齑斓於旆旄旃旌旎旒旖炀炜炖炝炻烀炷炫炱烨烊焐焓焖焯焱煳煜煨煅煲煊煸煺熘熳熵熨熠燠燔燧燹爝爨灬焘煦熹戾戽扃扈扉礻祀祆祉祛祜祓祚祢祗祠祯祧祺禅禊禚禧禳忑忐"], ["ed40", "鞞鞟鞡鞢鞤", 6, "鞬鞮鞰鞱鞳鞵", 46], ["ed80", "韤韥韨韮", 4, "韴韷", 23, "怼恝恚恧恁恙恣悫愆愍慝憩憝懋懑戆肀聿沓泶淼矶矸砀砉砗砘砑斫砭砜砝砹砺砻砟砼砥砬砣砩硎硭硖硗砦硐硇硌硪碛碓碚碇碜碡碣碲碹碥磔磙磉磬磲礅磴礓礤礞礴龛黹黻黼盱眄眍盹眇眈眚眢眙眭眦眵眸睐睑睇睃睚睨"], ["ee40", "頏", 62], ["ee80", "顎", 32, "睢睥睿瞍睽瞀瞌瞑瞟瞠瞰瞵瞽町畀畎畋畈畛畲畹疃罘罡罟詈罨罴罱罹羁罾盍盥蠲钅钆钇钋钊钌钍钏钐钔钗钕钚钛钜钣钤钫钪钭钬钯钰钲钴钶", 4, "钼钽钿铄铈", 6, "铐铑铒铕铖铗铙铘铛铞铟铠铢铤铥铧铨铪"], ["ef40", "顯", 5, "颋颎颒颕颙颣風", 37, "飏飐飔飖飗飛飜飝飠", 4], ["ef80", "飥飦飩", 30, "铩铫铮铯铳铴铵铷铹铼铽铿锃锂锆锇锉锊锍锎锏锒", 4, "锘锛锝锞锟锢锪锫锩锬锱锲锴锶锷锸锼锾锿镂锵镄镅镆镉镌镎镏镒镓镔镖镗镘镙镛镞镟镝镡镢镤", 8, "镯镱镲镳锺矧矬雉秕秭秣秫稆嵇稃稂稞稔"], ["f040", "餈", 4, "餎餏餑", 28, "餯", 26], ["f080", "饊", 9, "饖", 12, "饤饦饳饸饹饻饾馂馃馉稹稷穑黏馥穰皈皎皓皙皤瓞瓠甬鸠鸢鸨", 4, "鸲鸱鸶鸸鸷鸹鸺鸾鹁鹂鹄鹆鹇鹈鹉鹋鹌鹎鹑鹕鹗鹚鹛鹜鹞鹣鹦", 6, "鹱鹭鹳疒疔疖疠疝疬疣疳疴疸痄疱疰痃痂痖痍痣痨痦痤痫痧瘃痱痼痿瘐瘀瘅瘌瘗瘊瘥瘘瘕瘙"], ["f140", "馌馎馚", 10, "馦馧馩", 47], ["f180", "駙", 32, "瘛瘼瘢瘠癀瘭瘰瘿瘵癃瘾瘳癍癞癔癜癖癫癯翊竦穸穹窀窆窈窕窦窠窬窨窭窳衤衩衲衽衿袂袢裆袷袼裉裢裎裣裥裱褚裼裨裾裰褡褙褓褛褊褴褫褶襁襦襻疋胥皲皴矜耒耔耖耜耠耢耥耦耧耩耨耱耋耵聃聆聍聒聩聱覃顸颀颃"], ["f240", "駺", 62], ["f280", "騹", 32, "颉颌颍颏颔颚颛颞颟颡颢颥颦虍虔虬虮虿虺虼虻蚨蚍蚋蚬蚝蚧蚣蚪蚓蚩蚶蛄蚵蛎蚰蚺蚱蚯蛉蛏蚴蛩蛱蛲蛭蛳蛐蜓蛞蛴蛟蛘蛑蜃蜇蛸蜈蜊蜍蜉蜣蜻蜞蜥蜮蜚蜾蝈蜴蜱蜩蜷蜿螂蜢蝽蝾蝻蝠蝰蝌蝮螋蝓蝣蝼蝤蝙蝥螓螯螨蟒"], ["f340", "驚", 17, "驲骃骉骍骎骔骕骙骦骩", 6, "骲骳骴骵骹骻骽骾骿髃髄髆", 4, "髍髎髏髐髒體髕髖髗髙髚髛髜"], ["f380", "髝髞髠髢髣髤髥髧髨髩髪髬髮髰", 8, "髺髼", 6, "鬄鬅鬆蟆螈螅螭螗螃螫蟥螬螵螳蟋蟓螽蟑蟀蟊蟛蟪蟠蟮蠖蠓蟾蠊蠛蠡蠹蠼缶罂罄罅舐竺竽笈笃笄笕笊笫笏筇笸笪笙笮笱笠笥笤笳笾笞筘筚筅筵筌筝筠筮筻筢筲筱箐箦箧箸箬箝箨箅箪箜箢箫箴篑篁篌篝篚篥篦篪簌篾篼簏簖簋"], ["f440", "鬇鬉", 5, "鬐鬑鬒鬔", 10, "鬠鬡鬢鬤", 10, "鬰鬱鬳", 7, "鬽鬾鬿魀魆魊魋魌魎魐魒魓魕", 5], ["f480", "魛", 32, "簟簪簦簸籁籀臾舁舂舄臬衄舡舢舣舭舯舨舫舸舻舳舴舾艄艉艋艏艚艟艨衾袅袈裘裟襞羝羟羧羯羰羲籼敉粑粝粜粞粢粲粼粽糁糇糌糍糈糅糗糨艮暨羿翎翕翥翡翦翩翮翳糸絷綦綮繇纛麸麴赳趄趔趑趱赧赭豇豉酊酐酎酏酤"], ["f540", "魼", 62], ["f580", "鮻", 32, "酢酡酰酩酯酽酾酲酴酹醌醅醐醍醑醢醣醪醭醮醯醵醴醺豕鹾趸跫踅蹙蹩趵趿趼趺跄跖跗跚跞跎跏跛跆跬跷跸跣跹跻跤踉跽踔踝踟踬踮踣踯踺蹀踹踵踽踱蹉蹁蹂蹑蹒蹊蹰蹶蹼蹯蹴躅躏躔躐躜躞豸貂貊貅貘貔斛觖觞觚觜"], ["f640", "鯜", 62], ["f680", "鰛", 32, "觥觫觯訾謦靓雩雳雯霆霁霈霏霎霪霭霰霾龀龃龅", 5, "龌黾鼋鼍隹隼隽雎雒瞿雠銎銮鋈錾鍪鏊鎏鐾鑫鱿鲂鲅鲆鲇鲈稣鲋鲎鲐鲑鲒鲔鲕鲚鲛鲞", 5, "鲥", 4, "鲫鲭鲮鲰", 7, "鲺鲻鲼鲽鳄鳅鳆鳇鳊鳋"], ["f740", "鰼", 62], ["f780", "鱻鱽鱾鲀鲃鲄鲉鲊鲌鲏鲓鲖鲗鲘鲙鲝鲪鲬鲯鲹鲾", 4, "鳈鳉鳑鳒鳚鳛鳠鳡鳌", 4, "鳓鳔鳕鳗鳘鳙鳜鳝鳟鳢靼鞅鞑鞒鞔鞯鞫鞣鞲鞴骱骰骷鹘骶骺骼髁髀髅髂髋髌髑魅魃魇魉魈魍魑飨餍餮饕饔髟髡髦髯髫髻髭髹鬈鬏鬓鬟鬣麽麾縻麂麇麈麋麒鏖麝麟黛黜黝黠黟黢黩黧黥黪黯鼢鼬鼯鼹鼷鼽鼾齄"], ["f840", "鳣", 62], ["f880", "鴢", 32], ["f940", "鵃", 62], ["f980", "鶂", 32], ["fa40", "鶣", 62], ["fa80", "鷢", 32], ["fb40", "鸃", 27, "鸤鸧鸮鸰鸴鸻鸼鹀鹍鹐鹒鹓鹔鹖鹙鹝鹟鹠鹡鹢鹥鹮鹯鹲鹴", 9, "麀"], ["fb80", "麁麃麄麅麆麉麊麌", 5, "麔", 8, "麞麠", 5, "麧麨麩麪"], ["fc40", "麫", 8, "麵麶麷麹麺麼麿", 4, "黅黆黇黈黊黋黌黐黒黓黕黖黗黙黚點黡黣黤黦黨黫黬黭黮黰", 8, "黺黽黿", 6], ["fc80", "鼆", 4, "鼌鼏鼑鼒鼔鼕鼖鼘鼚", 5, "鼡鼣", 8, "鼭鼮鼰鼱"], ["fd40", "鼲", 4, "鼸鼺鼼鼿", 4, "齅", 10, "齒", 38], ["fd80", "齹", 5, "龁龂龍", 11, "龜龝龞龡", 4, "郎凉秊裏隣"], ["fe40", "兀嗀﨎﨏﨑﨓﨔礼﨟蘒﨡﨣﨤﨧﨨﨩"]];
    }, {}],
    21: [function (require, module, exports) {
      module.exports = [["0", "\0", 127], ["8141", "갂갃갅갆갋", 4, "갘갞갟갡갢갣갥", 6, "갮갲갳갴"], ["8161", "갵갶갷갺갻갽갾갿걁", 9, "걌걎", 5, "걕"], ["8181", "걖걗걙걚걛걝", 18, "걲걳걵걶걹걻", 4, "겂겇겈겍겎겏겑겒겓겕", 6, "겞겢", 5, "겫겭겮겱", 6, "겺겾겿곀곂곃곅곆곇곉곊곋곍", 7, "곖곘", 7, "곢곣곥곦곩곫곭곮곲곴곷", 4, "곾곿괁괂괃괅괇", 4, "괎괐괒괓"], ["8241", "괔괕괖괗괙괚괛괝괞괟괡", 7, "괪괫괮", 5], ["8261", "괶괷괹괺괻괽", 6, "굆굈굊", 5, "굑굒굓굕굖굗"], ["8281", "굙", 7, "굢굤", 7, "굮굯굱굲굷굸굹굺굾궀궃", 4, "궊궋궍궎궏궑", 10, "궞", 5, "궥", 17, "궸", 7, "귂귃귅귆귇귉", 6, "귒귔", 7, "귝귞귟귡귢귣귥", 18], ["8341", "귺귻귽귾긂", 5, "긊긌긎", 5, "긕", 7], ["8361", "긝", 18, "긲긳긵긶긹긻긼"], ["8381", "긽긾긿깂깄깇깈깉깋깏깑깒깓깕깗", 4, "깞깢깣깤깦깧깪깫깭깮깯깱", 6, "깺깾", 5, "꺆", 5, "꺍", 46, "꺿껁껂껃껅", 6, "껎껒", 5, "껚껛껝", 8], ["8441", "껦껧껩껪껬껮", 5, "껵껶껷껹껺껻껽", 8], ["8461", "꼆꼉꼊꼋꼌꼎꼏꼑", 18], ["8481", "꼤", 7, "꼮꼯꼱꼳꼵", 6, "꼾꽀꽄꽅꽆꽇꽊", 5, "꽑", 10, "꽞", 5, "꽦", 18, "꽺", 5, "꾁꾂꾃꾅꾆꾇꾉", 6, "꾒꾓꾔꾖", 5, "꾝", 26, "꾺꾻꾽꾾"], ["8541", "꾿꿁", 5, "꿊꿌꿏", 4, "꿕", 6, "꿝", 4], ["8561", "꿢", 5, "꿪", 5, "꿲꿳꿵꿶꿷꿹", 6, "뀂뀃"], ["8581", "뀅", 6, "뀍뀎뀏뀑뀒뀓뀕", 6, "뀞", 9, "뀩", 26, "끆끇끉끋끍끏끐끑끒끖끘끚끛끜끞", 29, "끾끿낁낂낃낅", 6, "낎낐낒", 5, "낛낝낞낣낤"], ["8641", "낥낦낧낪낰낲낶낷낹낺낻낽", 6, "냆냊", 5, "냒"], ["8661", "냓냕냖냗냙", 6, "냡냢냣냤냦", 10], ["8681", "냱", 22, "넊넍넎넏넑넔넕넖넗넚넞", 4, "넦넧넩넪넫넭", 6, "넶넺", 5, "녂녃녅녆녇녉", 6, "녒녓녖녗녙녚녛녝녞녟녡", 22, "녺녻녽녾녿놁놃", 4, "놊놌놎놏놐놑놕놖놗놙놚놛놝"], ["8741", "놞", 9, "놩", 15], ["8761", "놹", 18, "뇍뇎뇏뇑뇒뇓뇕"], ["8781", "뇖", 5, "뇞뇠", 7, "뇪뇫뇭뇮뇯뇱", 7, "뇺뇼뇾", 5, "눆눇눉눊눍", 6, "눖눘눚", 5, "눡", 18, "눵", 6, "눽", 26, "뉙뉚뉛뉝뉞뉟뉡", 6, "뉪", 4], ["8841", "뉯", 4, "뉶", 5, "뉽", 6, "늆늇늈늊", 4], ["8861", "늏늒늓늕늖늗늛", 4, "늢늤늧늨늩늫늭늮늯늱늲늳늵늶늷"], ["8881", "늸", 15, "닊닋닍닎닏닑닓", 4, "닚닜닞닟닠닡닣닧닩닪닰닱닲닶닼닽닾댂댃댅댆댇댉", 6, "댒댖", 5, "댝", 54, "덗덙덚덝덠덡덢덣"], ["8941", "덦덨덪덬덭덯덲덳덵덶덷덹", 6, "뎂뎆", 5, "뎍"], ["8961", "뎎뎏뎑뎒뎓뎕", 10, "뎢", 5, "뎩뎪뎫뎭"], ["8981", "뎮", 21, "돆돇돉돊돍돏돑돒돓돖돘돚돜돞돟돡돢돣돥돦돧돩", 18, "돽", 18, "됑", 6, "됙됚됛됝됞됟됡", 6, "됪됬", 7, "됵", 15], ["8a41", "둅", 10, "둒둓둕둖둗둙", 6, "둢둤둦"], ["8a61", "둧", 4, "둭", 18, "뒁뒂"], ["8a81", "뒃", 4, "뒉", 19, "뒞", 5, "뒥뒦뒧뒩뒪뒫뒭", 7, "뒶뒸뒺", 5, "듁듂듃듅듆듇듉", 6, "듑듒듓듔듖", 5, "듞듟듡듢듥듧", 4, "듮듰듲", 5, "듹", 26, "딖딗딙딚딝"], ["8b41", "딞", 5, "딦딫", 4, "딲딳딵딶딷딹", 6, "땂땆"], ["8b61", "땇땈땉땊땎땏땑땒땓땕", 6, "땞땢", 8], ["8b81", "땫", 52, "떢떣떥떦떧떩떬떭떮떯떲떶", 4, "떾떿뗁뗂뗃뗅", 6, "뗎뗒", 5, "뗙", 18, "뗭", 18], ["8c41", "똀", 15, "똒똓똕똖똗똙", 4], ["8c61", "똞", 6, "똦", 5, "똭", 6, "똵", 5], ["8c81", "똻", 12, "뙉", 26, "뙥뙦뙧뙩", 50, "뚞뚟뚡뚢뚣뚥", 5, "뚭뚮뚯뚰뚲", 16], ["8d41", "뛃", 16, "뛕", 8], ["8d61", "뛞", 17, "뛱뛲뛳뛵뛶뛷뛹뛺"], ["8d81", "뛻", 4, "뜂뜃뜄뜆", 33, "뜪뜫뜭뜮뜱", 6, "뜺뜼", 7, "띅띆띇띉띊띋띍", 6, "띖", 9, "띡띢띣띥띦띧띩", 6, "띲띴띶", 5, "띾띿랁랂랃랅", 6, "랎랓랔랕랚랛랝랞"], ["8e41", "랟랡", 6, "랪랮", 5, "랶랷랹", 8], ["8e61", "럂", 4, "럈럊", 19], ["8e81", "럞", 13, "럮럯럱럲럳럵", 6, "럾렂", 4, "렊렋렍렎렏렑", 6, "렚렜렞", 5, "렦렧렩렪렫렭", 6, "렶렺", 5, "롁롂롃롅", 11, "롒롔", 7, "롞롟롡롢롣롥", 6, "롮롰롲", 5, "롹롺롻롽", 7], ["8f41", "뢅", 7, "뢎", 17], ["8f61", "뢠", 7, "뢩", 6, "뢱뢲뢳뢵뢶뢷뢹", 4], ["8f81", "뢾뢿룂룄룆", 5, "룍룎룏룑룒룓룕", 7, "룞룠룢", 5, "룪룫룭룮룯룱", 6, "룺룼룾", 5, "뤅", 18, "뤙", 6, "뤡", 26, "뤾뤿륁륂륃륅", 6, "륍륎륐륒", 5], ["9041", "륚륛륝륞륟륡", 6, "륪륬륮", 5, "륶륷륹륺륻륽"], ["9061", "륾", 5, "릆릈릋릌릏", 15], ["9081", "릟", 12, "릮릯릱릲릳릵", 6, "릾맀맂", 5, "맊맋맍맓", 4, "맚맜맟맠맢맦맧맩맪맫맭", 6, "맶맻", 4, "먂", 5, "먉", 11, "먖", 33, "먺먻먽먾먿멁멃멄멅멆"], ["9141", "멇멊멌멏멐멑멒멖멗멙멚멛멝", 6, "멦멪", 5], ["9161", "멲멳멵멶멷멹", 9, "몆몈몉몊몋몍", 5], ["9181", "몓", 20, "몪몭몮몯몱몳", 4, "몺몼몾", 5, "뫅뫆뫇뫉", 14, "뫚", 33, "뫽뫾뫿묁묂묃묅", 7, "묎묐묒", 5, "묙묚묛묝묞묟묡", 6], ["9241", "묨묪묬", 7, "묷묹묺묿", 4, "뭆뭈뭊뭋뭌뭎뭑뭒"], ["9261", "뭓뭕뭖뭗뭙", 7, "뭢뭤", 7, "뭭", 4], ["9281", "뭲", 21, "뮉뮊뮋뮍뮎뮏뮑", 18, "뮥뮦뮧뮩뮪뮫뮭", 6, "뮵뮶뮸", 7, "믁믂믃믅믆믇믉", 6, "믑믒믔", 35, "믺믻믽믾밁"], ["9341", "밃", 4, "밊밎밐밒밓밙밚밠밡밢밣밦밨밪밫밬밮밯밲밳밵"], ["9361", "밶밷밹", 6, "뱂뱆뱇뱈뱊뱋뱎뱏뱑", 8], ["9381", "뱚뱛뱜뱞", 37, "벆벇벉벊벍벏", 4, "벖벘벛", 4, "벢벣벥벦벩", 6, "벲벶", 5, "벾벿볁볂볃볅", 7, "볎볒볓볔볖볗볙볚볛볝", 22, "볷볹볺볻볽"], ["9441", "볾", 5, "봆봈봊", 5, "봑봒봓봕", 8], ["9461", "봞", 5, "봥", 6, "봭", 12], ["9481", "봺", 5, "뵁", 6, "뵊뵋뵍뵎뵏뵑", 6, "뵚", 9, "뵥뵦뵧뵩", 22, "붂붃붅붆붋", 4, "붒붔붖붗붘붛붝", 6, "붥", 10, "붱", 6, "붹", 24], ["9541", "뷒뷓뷖뷗뷙뷚뷛뷝", 11, "뷪", 5, "뷱"], ["9561", "뷲뷳뷵뷶뷷뷹", 6, "븁븂븄븆", 5, "븎븏븑븒븓"], ["9581", "븕", 6, "븞븠", 35, "빆빇빉빊빋빍빏", 4, "빖빘빜빝빞빟빢빣빥빦빧빩빫", 4, "빲빶", 4, "빾빿뺁뺂뺃뺅", 6, "뺎뺒", 5, "뺚", 13, "뺩", 14], ["9641", "뺸", 23, "뻒뻓"], ["9661", "뻕뻖뻙", 6, "뻡뻢뻦", 5, "뻭", 8], ["9681", "뻶", 10, "뼂", 5, "뼊", 13, "뼚뼞", 33, "뽂뽃뽅뽆뽇뽉", 6, "뽒뽓뽔뽖", 44], ["9741", "뾃", 16, "뾕", 8], ["9761", "뾞", 17, "뾱", 7], ["9781", "뾹", 11, "뿆", 5, "뿎뿏뿑뿒뿓뿕", 6, "뿝뿞뿠뿢", 89, "쀽쀾쀿"], ["9841", "쁀", 16, "쁒", 5, "쁙쁚쁛"], ["9861", "쁝쁞쁟쁡", 6, "쁪", 15], ["9881", "쁺", 21, "삒삓삕삖삗삙", 6, "삢삤삦", 5, "삮삱삲삷", 4, "삾샂샃샄샆샇샊샋샍샎샏샑", 6, "샚샞", 5, "샦샧샩샪샫샭", 6, "샶샸샺", 5, "섁섂섃섅섆섇섉", 6, "섑섒섓섔섖", 5, "섡섢섥섨섩섪섫섮"], ["9941", "섲섳섴섵섷섺섻섽섾섿셁", 6, "셊셎", 5, "셖셗"], ["9961", "셙셚셛셝", 6, "셦셪", 5, "셱셲셳셵셶셷셹셺셻"], ["9981", "셼", 8, "솆", 5, "솏솑솒솓솕솗", 4, "솞솠솢솣솤솦솧솪솫솭솮솯솱", 11, "솾", 5, "쇅쇆쇇쇉쇊쇋쇍", 6, "쇕쇖쇙", 6, "쇡쇢쇣쇥쇦쇧쇩", 6, "쇲쇴", 7, "쇾쇿숁숂숃숅", 6, "숎숐숒", 5, "숚숛숝숞숡숢숣"], ["9a41", "숤숥숦숧숪숬숮숰숳숵", 16], ["9a61", "쉆쉇쉉", 6, "쉒쉓쉕쉖쉗쉙", 6, "쉡쉢쉣쉤쉦"], ["9a81", "쉧", 4, "쉮쉯쉱쉲쉳쉵", 6, "쉾슀슂", 5, "슊", 5, "슑", 6, "슙슚슜슞", 5, "슦슧슩슪슫슮", 5, "슶슸슺", 33, "싞싟싡싢싥", 5, "싮싰싲싳싴싵싷싺싽싾싿쌁", 6, "쌊쌋쌎쌏"], ["9b41", "쌐쌑쌒쌖쌗쌙쌚쌛쌝", 6, "쌦쌧쌪", 8], ["9b61", "쌳", 17, "썆", 7], ["9b81", "썎", 25, "썪썫썭썮썯썱썳", 4, "썺썻썾", 5, "쎅쎆쎇쎉쎊쎋쎍", 50, "쏁", 22, "쏚"], ["9c41", "쏛쏝쏞쏡쏣", 4, "쏪쏫쏬쏮", 5, "쏶쏷쏹", 5], ["9c61", "쏿", 8, "쐉", 6, "쐑", 9], ["9c81", "쐛", 8, "쐥", 6, "쐭쐮쐯쐱쐲쐳쐵", 6, "쐾", 9, "쑉", 26, "쑦쑧쑩쑪쑫쑭", 6, "쑶쑷쑸쑺", 5, "쒁", 18, "쒕", 6, "쒝", 12], ["9d41", "쒪", 13, "쒹쒺쒻쒽", 8], ["9d61", "쓆", 25], ["9d81", "쓠", 8, "쓪", 5, "쓲쓳쓵쓶쓷쓹쓻쓼쓽쓾씂", 9, "씍씎씏씑씒씓씕", 6, "씝", 10, "씪씫씭씮씯씱", 6, "씺씼씾", 5, "앆앇앋앏앐앑앒앖앚앛앜앟앢앣앥앦앧앩", 6, "앲앶", 5, "앾앿얁얂얃얅얆얈얉얊얋얎얐얒얓얔"], ["9e41", "얖얙얚얛얝얞얟얡", 7, "얪", 9, "얶"], ["9e61", "얷얺얿", 4, "엋엍엏엒엓엕엖엗엙", 6, "엢엤엦엧"], ["9e81", "엨엩엪엫엯엱엲엳엵엸엹엺엻옂옃옄옉옊옋옍옎옏옑", 6, "옚옝", 6, "옦옧옩옪옫옯옱옲옶옸옺옼옽옾옿왂왃왅왆왇왉", 6, "왒왖", 5, "왞왟왡", 10, "왭왮왰왲", 5, "왺왻왽왾왿욁", 6, "욊욌욎", 5, "욖욗욙욚욛욝", 6, "욦"], ["9f41", "욨욪", 5, "욲욳욵욶욷욻", 4, "웂웄웆", 5, "웎"], ["9f61", "웏웑웒웓웕", 6, "웞웟웢", 5, "웪웫웭웮웯웱웲"], ["9f81", "웳", 4, "웺웻웼웾", 5, "윆윇윉윊윋윍", 6, "윖윘윚", 5, "윢윣윥윦윧윩", 6, "윲윴윶윸윹윺윻윾윿읁읂읃읅", 4, "읋읎읐읙읚읛읝읞읟읡", 6, "읩읪읬", 7, "읶읷읹읺읻읿잀잁잂잆잋잌잍잏잒잓잕잙잛", 4, "잢잧", 4, "잮잯잱잲잳잵잶잷"], ["a041", "잸잹잺잻잾쟂", 5, "쟊쟋쟍쟏쟑", 6, "쟙쟚쟛쟜"], ["a061", "쟞", 5, "쟥쟦쟧쟩쟪쟫쟭", 13], ["a081", "쟻", 4, "젂젃젅젆젇젉젋", 4, "젒젔젗", 4, "젞젟젡젢젣젥", 6, "젮젰젲", 5, "젹젺젻젽젾젿졁", 6, "졊졋졎", 5, "졕", 26, "졲졳졵졶졷졹졻", 4, "좂좄좈좉좊좎", 5, "좕", 7, "좞좠좢좣좤"], ["a141", "좥좦좧좩", 18, "좾좿죀죁"], ["a161", "죂죃죅죆죇죉죊죋죍", 6, "죖죘죚", 5, "죢죣죥"], ["a181", "죦", 14, "죶", 5, "죾죿줁줂줃줇", 4, "줎　、。·‥…¨〃­―∥＼∼‘’“”〔〕〈", 9, "±×÷≠≤≥∞∴°′″℃Å￠￡￥♂♀∠⊥⌒∂∇≡≒§※☆★○●◎◇◆□■△▲▽▼→←↑↓↔〓≪≫√∽∝∵∫∬∈∋⊆⊇⊂⊃∪∩∧∨￢"], ["a241", "줐줒", 5, "줙", 18], ["a261", "줭", 6, "줵", 18], ["a281", "쥈", 7, "쥒쥓쥕쥖쥗쥙", 6, "쥢쥤", 7, "쥭쥮쥯⇒⇔∀∃´～ˇ˘˝˚˙¸˛¡¿ː∮∑∏¤℉‰◁◀▷▶♤♠♡♥♧♣⊙◈▣◐◑▒▤▥▨▧▦▩♨☏☎☜☞¶†‡↕↗↙↖↘♭♩♪♬㉿㈜№㏇™㏂㏘℡€®"], ["a341", "쥱쥲쥳쥵", 6, "쥽", 10, "즊즋즍즎즏"], ["a361", "즑", 6, "즚즜즞", 16], ["a381", "즯", 16, "짂짃짅짆짉짋", 4, "짒짔짗짘짛！", 58, "￦］", 32, "￣"], ["a441", "짞짟짡짣짥짦짨짩짪짫짮짲", 5, "짺짻짽짾짿쨁쨂쨃쨄"], ["a461", "쨅쨆쨇쨊쨎", 5, "쨕쨖쨗쨙", 12], ["a481", "쨦쨧쨨쨪", 28, "ㄱ", 93], ["a541", "쩇", 4, "쩎쩏쩑쩒쩓쩕", 6, "쩞쩢", 5, "쩩쩪"], ["a561", "쩫", 17, "쩾", 5, "쪅쪆"], ["a581", "쪇", 16, "쪙", 14, "ⅰ", 9], ["a5b0", "Ⅰ", 9], ["a5c1", "Α", 16, "Σ", 6], ["a5e1", "α", 16, "σ", 6], ["a641", "쪨", 19, "쪾쪿쫁쫂쫃쫅"], ["a661", "쫆", 5, "쫎쫐쫒쫔쫕쫖쫗쫚", 5, "쫡", 6], ["a681", "쫨쫩쫪쫫쫭", 6, "쫵", 18, "쬉쬊─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂┒┑┚┙┖┕┎┍┞┟┡┢┦┧┩┪┭┮┱┲┵┶┹┺┽┾╀╁╃", 7], ["a741", "쬋", 4, "쬑쬒쬓쬕쬖쬗쬙", 6, "쬢", 7], ["a761", "쬪", 22, "쭂쭃쭄"], ["a781", "쭅쭆쭇쭊쭋쭍쭎쭏쭑", 6, "쭚쭛쭜쭞", 5, "쭥", 7, "㎕㎖㎗ℓ㎘㏄㎣㎤㎥㎦㎙", 9, "㏊㎍㎎㎏㏏㎈㎉㏈㎧㎨㎰", 9, "㎀", 4, "㎺", 5, "㎐", 4, "Ω㏀㏁㎊㎋㎌㏖㏅㎭㎮㎯㏛㎩㎪㎫㎬㏝㏐㏓㏃㏉㏜㏆"], ["a841", "쭭", 10, "쭺", 14], ["a861", "쮉", 18, "쮝", 6], ["a881", "쮤", 19, "쮹", 11, "ÆÐªĦ"], ["a8a6", "Ĳ"], ["a8a8", "ĿŁØŒºÞŦŊ"], ["a8b1", "㉠", 27, "ⓐ", 25, "①", 14, "½⅓⅔¼¾⅛⅜⅝⅞"], ["a941", "쯅", 14, "쯕", 10], ["a961", "쯠쯡쯢쯣쯥쯦쯨쯪", 18], ["a981", "쯽", 14, "찎찏찑찒찓찕", 6, "찞찟찠찣찤æđðħıĳĸŀłøœßþŧŋŉ㈀", 27, "⒜", 25, "⑴", 14, "¹²³⁴ⁿ₁₂₃₄"], ["aa41", "찥찦찪찫찭찯찱", 6, "찺찿", 4, "챆챇챉챊챋챍챎"], ["aa61", "챏", 4, "챖챚", 5, "챡챢챣챥챧챩", 6, "챱챲"], ["aa81", "챳챴챶", 29, "ぁ", 82], ["ab41", "첔첕첖첗첚첛첝첞첟첡", 6, "첪첮", 5, "첶첷첹"], ["ab61", "첺첻첽", 6, "쳆쳈쳊", 5, "쳑쳒쳓쳕", 5], ["ab81", "쳛", 8, "쳥", 6, "쳭쳮쳯쳱", 12, "ァ", 85], ["ac41", "쳾쳿촀촂", 5, "촊촋촍촎촏촑", 6, "촚촜촞촟촠"], ["ac61", "촡촢촣촥촦촧촩촪촫촭", 11, "촺", 4], ["ac81", "촿", 28, "쵝쵞쵟А", 5, "ЁЖ", 25], ["acd1", "а", 5, "ёж", 25], ["ad41", "쵡쵢쵣쵥", 6, "쵮쵰쵲", 5, "쵹", 7], ["ad61", "춁", 6, "춉", 10, "춖춗춙춚춛춝춞춟"], ["ad81", "춠춡춢춣춦춨춪", 5, "춱", 18, "췅"], ["ae41", "췆", 5, "췍췎췏췑", 16], ["ae61", "췢", 5, "췩췪췫췭췮췯췱", 6, "췺췼췾", 4], ["ae81", "츃츅츆츇츉츊츋츍", 6, "츕츖츗츘츚", 5, "츢츣츥츦츧츩츪츫"], ["af41", "츬츭츮츯츲츴츶", 19], ["af61", "칊", 13, "칚칛칝칞칢", 5, "칪칬"], ["af81", "칮", 5, "칶칷칹칺칻칽", 6, "캆캈캊", 5, "캒캓캕캖캗캙"], ["b041", "캚", 5, "캢캦", 5, "캮", 12], ["b061", "캻", 5, "컂", 19], ["b081", "컖", 13, "컦컧컩컪컭", 6, "컶컺", 5, "가각간갇갈갉갊감", 7, "같", 4, "갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧골곪곬곯곰곱곳공곶과곽관괄괆"], ["b141", "켂켃켅켆켇켉", 6, "켒켔켖", 5, "켝켞켟켡켢켣"], ["b161", "켥", 6, "켮켲", 5, "켹", 11], ["b181", "콅", 14, "콖콗콙콚콛콝", 6, "콦콨콪콫콬괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸"], ["b241", "콭콮콯콲콳콵콶콷콹", 6, "쾁쾂쾃쾄쾆", 5, "쾍"], ["b261", "쾎", 18, "쾢", 5, "쾩"], ["b281", "쾪", 5, "쾱", 18, "쿅", 6, "깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕끗끙"], ["b341", "쿌", 19, "쿢쿣쿥쿦쿧쿩"], ["b361", "쿪", 5, "쿲쿴쿶", 5, "쿽쿾쿿퀁퀂퀃퀅", 5], ["b381", "퀋", 5, "퀒", 5, "퀙", 19, "끝끼끽낀낄낌낍낏낑나낙낚난낟날낡낢남납낫", 4, "낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨뇌뇐뇔뇜뇝"], ["b441", "퀮", 5, "퀶퀷퀹퀺퀻퀽", 6, "큆큈큊", 5], ["b461", "큑큒큓큕큖큗큙", 6, "큡", 10, "큮큯"], ["b481", "큱큲큳큵", 6, "큾큿킀킂", 18, "뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘늙늚늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢다닥닦단닫", 4, "닳담답닷", 4, "닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥"], ["b541", "킕", 14, "킦킧킩킪킫킭", 5], ["b561", "킳킶킸킺", 5, "탂탃탅탆탇탊", 5, "탒탖", 4], ["b581", "탛탞탟탡탢탣탥", 6, "탮탲", 5, "탹", 11, "덧덩덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘딛딜딤딥딧딨딩딪따딱딴딸"], ["b641", "턅", 7, "턎", 17], ["b661", "턠", 15, "턲턳턵턶턷턹턻턼턽턾"], ["b681", "턿텂텆", 5, "텎텏텑텒텓텕", 6, "텞텠텢", 5, "텩텪텫텭땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵라락란랄람랍랏랐랑랒랖랗"], ["b741", "텮", 13, "텽", 6, "톅톆톇톉톊"], ["b761", "톋", 20, "톢톣톥톦톧"], ["b781", "톩", 6, "톲톴톶톷톸톹톻톽톾톿퇁", 14, "래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩"], ["b841", "퇐", 7, "퇙", 17], ["b861", "퇫", 8, "퇵퇶퇷퇹", 13], ["b881", "툈툊", 5, "툑", 24, "륫륭르륵른를름릅릇릉릊릍릎리릭린릴림립릿링마막만많", 4, "맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼"], ["b941", "툪툫툮툯툱툲툳툵", 6, "툾퉀퉂", 5, "퉉퉊퉋퉌"], ["b961", "퉍", 14, "퉝", 6, "퉥퉦퉧퉨"], ["b981", "퉩", 22, "튂튃튅튆튇튉튊튋튌묀묄묍묏묑묘묜묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿밀밂밈밉밋밌밍및밑바", 4, "받", 4, "밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗"], ["ba41", "튍튎튏튒튓튔튖", 5, "튝튞튟튡튢튣튥", 6, "튭"], ["ba61", "튮튯튰튲", 5, "튺튻튽튾틁틃", 4, "틊틌", 5], ["ba81", "틒틓틕틖틗틙틚틛틝", 6, "틦", 9, "틲틳틵틶틷틹틺벙벚베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘뵙뵤뵨부북분붇불붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅빈빌빎빔빕빗빙빚빛빠빡빤"], ["bb41", "틻", 4, "팂팄팆", 5, "팏팑팒팓팕팗", 4, "팞팢팣"], ["bb61", "팤팦팧팪팫팭팮팯팱", 6, "팺팾", 5, "퍆퍇퍈퍉"], ["bb81", "퍊", 31, "빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤"], ["bc41", "퍪", 17, "퍾퍿펁펂펃펅펆펇"], ["bc61", "펈펉펊펋펎펒", 5, "펚펛펝펞펟펡", 6, "펪펬펮"], ["bc81", "펯", 4, "펵펶펷펹펺펻펽", 6, "폆폇폊", 5, "폑", 5, "샥샨샬샴샵샷샹섀섄섈섐섕서", 4, "섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭"], ["bd41", "폗폙", 7, "폢폤", 7, "폮폯폱폲폳폵폶폷"], ["bd61", "폸폹폺폻폾퐀퐂", 5, "퐉", 13], ["bd81", "퐗", 5, "퐞", 25, "숯숱숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십싯싱싶싸싹싻싼쌀쌈쌉쌌쌍쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰"], ["be41", "퐸", 7, "푁푂푃푅", 14], ["be61", "푔", 7, "푝푞푟푡푢푣푥", 7, "푮푰푱푲"], ["be81", "푳", 4, "푺푻푽푾풁풃", 4, "풊풌풎", 5, "풕", 8, "쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔씜씨씩씬씰씸씹씻씽아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩어억언얹얻얼얽얾엄", 6, "엌엎"], ["bf41", "풞", 10, "풪", 14], ["bf61", "풹", 18, "퓍퓎퓏퓑퓒퓓퓕"], ["bf81", "퓖", 5, "퓝퓞퓠", 7, "퓩퓪퓫퓭퓮퓯퓱", 6, "퓹퓺퓼에엑엔엘엠엡엣엥여역엮연열엶엷염", 5, "옅옆옇예옌옐옘옙옛옜오옥온올옭옮옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨"], ["c041", "퓾", 5, "픅픆픇픉픊픋픍", 6, "픖픘", 5], ["c061", "픞", 25], ["c081", "픸픹픺픻픾픿핁핂핃핅", 6, "핎핐핒", 5, "핚핛핝핞핟핡핢핣웩웬웰웸웹웽위윅윈윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응", 7, "읜읠읨읫이익인일읽읾잃임입잇있잉잊잎자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊"], ["c141", "핤핦핧핪핬핮", 5, "핶핷핹핺핻핽", 6, "햆햊햋"], ["c161", "햌햍햎햏햑", 19, "햦햧"], ["c181", "햨", 31, "점접젓정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙즛증지직진짇질짊짐집짓"], ["c241", "헊헋헍헎헏헑헓", 4, "헚헜헞", 5, "헦헧헩헪헫헭헮"], ["c261", "헯", 4, "헶헸헺", 5, "혂혃혅혆혇혉", 6, "혒"], ["c281", "혖", 5, "혝혞혟혡혢혣혥", 7, "혮", 9, "혺혻징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧차착찬찮찰참찹찻"], ["c341", "혽혾혿홁홂홃홄홆홇홊홌홎홏홐홒홓홖홗홙홚홛홝", 4], ["c361", "홢", 4, "홨홪", 5, "홲홳홵", 11], ["c381", "횁횂횄횆", 5, "횎횏횑횒횓횕", 7, "횞횠횢", 5, "횩횪찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층"], ["c441", "횫횭횮횯횱", 7, "횺횼", 7, "훆훇훉훊훋"], ["c461", "훍훎훏훐훒훓훕훖훘훚", 5, "훡훢훣훥훦훧훩", 4], ["c481", "훮훯훱훲훳훴훶", 5, "훾훿휁휂휃휅", 11, "휒휓휔치칙친칟칠칡침칩칫칭카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켕켜켠켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭퀴퀵퀸퀼"], ["c541", "휕휖휗휚휛휝휞휟휡", 6, "휪휬휮", 5, "휶휷휹"], ["c561", "휺휻휽", 6, "흅흆흈흊", 5, "흒흓흕흚", 4], ["c581", "흟흢흤흦흧흨흪흫흭흮흯흱흲흳흵", 6, "흾흿힀힂", 5, "힊힋큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜"], ["c641", "힍힎힏힑", 6, "힚힜힞", 5], ["c6a1", "퉤튀튁튄튈튐튑튕튜튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁"], ["c7a1", "퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑하학한할핥함합핫항해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현혈혐협혓혔형혜혠"], ["c8a1", "혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝"], ["caa1", "伽佳假價加可呵哥嘉嫁家暇架枷柯歌珂痂稼苛茄街袈訶賈跏軻迦駕刻却各恪慤殼珏脚覺角閣侃刊墾奸姦干幹懇揀杆柬桿澗癎看磵稈竿簡肝艮艱諫間乫喝曷渴碣竭葛褐蝎鞨勘坎堪嵌感憾戡敢柑橄減甘疳監瞰紺邯鑑鑒龕"], ["cba1", "匣岬甲胛鉀閘剛堈姜岡崗康强彊慷江畺疆糠絳綱羌腔舡薑襁講鋼降鱇介价個凱塏愷愾慨改槪漑疥皆盖箇芥蓋豈鎧開喀客坑更粳羹醵倨去居巨拒据據擧渠炬祛距踞車遽鉅鋸乾件健巾建愆楗腱虔蹇鍵騫乞傑杰桀儉劍劒檢"], ["cca1", "瞼鈐黔劫怯迲偈憩揭擊格檄激膈覡隔堅牽犬甄絹繭肩見譴遣鵑抉決潔結缺訣兼慊箝謙鉗鎌京俓倞傾儆勁勍卿坰境庚徑慶憬擎敬景暻更梗涇炅烱璟璥瓊痙硬磬竟競絅經耕耿脛莖警輕逕鏡頃頸驚鯨係啓堺契季屆悸戒桂械"], ["cda1", "棨溪界癸磎稽系繫繼計誡谿階鷄古叩告呱固姑孤尻庫拷攷故敲暠枯槁沽痼皐睾稿羔考股膏苦苽菰藁蠱袴誥賈辜錮雇顧高鼓哭斛曲梏穀谷鵠困坤崑昆梱棍滾琨袞鯤汨滑骨供公共功孔工恐恭拱控攻珙空蚣貢鞏串寡戈果瓜"], ["cea1", "科菓誇課跨過鍋顆廓槨藿郭串冠官寬慣棺款灌琯瓘管罐菅觀貫關館刮恝括适侊光匡壙廣曠洸炚狂珖筐胱鑛卦掛罫乖傀塊壞怪愧拐槐魁宏紘肱轟交僑咬喬嬌嶠巧攪敎校橋狡皎矯絞翹膠蕎蛟較轎郊餃驕鮫丘久九仇俱具勾"], ["cfa1", "區口句咎嘔坵垢寇嶇廐懼拘救枸柩構歐毆毬求溝灸狗玖球瞿矩究絿耉臼舅舊苟衢謳購軀逑邱鉤銶駒驅鳩鷗龜國局菊鞠鞫麴君窘群裙軍郡堀屈掘窟宮弓穹窮芎躬倦券勸卷圈拳捲權淃眷厥獗蕨蹶闕机櫃潰詭軌饋句晷歸貴"], ["d0a1", "鬼龜叫圭奎揆槻珪硅窺竅糾葵規赳逵閨勻均畇筠菌鈞龜橘克剋劇戟棘極隙僅劤勤懃斤根槿瑾筋芹菫覲謹近饉契今妗擒昑檎琴禁禽芩衾衿襟金錦伋及急扱汲級給亘兢矜肯企伎其冀嗜器圻基埼夔奇妓寄岐崎己幾忌技旗旣"], ["d1a1", "朞期杞棋棄機欺氣汽沂淇玘琦琪璂璣畸畿碁磯祁祇祈祺箕紀綺羈耆耭肌記譏豈起錡錤飢饑騎騏驥麒緊佶吉拮桔金喫儺喇奈娜懦懶拏拿癩", 5, "那樂", 4, "諾酪駱亂卵暖欄煖爛蘭難鸞捏捺南嵐枏楠湳濫男藍襤拉"], ["d2a1", "納臘蠟衲囊娘廊", 4, "乃來內奈柰耐冷女年撚秊念恬拈捻寧寗努勞奴弩怒擄櫓爐瑙盧", 5, "駑魯", 10, "濃籠聾膿農惱牢磊腦賂雷尿壘", 7, "嫩訥杻紐勒", 5, "能菱陵尼泥匿溺多茶"], ["d3a1", "丹亶但單團壇彖斷旦檀段湍短端簞緞蛋袒鄲鍛撻澾獺疸達啖坍憺擔曇淡湛潭澹痰聃膽蕁覃談譚錟沓畓答踏遝唐堂塘幢戇撞棠當糖螳黨代垈坮大對岱帶待戴擡玳臺袋貸隊黛宅德悳倒刀到圖堵塗導屠島嶋度徒悼挑掉搗桃"], ["d4a1", "棹櫂淘渡滔濤燾盜睹禱稻萄覩賭跳蹈逃途道都鍍陶韜毒瀆牘犢獨督禿篤纛讀墩惇敦旽暾沌焞燉豚頓乭突仝冬凍動同憧東桐棟洞潼疼瞳童胴董銅兜斗杜枓痘竇荳讀豆逗頭屯臀芚遁遯鈍得嶝橙燈登等藤謄鄧騰喇懶拏癩羅"], ["d5a1", "蘿螺裸邏樂洛烙珞絡落諾酪駱丹亂卵欄欒瀾爛蘭鸞剌辣嵐擥攬欖濫籃纜藍襤覽拉臘蠟廊朗浪狼琅瑯螂郞來崍徠萊冷掠略亮倆兩凉梁樑粮粱糧良諒輛量侶儷勵呂廬慮戾旅櫚濾礪藜蠣閭驢驪麗黎力曆歷瀝礫轢靂憐戀攣漣"], ["d6a1", "煉璉練聯蓮輦連鍊冽列劣洌烈裂廉斂殮濂簾獵令伶囹寧岺嶺怜玲笭羚翎聆逞鈴零靈領齡例澧禮醴隷勞怒撈擄櫓潞瀘爐盧老蘆虜路輅露魯鷺鹵碌祿綠菉錄鹿麓論壟弄朧瀧瓏籠聾儡瀨牢磊賂賚賴雷了僚寮廖料燎療瞭聊蓼"], ["d7a1", "遼鬧龍壘婁屢樓淚漏瘻累縷蔞褸鏤陋劉旒柳榴流溜瀏琉瑠留瘤硫謬類六戮陸侖倫崙淪綸輪律慄栗率隆勒肋凜凌楞稜綾菱陵俚利厘吏唎履悧李梨浬犁狸理璃異痢籬罹羸莉裏裡里釐離鯉吝潾燐璘藺躪隣鱗麟林淋琳臨霖砬"], ["d8a1", "立笠粒摩瑪痲碼磨馬魔麻寞幕漠膜莫邈万卍娩巒彎慢挽晩曼滿漫灣瞞萬蔓蠻輓饅鰻唜抹末沫茉襪靺亡妄忘忙望網罔芒茫莽輞邙埋妹媒寐昧枚梅每煤罵買賣邁魅脈貊陌驀麥孟氓猛盲盟萌冪覓免冕勉棉沔眄眠綿緬面麵滅"], ["d9a1", "蔑冥名命明暝椧溟皿瞑茗蓂螟酩銘鳴袂侮冒募姆帽慕摸摹暮某模母毛牟牡瑁眸矛耗芼茅謀謨貌木沐牧目睦穆鶩歿沒夢朦蒙卯墓妙廟描昴杳渺猫竗苗錨務巫憮懋戊拇撫无楙武毋無珷畝繆舞茂蕪誣貿霧鵡墨默們刎吻問文"], ["daa1", "汶紊紋聞蚊門雯勿沕物味媚尾嵋彌微未梶楣渼湄眉米美薇謎迷靡黴岷悶愍憫敏旻旼民泯玟珉緡閔密蜜謐剝博拍搏撲朴樸泊珀璞箔粕縛膊舶薄迫雹駁伴半反叛拌搬攀斑槃泮潘班畔瘢盤盼磐磻礬絆般蟠返頒飯勃拔撥渤潑"], ["dba1", "發跋醱鉢髮魃倣傍坊妨尨幇彷房放方旁昉枋榜滂磅紡肪膀舫芳蒡蚌訪謗邦防龐倍俳北培徘拜排杯湃焙盃背胚裴裵褙賠輩配陪伯佰帛柏栢白百魄幡樊煩燔番磻繁蕃藩飜伐筏罰閥凡帆梵氾汎泛犯範范法琺僻劈壁擘檗璧癖"], ["dca1", "碧蘗闢霹便卞弁變辨辯邊別瞥鱉鼈丙倂兵屛幷昞昺柄棅炳甁病秉竝輧餠騈保堡報寶普步洑湺潽珤甫菩補褓譜輔伏僕匐卜宓復服福腹茯蔔複覆輹輻馥鰒本乶俸奉封峯峰捧棒烽熢琫縫蓬蜂逢鋒鳳不付俯傅剖副否咐埠夫婦"], ["dda1", "孚孵富府復扶敷斧浮溥父符簿缶腐腑膚艀芙莩訃負賦賻赴趺部釜阜附駙鳧北分吩噴墳奔奮忿憤扮昐汾焚盆粉糞紛芬賁雰不佛弗彿拂崩朋棚硼繃鵬丕備匕匪卑妃婢庇悲憊扉批斐枇榧比毖毗毘沸泌琵痺砒碑秕秘粃緋翡肥"], ["dea1", "脾臂菲蜚裨誹譬費鄙非飛鼻嚬嬪彬斌檳殯浜濱瀕牝玭貧賓頻憑氷聘騁乍事些仕伺似使俟僿史司唆嗣四士奢娑寫寺射巳師徙思捨斜斯柶査梭死沙泗渣瀉獅砂社祀祠私篩紗絲肆舍莎蓑蛇裟詐詞謝賜赦辭邪飼駟麝削數朔索"], ["dfa1", "傘刪山散汕珊産疝算蒜酸霰乷撒殺煞薩三參杉森渗芟蔘衫揷澁鈒颯上傷像償商喪嘗孀尙峠常床庠廂想桑橡湘爽牀狀相祥箱翔裳觴詳象賞霜塞璽賽嗇塞穡索色牲生甥省笙墅壻嶼序庶徐恕抒捿敍暑曙書栖棲犀瑞筮絮緖署"], ["e0a1", "胥舒薯西誓逝鋤黍鼠夕奭席惜昔晳析汐淅潟石碩蓆釋錫仙僊先善嬋宣扇敾旋渲煽琁瑄璇璿癬禪線繕羨腺膳船蘚蟬詵跣選銑鐥饍鮮卨屑楔泄洩渫舌薛褻設說雪齧剡暹殲纖蟾贍閃陝攝涉燮葉城姓宬性惺成星晟猩珹盛省筬"], ["e1a1", "聖聲腥誠醒世勢歲洗稅笹細說貰召嘯塑宵小少巢所掃搔昭梳沼消溯瀟炤燒甦疏疎瘙笑篠簫素紹蔬蕭蘇訴逍遡邵銷韶騷俗屬束涑粟續謖贖速孫巽損蓀遜飡率宋悚松淞訟誦送頌刷殺灑碎鎖衰釗修受嗽囚垂壽嫂守岫峀帥愁"], ["e2a1", "戍手授搜收數樹殊水洙漱燧狩獸琇璲瘦睡秀穗竪粹綏綬繡羞脩茱蒐蓚藪袖誰讐輸遂邃酬銖銹隋隧隨雖需須首髓鬚叔塾夙孰宿淑潚熟琡璹肅菽巡徇循恂旬栒楯橓殉洵淳珣盾瞬筍純脣舜荀蓴蕣詢諄醇錞順馴戌術述鉥崇崧"], ["e3a1", "嵩瑟膝蝨濕拾習褶襲丞乘僧勝升承昇繩蠅陞侍匙嘶始媤尸屎屍市弑恃施是時枾柴猜矢示翅蒔蓍視試詩諡豕豺埴寔式息拭植殖湜熄篒蝕識軾食飾伸侁信呻娠宸愼新晨燼申神紳腎臣莘薪藎蜃訊身辛辰迅失室實悉審尋心沁"], ["e4a1", "沈深瀋甚芯諶什十拾雙氏亞俄兒啞娥峨我牙芽莪蛾衙訝阿雅餓鴉鵝堊岳嶽幄惡愕握樂渥鄂鍔顎鰐齷安岸按晏案眼雁鞍顔鮟斡謁軋閼唵岩巖庵暗癌菴闇壓押狎鴨仰央怏昻殃秧鴦厓哀埃崖愛曖涯碍艾隘靄厄扼掖液縊腋額"], ["e5a1", "櫻罌鶯鸚也倻冶夜惹揶椰爺耶若野弱掠略約若葯蒻藥躍亮佯兩凉壤孃恙揚攘敭暘梁楊樣洋瀁煬痒瘍禳穰糧羊良襄諒讓釀陽量養圄御於漁瘀禦語馭魚齬億憶抑檍臆偃堰彦焉言諺孼蘖俺儼嚴奄掩淹嶪業円予余勵呂女如廬"], ["e6a1", "旅歟汝濾璵礖礪與艅茹輿轝閭餘驪麗黎亦力域役易曆歷疫繹譯轢逆驛嚥堧姸娟宴年延憐戀捐挻撚椽沇沿涎涓淵演漣烟然煙煉燃燕璉硏硯秊筵緣練縯聯衍軟輦蓮連鉛鍊鳶列劣咽悅涅烈熱裂說閱厭廉念捻染殮炎焰琰艶苒"], ["e7a1", "簾閻髥鹽曄獵燁葉令囹塋寧嶺嶸影怜映暎楹榮永泳渶潁濚瀛瀯煐營獰玲瑛瑩瓔盈穎纓羚聆英詠迎鈴鍈零霙靈領乂倪例刈叡曳汭濊猊睿穢芮藝蘂禮裔詣譽豫醴銳隸霓預五伍俉傲午吾吳嗚塢墺奧娛寤悟惡懊敖旿晤梧汚澳"], ["e8a1", "烏熬獒筽蜈誤鰲鼇屋沃獄玉鈺溫瑥瘟穩縕蘊兀壅擁瓮甕癰翁邕雍饔渦瓦窩窪臥蛙蝸訛婉完宛梡椀浣玩琓琬碗緩翫脘腕莞豌阮頑曰往旺枉汪王倭娃歪矮外嵬巍猥畏了僚僥凹堯夭妖姚寥寮尿嶢拗搖撓擾料曜樂橈燎燿瑤療"], ["e9a1", "窈窯繇繞耀腰蓼蟯要謠遙遼邀饒慾欲浴縟褥辱俑傭冗勇埇墉容庸慂榕涌湧溶熔瑢用甬聳茸蓉踊鎔鏞龍于佑偶優又友右宇寓尤愚憂旴牛玗瑀盂祐禑禹紆羽芋藕虞迂遇郵釪隅雨雩勖彧旭昱栯煜稶郁頊云暈橒殞澐熉耘芸蕓"], ["eaa1", "運隕雲韻蔚鬱亐熊雄元原員圓園垣媛嫄寃怨愿援沅洹湲源爰猿瑗苑袁轅遠阮院願鴛月越鉞位偉僞危圍委威尉慰暐渭爲瑋緯胃萎葦蔿蝟衛褘謂違韋魏乳侑儒兪劉唯喩孺宥幼幽庾悠惟愈愉揄攸有杻柔柚柳楡楢油洧流游溜"], ["eba1", "濡猶猷琉瑜由留癒硫紐維臾萸裕誘諛諭踰蹂遊逾遺酉釉鍮類六堉戮毓肉育陸倫允奫尹崙淪潤玧胤贇輪鈗閏律慄栗率聿戎瀜絨融隆垠恩慇殷誾銀隱乙吟淫蔭陰音飮揖泣邑凝應膺鷹依倚儀宜意懿擬椅毅疑矣義艤薏蟻衣誼"], ["eca1", "議醫二以伊利吏夷姨履已弛彛怡易李梨泥爾珥理異痍痢移罹而耳肄苡荑裏裡貽貳邇里離飴餌匿溺瀷益翊翌翼謚人仁刃印吝咽因姻寅引忍湮燐璘絪茵藺蚓認隣靭靷鱗麟一佚佾壹日溢逸鎰馹任壬妊姙恁林淋稔臨荏賃入卄"], ["eda1", "立笠粒仍剩孕芿仔刺咨姉姿子字孜恣慈滋炙煮玆瓷疵磁紫者自茨蔗藉諮資雌作勺嚼斫昨灼炸爵綽芍酌雀鵲孱棧殘潺盞岑暫潛箴簪蠶雜丈仗匠場墻壯奬將帳庄張掌暲杖樟檣欌漿牆狀獐璋章粧腸臟臧莊葬蔣薔藏裝贓醬長"], ["eea1", "障再哉在宰才材栽梓渽滓災縡裁財載齋齎爭箏諍錚佇低儲咀姐底抵杵楮樗沮渚狙猪疽箸紵苧菹著藷詛貯躇這邸雎齟勣吊嫡寂摘敵滴狄炙的積笛籍績翟荻謫賊赤跡蹟迪迹適鏑佃佺傳全典前剪塡塼奠專展廛悛戰栓殿氈澱"], ["efa1", "煎琠田甸畑癲筌箋箭篆纏詮輾轉鈿銓錢鐫電顚顫餞切截折浙癤竊節絶占岾店漸点粘霑鮎點接摺蝶丁井亭停偵呈姃定幀庭廷征情挺政整旌晶晸柾楨檉正汀淀淨渟湞瀞炡玎珽町睛碇禎程穽精綎艇訂諪貞鄭酊釘鉦鋌錠霆靖"], ["f0a1", "靜頂鼎制劑啼堤帝弟悌提梯濟祭第臍薺製諸蹄醍除際霽題齊俎兆凋助嘲弔彫措操早晁曺曹朝條棗槽漕潮照燥爪璪眺祖祚租稠窕粗糟組繰肇藻蚤詔調趙躁造遭釣阻雕鳥族簇足鏃存尊卒拙猝倧宗從悰慫棕淙琮種終綜縱腫"], ["f1a1", "踪踵鍾鐘佐坐左座挫罪主住侏做姝胄呪周嗾奏宙州廚晝朱柱株注洲湊澍炷珠疇籌紂紬綢舟蛛註誅走躊輳週酎酒鑄駐竹粥俊儁准埈寯峻晙樽浚準濬焌畯竣蠢逡遵雋駿茁中仲衆重卽櫛楫汁葺增憎曾拯烝甑症繒蒸證贈之只"], ["f2a1", "咫地址志持指摯支旨智枝枳止池沚漬知砥祉祗紙肢脂至芝芷蜘誌識贄趾遲直稙稷織職唇嗔塵振搢晉晋桭榛殄津溱珍瑨璡畛疹盡眞瞋秦縉縝臻蔯袗診賑軫辰進鎭陣陳震侄叱姪嫉帙桎瓆疾秩窒膣蛭質跌迭斟朕什執潗緝輯"], ["f3a1", "鏶集徵懲澄且侘借叉嗟嵯差次此磋箚茶蹉車遮捉搾着窄錯鑿齪撰澯燦璨瓚竄簒纂粲纘讚贊鑽餐饌刹察擦札紮僭參塹慘慙懺斬站讒讖倉倡創唱娼廠彰愴敞昌昶暢槍滄漲猖瘡窓脹艙菖蒼債埰寀寨彩採砦綵菜蔡采釵冊柵策"], ["f4a1", "責凄妻悽處倜刺剔尺慽戚拓擲斥滌瘠脊蹠陟隻仟千喘天川擅泉淺玔穿舛薦賤踐遷釧闡阡韆凸哲喆徹撤澈綴輟轍鐵僉尖沾添甛瞻簽籤詹諂堞妾帖捷牒疊睫諜貼輒廳晴淸聽菁請靑鯖切剃替涕滯締諦逮遞體初剿哨憔抄招梢"], ["f5a1", "椒楚樵炒焦硝礁礎秒稍肖艸苕草蕉貂超酢醋醮促囑燭矗蜀觸寸忖村邨叢塚寵悤憁摠總聰蔥銃撮催崔最墜抽推椎楸樞湫皺秋芻萩諏趨追鄒酋醜錐錘鎚雛騶鰍丑畜祝竺筑築縮蓄蹙蹴軸逐春椿瑃出朮黜充忠沖蟲衝衷悴膵萃"], ["f6a1", "贅取吹嘴娶就炊翠聚脆臭趣醉驟鷲側仄厠惻測層侈値嗤峙幟恥梔治淄熾痔痴癡稚穉緇緻置致蚩輜雉馳齒則勅飭親七柒漆侵寢枕沈浸琛砧針鍼蟄秤稱快他咤唾墮妥惰打拖朶楕舵陀馱駝倬卓啄坼度托拓擢晫柝濁濯琢琸託"], ["f7a1", "鐸呑嘆坦彈憚歎灘炭綻誕奪脫探眈耽貪塔搭榻宕帑湯糖蕩兌台太怠態殆汰泰笞胎苔跆邰颱宅擇澤撑攄兎吐土討慟桶洞痛筒統通堆槌腿褪退頹偸套妬投透鬪慝特闖坡婆巴把播擺杷波派爬琶破罷芭跛頗判坂板版瓣販辦鈑"], ["f8a1", "阪八叭捌佩唄悖敗沛浿牌狽稗覇貝彭澎烹膨愎便偏扁片篇編翩遍鞭騙貶坪平枰萍評吠嬖幣廢弊斃肺蔽閉陛佈包匍匏咆哺圃布怖抛抱捕暴泡浦疱砲胞脯苞葡蒲袍褒逋鋪飽鮑幅暴曝瀑爆輻俵剽彪慓杓標漂瓢票表豹飇飄驃"], ["f9a1", "品稟楓諷豊風馮彼披疲皮被避陂匹弼必泌珌畢疋筆苾馝乏逼下何厦夏廈昰河瑕荷蝦賀遐霞鰕壑學虐謔鶴寒恨悍旱汗漢澣瀚罕翰閑閒限韓割轄函含咸啣喊檻涵緘艦銜陷鹹合哈盒蛤閤闔陜亢伉姮嫦巷恒抗杭桁沆港缸肛航"], ["faa1", "行降項亥偕咳垓奚孩害懈楷海瀣蟹解該諧邂駭骸劾核倖幸杏荇行享向嚮珦鄕響餉饗香噓墟虛許憲櫶獻軒歇險驗奕爀赫革俔峴弦懸晛泫炫玄玹現眩睍絃絢縣舷衒見賢鉉顯孑穴血頁嫌俠協夾峽挾浹狹脅脇莢鋏頰亨兄刑型"], ["fba1", "形泂滎瀅灐炯熒珩瑩荊螢衡逈邢鎣馨兮彗惠慧暳蕙蹊醯鞋乎互呼壕壺好岵弧戶扈昊晧毫浩淏湖滸澔濠濩灝狐琥瑚瓠皓祜糊縞胡芦葫蒿虎號蝴護豪鎬頀顥惑或酷婚昏混渾琿魂忽惚笏哄弘汞泓洪烘紅虹訌鴻化和嬅樺火畵"], ["fca1", "禍禾花華話譁貨靴廓擴攫確碻穫丸喚奐宦幻患換歡晥桓渙煥環紈還驩鰥活滑猾豁闊凰幌徨恍惶愰慌晃晄榥況湟滉潢煌璜皇篁簧荒蝗遑隍黃匯回廻徊恢悔懷晦會檜淮澮灰獪繪膾茴蛔誨賄劃獲宖橫鐄哮嚆孝效斅曉梟涍淆"], ["fda1", "爻肴酵驍侯候厚后吼喉嗅帿後朽煦珝逅勛勳塤壎焄熏燻薰訓暈薨喧暄煊萱卉喙毁彙徽揮暉煇諱輝麾休携烋畦虧恤譎鷸兇凶匈洶胸黑昕欣炘痕吃屹紇訖欠欽歆吸恰洽翕興僖凞喜噫囍姬嬉希憙憘戱晞曦熙熹熺犧禧稀羲詰"]];
    }, {}],
    22: [function (require, module, exports) {
      module.exports = [["0", "\0", 127], ["a140", "　，、。．‧；：？！︰…‥﹐﹑﹒·﹔﹕﹖﹗｜–︱—︳╴︴﹏（）︵︶｛｝︷︸〔〕︹︺【】︻︼《》︽︾〈〉︿﹀「」﹁﹂『』﹃﹄﹙﹚"], ["a1a1", "﹛﹜﹝﹞‘’“”〝〞‵′＃＆＊※§〃○●△▲◎☆★◇◆□■▽▼㊣℅¯￣＿ˍ﹉﹊﹍﹎﹋﹌﹟﹠﹡＋－×÷±√＜＞＝≦≧≠∞≒≡﹢", 4, "～∩∪⊥∠∟⊿㏒㏑∫∮∵∴♀♂⊕⊙↑↓←→↖↗↙↘∥∣／"], ["a240", "＼∕﹨＄￥〒￠￡％＠℃℉﹩﹪﹫㏕㎜㎝㎞㏎㎡㎎㎏㏄°兙兛兞兝兡兣嗧瓩糎▁", 7, "▏▎▍▌▋▊▉┼┴┬┤├▔─│▕┌┐└┘╭"], ["a2a1", "╮╰╯═╞╪╡◢◣◥◤╱╲╳０", 9, "Ⅰ", 9, "〡", 8, "十卄卅Ａ", 25, "ａ", 21], ["a340", "ｗｘｙｚΑ", 16, "Σ", 6, "α", 16, "σ", 6, "ㄅ", 10], ["a3a1", "ㄐ", 25, "˙ˉˊˇˋ"], ["a3e1", "€"], ["a440", "一乙丁七乃九了二人儿入八几刀刁力匕十卜又三下丈上丫丸凡久么也乞于亡兀刃勺千叉口土士夕大女子孑孓寸小尢尸山川工己已巳巾干廾弋弓才"], ["a4a1", "丑丐不中丰丹之尹予云井互五亢仁什仃仆仇仍今介仄元允內六兮公冗凶分切刈勻勾勿化匹午升卅卞厄友及反壬天夫太夭孔少尤尺屯巴幻廿弔引心戈戶手扎支文斗斤方日曰月木欠止歹毋比毛氏水火爪父爻片牙牛犬王丙"], ["a540", "世丕且丘主乍乏乎以付仔仕他仗代令仙仞充兄冉冊冬凹出凸刊加功包匆北匝仟半卉卡占卯卮去可古右召叮叩叨叼司叵叫另只史叱台句叭叻四囚外"], ["a5a1", "央失奴奶孕它尼巨巧左市布平幼弁弘弗必戊打扔扒扑斥旦朮本未末札正母民氐永汁汀氾犯玄玉瓜瓦甘生用甩田由甲申疋白皮皿目矛矢石示禾穴立丞丟乒乓乩亙交亦亥仿伉伙伊伕伍伐休伏仲件任仰仳份企伋光兇兆先全"], ["a640", "共再冰列刑划刎刖劣匈匡匠印危吉吏同吊吐吁吋各向名合吃后吆吒因回囝圳地在圭圬圯圩夙多夷夸妄奸妃好她如妁字存宇守宅安寺尖屹州帆并年"], ["a6a1", "式弛忙忖戎戌戍成扣扛托收早旨旬旭曲曳有朽朴朱朵次此死氖汝汗汙江池汐汕污汛汍汎灰牟牝百竹米糸缶羊羽老考而耒耳聿肉肋肌臣自至臼舌舛舟艮色艾虫血行衣西阡串亨位住佇佗佞伴佛何估佐佑伽伺伸佃佔似但佣"], ["a740", "作你伯低伶余佝佈佚兌克免兵冶冷別判利刪刨劫助努劬匣即卵吝吭吞吾否呎吧呆呃吳呈呂君吩告吹吻吸吮吵吶吠吼呀吱含吟听囪困囤囫坊坑址坍"], ["a7a1", "均坎圾坐坏圻壯夾妝妒妨妞妣妙妖妍妤妓妊妥孝孜孚孛完宋宏尬局屁尿尾岐岑岔岌巫希序庇床廷弄弟彤形彷役忘忌志忍忱快忸忪戒我抄抗抖技扶抉扭把扼找批扳抒扯折扮投抓抑抆改攻攸旱更束李杏材村杜杖杞杉杆杠"], ["a840", "杓杗步每求汞沙沁沈沉沅沛汪決沐汰沌汨沖沒汽沃汲汾汴沆汶沍沔沘沂灶灼災灸牢牡牠狄狂玖甬甫男甸皂盯矣私秀禿究系罕肖肓肝肘肛肚育良芒"], ["a8a1", "芋芍見角言谷豆豕貝赤走足身車辛辰迂迆迅迄巡邑邢邪邦那酉釆里防阮阱阪阬並乖乳事些亞享京佯依侍佳使佬供例來侃佰併侈佩佻侖佾侏侑佺兔兒兕兩具其典冽函刻券刷刺到刮制剁劾劻卒協卓卑卦卷卸卹取叔受味呵"], ["a940", "咖呸咕咀呻呷咄咒咆呼咐呱呶和咚呢周咋命咎固垃坷坪坩坡坦坤坼夜奉奇奈奄奔妾妻委妹妮姑姆姐姍始姓姊妯妳姒姅孟孤季宗定官宜宙宛尚屈居"], ["a9a1", "屆岷岡岸岩岫岱岳帘帚帖帕帛帑幸庚店府底庖延弦弧弩往征彿彼忝忠忽念忿怏怔怯怵怖怪怕怡性怩怫怛或戕房戾所承拉拌拄抿拂抹拒招披拓拔拋拈抨抽押拐拙拇拍抵拚抱拘拖拗拆抬拎放斧於旺昔易昌昆昂明昀昏昕昊"], ["aa40", "昇服朋杭枋枕東果杳杷枇枝林杯杰板枉松析杵枚枓杼杪杲欣武歧歿氓氛泣注泳沱泌泥河沽沾沼波沫法泓沸泄油況沮泗泅泱沿治泡泛泊沬泯泜泖泠"], ["aaa1", "炕炎炒炊炙爬爭爸版牧物狀狎狙狗狐玩玨玟玫玥甽疝疙疚的盂盲直知矽社祀祁秉秈空穹竺糾罔羌羋者肺肥肢肱股肫肩肴肪肯臥臾舍芳芝芙芭芽芟芹花芬芥芯芸芣芰芾芷虎虱初表軋迎返近邵邸邱邶采金長門阜陀阿阻附"], ["ab40", "陂隹雨青非亟亭亮信侵侯便俠俑俏保促侶俘俟俊俗侮俐俄係俚俎俞侷兗冒冑冠剎剃削前剌剋則勇勉勃勁匍南卻厚叛咬哀咨哎哉咸咦咳哇哂咽咪品"], ["aba1", "哄哈咯咫咱咻咩咧咿囿垂型垠垣垢城垮垓奕契奏奎奐姜姘姿姣姨娃姥姪姚姦威姻孩宣宦室客宥封屎屏屍屋峙峒巷帝帥帟幽庠度建弈弭彥很待徊律徇後徉怒思怠急怎怨恍恰恨恢恆恃恬恫恪恤扁拜挖按拼拭持拮拽指拱拷"], ["ac40", "拯括拾拴挑挂政故斫施既春昭映昧是星昨昱昤曷柿染柱柔某柬架枯柵柩柯柄柑枴柚查枸柏柞柳枰柙柢柝柒歪殃殆段毒毗氟泉洋洲洪流津洌洱洞洗"], ["aca1", "活洽派洶洛泵洹洧洸洩洮洵洎洫炫為炳炬炯炭炸炮炤爰牲牯牴狩狠狡玷珊玻玲珍珀玳甚甭畏界畎畋疫疤疥疢疣癸皆皇皈盈盆盃盅省盹相眉看盾盼眇矜砂研砌砍祆祉祈祇禹禺科秒秋穿突竿竽籽紂紅紀紉紇約紆缸美羿耄"], ["ad40", "耐耍耑耶胖胥胚胃胄背胡胛胎胞胤胝致舢苧范茅苣苛苦茄若茂茉苒苗英茁苜苔苑苞苓苟苯茆虐虹虻虺衍衫要觔計訂訃貞負赴赳趴軍軌述迦迢迪迥"], ["ada1", "迭迫迤迨郊郎郁郃酋酊重閂限陋陌降面革韋韭音頁風飛食首香乘亳倌倍倣俯倦倥俸倩倖倆值借倚倒們俺倀倔倨俱倡個候倘俳修倭倪俾倫倉兼冤冥冢凍凌准凋剖剜剔剛剝匪卿原厝叟哨唐唁唷哼哥哲唆哺唔哩哭員唉哮哪"], ["ae40", "哦唧唇哽唏圃圄埂埔埋埃堉夏套奘奚娑娘娜娟娛娓姬娠娣娩娥娌娉孫屘宰害家宴宮宵容宸射屑展屐峭峽峻峪峨峰島崁峴差席師庫庭座弱徒徑徐恙"], ["aea1", "恣恥恐恕恭恩息悄悟悚悍悔悌悅悖扇拳挈拿捎挾振捕捂捆捏捉挺捐挽挪挫挨捍捌效敉料旁旅時晉晏晃晒晌晅晁書朔朕朗校核案框桓根桂桔栩梳栗桌桑栽柴桐桀格桃株桅栓栘桁殊殉殷氣氧氨氦氤泰浪涕消涇浦浸海浙涓"], ["af40", "浬涉浮浚浴浩涌涊浹涅浥涔烊烘烤烙烈烏爹特狼狹狽狸狷玆班琉珮珠珪珞畔畝畜畚留疾病症疲疳疽疼疹痂疸皋皰益盍盎眩真眠眨矩砰砧砸砝破砷"], ["afa1", "砥砭砠砟砲祕祐祠祟祖神祝祗祚秤秣秧租秦秩秘窄窈站笆笑粉紡紗紋紊素索純紐紕級紜納紙紛缺罟羔翅翁耆耘耕耙耗耽耿胱脂胰脅胭胴脆胸胳脈能脊胼胯臭臬舀舐航舫舨般芻茫荒荔荊茸荐草茵茴荏茲茹茶茗荀茱茨荃"], ["b040", "虔蚊蚪蚓蚤蚩蚌蚣蚜衰衷袁袂衽衹記訐討訌訕訊託訓訖訏訑豈豺豹財貢起躬軒軔軏辱送逆迷退迺迴逃追逅迸邕郡郝郢酒配酌釘針釗釜釙閃院陣陡"], ["b0a1", "陛陝除陘陞隻飢馬骨高鬥鬲鬼乾偺偽停假偃偌做偉健偶偎偕偵側偷偏倏偯偭兜冕凰剪副勒務勘動匐匏匙匿區匾參曼商啪啦啄啞啡啃啊唱啖問啕唯啤唸售啜唬啣唳啁啗圈國圉域堅堊堆埠埤基堂堵執培夠奢娶婁婉婦婪婀"], ["b140", "娼婢婚婆婊孰寇寅寄寂宿密尉專將屠屜屝崇崆崎崛崖崢崑崩崔崙崤崧崗巢常帶帳帷康庸庶庵庾張強彗彬彩彫得徙從徘御徠徜恿患悉悠您惋悴惦悽"], ["b1a1", "情悻悵惜悼惘惕惆惟悸惚惇戚戛扈掠控捲掖探接捷捧掘措捱掩掉掃掛捫推掄授掙採掬排掏掀捻捩捨捺敝敖救教敗啟敏敘敕敔斜斛斬族旋旌旎晝晚晤晨晦晞曹勗望梁梯梢梓梵桿桶梱梧梗械梃棄梭梆梅梔條梨梟梡梂欲殺"], ["b240", "毫毬氫涎涼淳淙液淡淌淤添淺清淇淋涯淑涮淞淹涸混淵淅淒渚涵淚淫淘淪深淮淨淆淄涪淬涿淦烹焉焊烽烯爽牽犁猜猛猖猓猙率琅琊球理現琍瓠瓶"], ["b2a1", "瓷甜產略畦畢異疏痔痕疵痊痍皎盔盒盛眷眾眼眶眸眺硫硃硎祥票祭移窒窕笠笨笛第符笙笞笮粒粗粕絆絃統紮紹紼絀細紳組累終紲紱缽羞羚翌翎習耜聊聆脯脖脣脫脩脰脤舂舵舷舶船莎莞莘荸莢莖莽莫莒莊莓莉莠荷荻荼"], ["b340", "莆莧處彪蛇蛀蚶蛄蚵蛆蛋蚱蚯蛉術袞袈被袒袖袍袋覓規訪訝訣訥許設訟訛訢豉豚販責貫貨貪貧赧赦趾趺軛軟這逍通逗連速逝逐逕逞造透逢逖逛途"], ["b3a1", "部郭都酗野釵釦釣釧釭釩閉陪陵陳陸陰陴陶陷陬雀雪雩章竟頂頃魚鳥鹵鹿麥麻傢傍傅備傑傀傖傘傚最凱割剴創剩勞勝勛博厥啻喀喧啼喊喝喘喂喜喪喔喇喋喃喳單喟唾喲喚喻喬喱啾喉喫喙圍堯堪場堤堰報堡堝堠壹壺奠"], ["b440", "婷媚婿媒媛媧孳孱寒富寓寐尊尋就嵌嵐崴嵇巽幅帽幀幃幾廊廁廂廄弼彭復循徨惑惡悲悶惠愜愣惺愕惰惻惴慨惱愎惶愉愀愒戟扉掣掌描揀揩揉揆揍"], ["b4a1", "插揣提握揖揭揮捶援揪換摒揚揹敞敦敢散斑斐斯普晰晴晶景暑智晾晷曾替期朝棺棕棠棘棗椅棟棵森棧棹棒棲棣棋棍植椒椎棉棚楮棻款欺欽殘殖殼毯氮氯氬港游湔渡渲湧湊渠渥渣減湛湘渤湖湮渭渦湯渴湍渺測湃渝渾滋"], ["b540", "溉渙湎湣湄湲湩湟焙焚焦焰無然煮焜牌犄犀猶猥猴猩琺琪琳琢琥琵琶琴琯琛琦琨甥甦畫番痢痛痣痙痘痞痠登發皖皓皴盜睏短硝硬硯稍稈程稅稀窘"], ["b5a1", "窗窖童竣等策筆筐筒答筍筋筏筑粟粥絞結絨絕紫絮絲絡給絢絰絳善翔翕耋聒肅腕腔腋腑腎脹腆脾腌腓腴舒舜菩萃菸萍菠菅萋菁華菱菴著萊菰萌菌菽菲菊萸萎萄菜萇菔菟虛蛟蛙蛭蛔蛛蛤蛐蛞街裁裂袱覃視註詠評詞証詁"], ["b640", "詔詛詐詆訴診訶詖象貂貯貼貳貽賁費賀貴買貶貿貸越超趁跎距跋跚跑跌跛跆軻軸軼辜逮逵週逸進逶鄂郵鄉郾酣酥量鈔鈕鈣鈉鈞鈍鈐鈇鈑閔閏開閑"], ["b6a1", "間閒閎隊階隋陽隅隆隍陲隄雁雅雄集雇雯雲韌項順須飧飪飯飩飲飭馮馭黃黍黑亂傭債傲傳僅傾催傷傻傯僇剿剷剽募勦勤勢勣匯嗟嗨嗓嗦嗎嗜嗇嗑嗣嗤嗯嗚嗡嗅嗆嗥嗉園圓塞塑塘塗塚塔填塌塭塊塢塒塋奧嫁嫉嫌媾媽媼"], ["b740", "媳嫂媲嵩嵯幌幹廉廈弒彙徬微愚意慈感想愛惹愁愈慎慌慄慍愾愴愧愍愆愷戡戢搓搾搞搪搭搽搬搏搜搔損搶搖搗搆敬斟新暗暉暇暈暖暄暘暍會榔業"], ["b7a1", "楚楷楠楔極椰概楊楨楫楞楓楹榆楝楣楛歇歲毀殿毓毽溢溯滓溶滂源溝滇滅溥溘溼溺溫滑準溜滄滔溪溧溴煎煙煩煤煉照煜煬煦煌煥煞煆煨煖爺牒猷獅猿猾瑯瑚瑕瑟瑞瑁琿瑙瑛瑜當畸瘀痰瘁痲痱痺痿痴痳盞盟睛睫睦睞督"], ["b840", "睹睪睬睜睥睨睢矮碎碰碗碘碌碉硼碑碓硿祺祿禁萬禽稜稚稠稔稟稞窟窠筷節筠筮筧粱粳粵經絹綑綁綏絛置罩罪署義羨群聖聘肆肄腱腰腸腥腮腳腫"], ["b8a1", "腹腺腦舅艇蒂葷落萱葵葦葫葉葬葛萼萵葡董葩葭葆虞虜號蛹蜓蜈蜇蜀蛾蛻蜂蜃蜆蜊衙裟裔裙補裘裝裡裊裕裒覜解詫該詳試詩詰誇詼詣誠話誅詭詢詮詬詹詻訾詨豢貊貉賊資賈賄貲賃賂賅跡跟跨路跳跺跪跤跦躲較載軾輊"], ["b940", "辟農運遊道遂達逼違遐遇遏過遍遑逾遁鄒鄗酬酪酩釉鈷鉗鈸鈽鉀鈾鉛鉋鉤鉑鈴鉉鉍鉅鈹鈿鉚閘隘隔隕雍雋雉雊雷電雹零靖靴靶預頑頓頊頒頌飼飴"], ["b9a1", "飽飾馳馱馴髡鳩麂鼎鼓鼠僧僮僥僖僭僚僕像僑僱僎僩兢凳劃劂匱厭嗾嘀嘛嘗嗽嘔嘆嘉嘍嘎嗷嘖嘟嘈嘐嗶團圖塵塾境墓墊塹墅塽壽夥夢夤奪奩嫡嫦嫩嫗嫖嫘嫣孵寞寧寡寥實寨寢寤察對屢嶄嶇幛幣幕幗幔廓廖弊彆彰徹慇"], ["ba40", "愿態慷慢慣慟慚慘慵截撇摘摔撤摸摟摺摑摧搴摭摻敲斡旗旖暢暨暝榜榨榕槁榮槓構榛榷榻榫榴槐槍榭槌榦槃榣歉歌氳漳演滾漓滴漩漾漠漬漏漂漢"], ["baa1", "滿滯漆漱漸漲漣漕漫漯澈漪滬漁滲滌滷熔熙煽熊熄熒爾犒犖獄獐瑤瑣瑪瑰瑭甄疑瘧瘍瘋瘉瘓盡監瞄睽睿睡磁碟碧碳碩碣禎福禍種稱窪窩竭端管箕箋筵算箝箔箏箸箇箄粹粽精綻綰綜綽綾綠緊綴網綱綺綢綿綵綸維緒緇綬"], ["bb40", "罰翠翡翟聞聚肇腐膀膏膈膊腿膂臧臺與舔舞艋蓉蒿蓆蓄蒙蒞蒲蒜蓋蒸蓀蓓蒐蒼蓑蓊蜿蜜蜻蜢蜥蜴蜘蝕蜷蜩裳褂裴裹裸製裨褚裯誦誌語誣認誡誓誤"], ["bba1", "說誥誨誘誑誚誧豪貍貌賓賑賒赫趙趕跼輔輒輕輓辣遠遘遜遣遙遞遢遝遛鄙鄘鄞酵酸酷酴鉸銀銅銘銖鉻銓銜銨鉼銑閡閨閩閣閥閤隙障際雌雒需靼鞅韶頗領颯颱餃餅餌餉駁骯骰髦魁魂鳴鳶鳳麼鼻齊億儀僻僵價儂儈儉儅凜"], ["bc40", "劇劈劉劍劊勰厲嘮嘻嘹嘲嘿嘴嘩噓噎噗噴嘶嘯嘰墀墟增墳墜墮墩墦奭嬉嫻嬋嫵嬌嬈寮寬審寫層履嶝嶔幢幟幡廢廚廟廝廣廠彈影德徵慶慧慮慝慕憂"], ["bca1", "慼慰慫慾憧憐憫憎憬憚憤憔憮戮摩摯摹撞撲撈撐撰撥撓撕撩撒撮播撫撚撬撙撢撳敵敷數暮暫暴暱樣樟槨樁樞標槽模樓樊槳樂樅槭樑歐歎殤毅毆漿潼澄潑潦潔澆潭潛潸潮澎潺潰潤澗潘滕潯潠潟熟熬熱熨牖犛獎獗瑩璋璃"], ["bd40", "瑾璀畿瘠瘩瘟瘤瘦瘡瘢皚皺盤瞎瞇瞌瞑瞋磋磅確磊碾磕碼磐稿稼穀稽稷稻窯窮箭箱範箴篆篇篁箠篌糊締練緯緻緘緬緝編緣線緞緩綞緙緲緹罵罷羯"], ["bda1", "翩耦膛膜膝膠膚膘蔗蔽蔚蓮蔬蔭蔓蔑蔣蔡蔔蓬蔥蓿蔆螂蝴蝶蝠蝦蝸蝨蝙蝗蝌蝓衛衝褐複褒褓褕褊誼諒談諄誕請諸課諉諂調誰論諍誶誹諛豌豎豬賠賞賦賤賬賭賢賣賜質賡赭趟趣踫踐踝踢踏踩踟踡踞躺輝輛輟輩輦輪輜輞"], ["be40", "輥適遮遨遭遷鄰鄭鄧鄱醇醉醋醃鋅銻銷鋪銬鋤鋁銳銼鋒鋇鋰銲閭閱霄霆震霉靠鞍鞋鞏頡頫頜颳養餓餒餘駝駐駟駛駑駕駒駙骷髮髯鬧魅魄魷魯鴆鴉"], ["bea1", "鴃麩麾黎墨齒儒儘儔儐儕冀冪凝劑劓勳噙噫噹噩噤噸噪器噥噱噯噬噢噶壁墾壇壅奮嬝嬴學寰導彊憲憑憩憊懍憶憾懊懈戰擅擁擋撻撼據擄擇擂操撿擒擔撾整曆曉暹曄曇暸樽樸樺橙橫橘樹橄橢橡橋橇樵機橈歙歷氅濂澱澡"], ["bf40", "濃澤濁澧澳激澹澶澦澠澴熾燉燐燒燈燕熹燎燙燜燃燄獨璜璣璘璟璞瓢甌甍瘴瘸瘺盧盥瞠瞞瞟瞥磨磚磬磧禦積穎穆穌穋窺篙簑築篤篛篡篩篦糕糖縊"], ["bfa1", "縑縈縛縣縞縝縉縐罹羲翰翱翮耨膳膩膨臻興艘艙蕊蕙蕈蕨蕩蕃蕉蕭蕪蕞螃螟螞螢融衡褪褲褥褫褡親覦諦諺諫諱謀諜諧諮諾謁謂諷諭諳諶諼豫豭貓賴蹄踱踴蹂踹踵輻輯輸輳辨辦遵遴選遲遼遺鄴醒錠錶鋸錳錯錢鋼錫錄錚"], ["c040", "錐錦錡錕錮錙閻隧隨險雕霎霑霖霍霓霏靛靜靦鞘頰頸頻頷頭頹頤餐館餞餛餡餚駭駢駱骸骼髻髭鬨鮑鴕鴣鴦鴨鴒鴛默黔龍龜優償儡儲勵嚎嚀嚐嚅嚇"], ["c0a1", "嚏壕壓壑壎嬰嬪嬤孺尷屨嶼嶺嶽嶸幫彌徽應懂懇懦懋戲戴擎擊擘擠擰擦擬擱擢擭斂斃曙曖檀檔檄檢檜櫛檣橾檗檐檠歜殮毚氈濘濱濟濠濛濤濫濯澀濬濡濩濕濮濰燧營燮燦燥燭燬燴燠爵牆獰獲璩環璦璨癆療癌盪瞳瞪瞰瞬"], ["c140", "瞧瞭矯磷磺磴磯礁禧禪穗窿簇簍篾篷簌篠糠糜糞糢糟糙糝縮績繆縷縲繃縫總縱繅繁縴縹繈縵縿縯罄翳翼聱聲聰聯聳臆臃膺臂臀膿膽臉膾臨舉艱薪"], ["c1a1", "薄蕾薜薑薔薯薛薇薨薊虧蟀蟑螳蟒蟆螫螻螺蟈蟋褻褶襄褸褽覬謎謗謙講謊謠謝謄謐豁谿豳賺賽購賸賻趨蹉蹋蹈蹊轄輾轂轅輿避遽還邁邂邀鄹醣醞醜鍍鎂錨鍵鍊鍥鍋錘鍾鍬鍛鍰鍚鍔闊闋闌闈闆隱隸雖霜霞鞠韓顆颶餵騁"], ["c240", "駿鮮鮫鮪鮭鴻鴿麋黏點黜黝黛鼾齋叢嚕嚮壙壘嬸彝懣戳擴擲擾攆擺擻擷斷曜朦檳檬櫃檻檸櫂檮檯歟歸殯瀉瀋濾瀆濺瀑瀏燻燼燾燸獷獵璧璿甕癖癘"], ["c2a1", "癒瞽瞿瞻瞼礎禮穡穢穠竄竅簫簧簪簞簣簡糧織繕繞繚繡繒繙罈翹翻職聶臍臏舊藏薩藍藐藉薰薺薹薦蟯蟬蟲蟠覆覲觴謨謹謬謫豐贅蹙蹣蹦蹤蹟蹕軀轉轍邇邃邈醫醬釐鎔鎊鎖鎢鎳鎮鎬鎰鎘鎚鎗闔闖闐闕離雜雙雛雞霤鞣鞦"], ["c340", "鞭韹額顏題顎顓颺餾餿餽餮馥騎髁鬃鬆魏魎魍鯊鯉鯽鯈鯀鵑鵝鵠黠鼕鼬儳嚥壞壟壢寵龐廬懲懷懶懵攀攏曠曝櫥櫝櫚櫓瀛瀟瀨瀚瀝瀕瀘爆爍牘犢獸"], ["c3a1", "獺璽瓊瓣疇疆癟癡矇礙禱穫穩簾簿簸簽簷籀繫繭繹繩繪羅繳羶羹羸臘藩藝藪藕藤藥藷蟻蠅蠍蟹蟾襠襟襖襞譁譜識證譚譎譏譆譙贈贊蹼蹲躇蹶蹬蹺蹴轔轎辭邊邋醱醮鏡鏑鏟鏃鏈鏜鏝鏖鏢鏍鏘鏤鏗鏨關隴難霪霧靡韜韻類"], ["c440", "願顛颼饅饉騖騙鬍鯨鯧鯖鯛鶉鵡鵲鵪鵬麒麗麓麴勸嚨嚷嚶嚴嚼壤孀孃孽寶巉懸懺攘攔攙曦朧櫬瀾瀰瀲爐獻瓏癢癥礦礪礬礫竇競籌籃籍糯糰辮繽繼"], ["c4a1", "纂罌耀臚艦藻藹蘑藺蘆蘋蘇蘊蠔蠕襤覺觸議譬警譯譟譫贏贍躉躁躅躂醴釋鐘鐃鏽闡霰飄饒饑馨騫騰騷騵鰓鰍鹹麵黨鼯齟齣齡儷儸囁囀囂夔屬巍懼懾攝攜斕曩櫻欄櫺殲灌爛犧瓖瓔癩矓籐纏續羼蘗蘭蘚蠣蠢蠡蠟襪襬覽譴"], ["c540", "護譽贓躊躍躋轟辯醺鐮鐳鐵鐺鐸鐲鐫闢霸霹露響顧顥饗驅驃驀騾髏魔魑鰭鰥鶯鶴鷂鶸麝黯鼙齜齦齧儼儻囈囊囉孿巔巒彎懿攤權歡灑灘玀瓤疊癮癬"], ["c5a1", "禳籠籟聾聽臟襲襯觼讀贖贗躑躓轡酈鑄鑑鑒霽霾韃韁顫饕驕驍髒鬚鱉鰱鰾鰻鷓鷗鼴齬齪龔囌巖戀攣攫攪曬欐瓚竊籤籣籥纓纖纔臢蘸蘿蠱變邐邏鑣鑠鑤靨顯饜驚驛驗髓體髑鱔鱗鱖鷥麟黴囑壩攬灞癱癲矗罐羈蠶蠹衢讓讒"], ["c640", "讖艷贛釀鑪靂靈靄韆顰驟鬢魘鱟鷹鷺鹼鹽鼇齷齲廳欖灣籬籮蠻觀躡釁鑲鑰顱饞髖鬣黌灤矚讚鑷韉驢驥纜讜躪釅鑽鑾鑼鱷鱸黷豔鑿鸚爨驪鬱鸛鸞籲"], ["c940", "乂乜凵匚厂万丌乇亍囗兀屮彳丏冇与丮亓仂仉仈冘勼卬厹圠夃夬尐巿旡殳毌气爿丱丼仨仜仩仡仝仚刌匜卌圢圣夗夯宁宄尒尻屴屳帄庀庂忉戉扐氕"], ["c9a1", "氶汃氿氻犮犰玊禸肊阞伎优伬仵伔仱伀价伈伝伂伅伢伓伄仴伒冱刓刉刐劦匢匟卍厊吇囡囟圮圪圴夼妀奼妅奻奾奷奿孖尕尥屼屺屻屾巟幵庄异弚彴忕忔忏扜扞扤扡扦扢扙扠扚扥旯旮朾朹朸朻机朿朼朳氘汆汒汜汏汊汔汋"], ["ca40", "汌灱牞犴犵玎甪癿穵网艸艼芀艽艿虍襾邙邗邘邛邔阢阤阠阣佖伻佢佉体佤伾佧佒佟佁佘伭伳伿佡冏冹刜刞刡劭劮匉卣卲厎厏吰吷吪呔呅吙吜吥吘"], ["caa1", "吽呏呁吨吤呇囮囧囥坁坅坌坉坋坒夆奀妦妘妠妗妎妢妐妏妧妡宎宒尨尪岍岏岈岋岉岒岊岆岓岕巠帊帎庋庉庌庈庍弅弝彸彶忒忑忐忭忨忮忳忡忤忣忺忯忷忻怀忴戺抃抌抎抏抔抇扱扻扺扰抁抈扷扽扲扴攷旰旴旳旲旵杅杇"], ["cb40", "杙杕杌杈杝杍杚杋毐氙氚汸汧汫沄沋沏汱汯汩沚汭沇沕沜汦汳汥汻沎灴灺牣犿犽狃狆狁犺狅玕玗玓玔玒町甹疔疕皁礽耴肕肙肐肒肜芐芏芅芎芑芓"], ["cba1", "芊芃芄豸迉辿邟邡邥邞邧邠阰阨阯阭丳侘佼侅佽侀侇佶佴侉侄佷佌侗佪侚佹侁佸侐侜侔侞侒侂侕佫佮冞冼冾刵刲刳剆刱劼匊匋匼厒厔咇呿咁咑咂咈呫呺呾呥呬呴呦咍呯呡呠咘呣呧呤囷囹坯坲坭坫坱坰坶垀坵坻坳坴坢"], ["cc40", "坨坽夌奅妵妺姏姎妲姌姁妶妼姃姖妱妽姀姈妴姇孢孥宓宕屄屇岮岤岠岵岯岨岬岟岣岭岢岪岧岝岥岶岰岦帗帔帙弨弢弣弤彔徂彾彽忞忥怭怦怙怲怋"], ["cca1", "怴怊怗怳怚怞怬怢怍怐怮怓怑怌怉怜戔戽抭抴拑抾抪抶拊抮抳抯抻抩抰抸攽斨斻昉旼昄昒昈旻昃昋昍昅旽昑昐曶朊枅杬枎枒杶杻枘枆构杴枍枌杺枟枑枙枃杽极杸杹枔欥殀歾毞氝沓泬泫泮泙沶泔沭泧沷泐泂沺泃泆泭泲"], ["cd40", "泒泝沴沊沝沀泞泀洰泍泇沰泹泏泩泑炔炘炅炓炆炄炑炖炂炚炃牪狖狋狘狉狜狒狔狚狌狑玤玡玭玦玢玠玬玝瓝瓨甿畀甾疌疘皯盳盱盰盵矸矼矹矻矺"], ["cda1", "矷祂礿秅穸穻竻籵糽耵肏肮肣肸肵肭舠芠苀芫芚芘芛芵芧芮芼芞芺芴芨芡芩苂芤苃芶芢虰虯虭虮豖迒迋迓迍迖迕迗邲邴邯邳邰阹阽阼阺陃俍俅俓侲俉俋俁俔俜俙侻侳俛俇俖侺俀侹俬剄剉勀勂匽卼厗厖厙厘咺咡咭咥哏"], ["ce40", "哃茍咷咮哖咶哅哆咠呰咼咢咾呲哞咰垵垞垟垤垌垗垝垛垔垘垏垙垥垚垕壴复奓姡姞姮娀姱姝姺姽姼姶姤姲姷姛姩姳姵姠姾姴姭宨屌峐峘峌峗峋峛"], ["cea1", "峞峚峉峇峊峖峓峔峏峈峆峎峟峸巹帡帢帣帠帤庰庤庢庛庣庥弇弮彖徆怷怹恔恲恞恅恓恇恉恛恌恀恂恟怤恄恘恦恮扂扃拏挍挋拵挎挃拫拹挏挌拸拶挀挓挔拺挕拻拰敁敃斪斿昶昡昲昵昜昦昢昳昫昺昝昴昹昮朏朐柁柲柈枺"], ["cf40", "柜枻柸柘柀枷柅柫柤柟枵柍枳柷柶柮柣柂枹柎柧柰枲柼柆柭柌枮柦柛柺柉柊柃柪柋欨殂殄殶毖毘毠氠氡洨洴洭洟洼洿洒洊泚洳洄洙洺洚洑洀洝浂"], ["cfa1", "洁洘洷洃洏浀洇洠洬洈洢洉洐炷炟炾炱炰炡炴炵炩牁牉牊牬牰牳牮狊狤狨狫狟狪狦狣玅珌珂珈珅玹玶玵玴珫玿珇玾珃珆玸珋瓬瓮甮畇畈疧疪癹盄眈眃眄眅眊盷盻盺矧矨砆砑砒砅砐砏砎砉砃砓祊祌祋祅祄秕种秏秖秎窀"], ["d040", "穾竑笀笁籺籸籹籿粀粁紃紈紁罘羑羍羾耇耎耏耔耷胘胇胠胑胈胂胐胅胣胙胜胊胕胉胏胗胦胍臿舡芔苙苾苹茇苨茀苕茺苫苖苴苬苡苲苵茌苻苶苰苪"], ["d0a1", "苤苠苺苳苭虷虴虼虳衁衎衧衪衩觓訄訇赲迣迡迮迠郱邽邿郕郅邾郇郋郈釔釓陔陏陑陓陊陎倞倅倇倓倢倰倛俵俴倳倷倬俶俷倗倜倠倧倵倯倱倎党冔冓凊凄凅凈凎剡剚剒剞剟剕剢勍匎厞唦哢唗唒哧哳哤唚哿唄唈哫唑唅哱"], ["d140", "唊哻哷哸哠唎唃唋圁圂埌堲埕埒垺埆垽垼垸垶垿埇埐垹埁夎奊娙娖娭娮娕娏娗娊娞娳孬宧宭宬尃屖屔峬峿峮峱峷崀峹帩帨庨庮庪庬弳弰彧恝恚恧"], ["d1a1", "恁悢悈悀悒悁悝悃悕悛悗悇悜悎戙扆拲挐捖挬捄捅挶捃揤挹捋捊挼挩捁挴捘捔捙挭捇挳捚捑挸捗捀捈敊敆旆旃旄旂晊晟晇晑朒朓栟栚桉栲栳栻桋桏栖栱栜栵栫栭栯桎桄栴栝栒栔栦栨栮桍栺栥栠欬欯欭欱欴歭肂殈毦毤"], ["d240", "毨毣毢毧氥浺浣浤浶洍浡涒浘浢浭浯涑涍淯浿涆浞浧浠涗浰浼浟涂涘洯浨涋浾涀涄洖涃浻浽浵涐烜烓烑烝烋缹烢烗烒烞烠烔烍烅烆烇烚烎烡牂牸"], ["d2a1", "牷牶猀狺狴狾狶狳狻猁珓珙珥珖玼珧珣珩珜珒珛珔珝珚珗珘珨瓞瓟瓴瓵甡畛畟疰痁疻痄痀疿疶疺皊盉眝眛眐眓眒眣眑眕眙眚眢眧砣砬砢砵砯砨砮砫砡砩砳砪砱祔祛祏祜祓祒祑秫秬秠秮秭秪秜秞秝窆窉窅窋窌窊窇竘笐"], ["d340", "笄笓笅笏笈笊笎笉笒粄粑粊粌粈粍粅紞紝紑紎紘紖紓紟紒紏紌罜罡罞罠罝罛羖羒翃翂翀耖耾耹胺胲胹胵脁胻脀舁舯舥茳茭荄茙荑茥荖茿荁茦茜茢"], ["d3a1", "荂荎茛茪茈茼荍茖茤茠茷茯茩荇荅荌荓茞茬荋茧荈虓虒蚢蚨蚖蚍蚑蚞蚇蚗蚆蚋蚚蚅蚥蚙蚡蚧蚕蚘蚎蚝蚐蚔衃衄衭衵衶衲袀衱衿衯袃衾衴衼訒豇豗豻貤貣赶赸趵趷趶軑軓迾迵适迿迻逄迼迶郖郠郙郚郣郟郥郘郛郗郜郤酐"], ["d440", "酎酏釕釢釚陜陟隼飣髟鬯乿偰偪偡偞偠偓偋偝偲偈偍偁偛偊偢倕偅偟偩偫偣偤偆偀偮偳偗偑凐剫剭剬剮勖勓匭厜啵啶唼啍啐唴唪啑啢唶唵唰啒啅"], ["d4a1", "唌唲啥啎唹啈唭唻啀啋圊圇埻堔埢埶埜埴堀埭埽堈埸堋埳埏堇埮埣埲埥埬埡堎埼堐埧堁堌埱埩埰堍堄奜婠婘婕婧婞娸娵婭婐婟婥婬婓婤婗婃婝婒婄婛婈媎娾婍娹婌婰婩婇婑婖婂婜孲孮寁寀屙崞崋崝崚崠崌崨崍崦崥崏"], ["d540", "崰崒崣崟崮帾帴庱庴庹庲庳弶弸徛徖徟悊悐悆悾悰悺惓惔惏惤惙惝惈悱惛悷惊悿惃惍惀挲捥掊掂捽掽掞掭掝掗掫掎捯掇掐据掯捵掜捭掮捼掤挻掟"], ["d5a1", "捸掅掁掑掍捰敓旍晥晡晛晙晜晢朘桹梇梐梜桭桮梮梫楖桯梣梬梩桵桴梲梏桷梒桼桫桲梪梀桱桾梛梖梋梠梉梤桸桻梑梌梊桽欶欳欷欸殑殏殍殎殌氪淀涫涴涳湴涬淩淢涷淶淔渀淈淠淟淖涾淥淜淝淛淴淊涽淭淰涺淕淂淏淉"], ["d640", "淐淲淓淽淗淍淣涻烺焍烷焗烴焌烰焄烳焐烼烿焆焓焀烸烶焋焂焎牾牻牼牿猝猗猇猑猘猊猈狿猏猞玈珶珸珵琄琁珽琇琀珺珼珿琌琋珴琈畤畣痎痒痏"], ["d6a1", "痋痌痑痐皏皉盓眹眯眭眱眲眴眳眽眥眻眵硈硒硉硍硊硌砦硅硐祤祧祩祪祣祫祡离秺秸秶秷窏窔窐笵筇笴笥笰笢笤笳笘笪笝笱笫笭笯笲笸笚笣粔粘粖粣紵紽紸紶紺絅紬紩絁絇紾紿絊紻紨罣羕羜羝羛翊翋翍翐翑翇翏翉耟"], ["d740", "耞耛聇聃聈脘脥脙脛脭脟脬脞脡脕脧脝脢舑舸舳舺舴舲艴莐莣莨莍荺荳莤荴莏莁莕莙荵莔莩荽莃莌莝莛莪莋荾莥莯莈莗莰荿莦莇莮荶莚虙虖蚿蚷"], ["d7a1", "蛂蛁蛅蚺蚰蛈蚹蚳蚸蛌蚴蚻蚼蛃蚽蚾衒袉袕袨袢袪袚袑袡袟袘袧袙袛袗袤袬袌袓袎覂觖觙觕訰訧訬訞谹谻豜豝豽貥赽赻赹趼跂趹趿跁軘軞軝軜軗軠軡逤逋逑逜逌逡郯郪郰郴郲郳郔郫郬郩酖酘酚酓酕釬釴釱釳釸釤釹釪"], ["d840", "釫釷釨釮镺閆閈陼陭陫陱陯隿靪頄飥馗傛傕傔傞傋傣傃傌傎傝偨傜傒傂傇兟凔匒匑厤厧喑喨喥喭啷噅喢喓喈喏喵喁喣喒喤啽喌喦啿喕喡喎圌堩堷"], ["d8a1", "堙堞堧堣堨埵塈堥堜堛堳堿堶堮堹堸堭堬堻奡媯媔媟婺媢媞婸媦婼媥媬媕媮娷媄媊媗媃媋媩婻婽媌媜媏媓媝寪寍寋寔寑寊寎尌尰崷嵃嵫嵁嵋崿崵嵑嵎嵕崳崺嵒崽崱嵙嵂崹嵉崸崼崲崶嵀嵅幄幁彘徦徥徫惉悹惌惢惎惄愔"], ["d940", "惲愊愖愅惵愓惸惼惾惁愃愘愝愐惿愄愋扊掔掱掰揎揥揨揯揃撝揳揊揠揶揕揲揵摡揟掾揝揜揄揘揓揂揇揌揋揈揰揗揙攲敧敪敤敜敨敥斌斝斞斮旐旒"], ["d9a1", "晼晬晻暀晱晹晪晲朁椌棓椄棜椪棬棪棱椏棖棷棫棤棶椓椐棳棡椇棌椈楰梴椑棯棆椔棸棐棽棼棨椋椊椗棎棈棝棞棦棴棑椆棔棩椕椥棇欹欻欿欼殔殗殙殕殽毰毲毳氰淼湆湇渟湉溈渼渽湅湢渫渿湁湝湳渜渳湋湀湑渻渃渮湞"], ["da40", "湨湜湡渱渨湠湱湫渹渢渰湓湥渧湸湤湷湕湹湒湦渵渶湚焠焞焯烻焮焱焣焥焢焲焟焨焺焛牋牚犈犉犆犅犋猒猋猰猢猱猳猧猲猭猦猣猵猌琮琬琰琫琖"], ["daa1", "琚琡琭琱琤琣琝琩琠琲瓻甯畯畬痧痚痡痦痝痟痤痗皕皒盚睆睇睄睍睅睊睎睋睌矞矬硠硤硥硜硭硱硪确硰硩硨硞硢祴祳祲祰稂稊稃稌稄窙竦竤筊笻筄筈筌筎筀筘筅粢粞粨粡絘絯絣絓絖絧絪絏絭絜絫絒絔絩絑絟絎缾缿罥"], ["db40", "罦羢羠羡翗聑聏聐胾胔腃腊腒腏腇脽腍脺臦臮臷臸臹舄舼舽舿艵茻菏菹萣菀菨萒菧菤菼菶萐菆菈菫菣莿萁菝菥菘菿菡菋菎菖菵菉萉萏菞萑萆菂菳"], ["dba1", "菕菺菇菑菪萓菃菬菮菄菻菗菢萛菛菾蛘蛢蛦蛓蛣蛚蛪蛝蛫蛜蛬蛩蛗蛨蛑衈衖衕袺裗袹袸裀袾袶袼袷袽袲褁裉覕覘覗觝觚觛詎詍訹詙詀詗詘詄詅詒詈詑詊詌詏豟貁貀貺貾貰貹貵趄趀趉跘跓跍跇跖跜跏跕跙跈跗跅軯軷軺"], ["dc40", "軹軦軮軥軵軧軨軶軫軱軬軴軩逭逴逯鄆鄬鄄郿郼鄈郹郻鄁鄀鄇鄅鄃酡酤酟酢酠鈁鈊鈥鈃鈚鈦鈏鈌鈀鈒釿釽鈆鈄鈧鈂鈜鈤鈙鈗鈅鈖镻閍閌閐隇陾隈"], ["dca1", "隉隃隀雂雈雃雱雰靬靰靮頇颩飫鳦黹亃亄亶傽傿僆傮僄僊傴僈僂傰僁傺傱僋僉傶傸凗剺剸剻剼嗃嗛嗌嗐嗋嗊嗝嗀嗔嗄嗩喿嗒喍嗏嗕嗢嗖嗈嗲嗍嗙嗂圔塓塨塤塏塍塉塯塕塎塝塙塥塛堽塣塱壼嫇嫄嫋媺媸媱媵媰媿嫈媻嫆"], ["dd40", "媷嫀嫊媴媶嫍媹媐寖寘寙尟尳嵱嵣嵊嵥嵲嵬嵞嵨嵧嵢巰幏幎幊幍幋廅廌廆廋廇彀徯徭惷慉慊愫慅愶愲愮慆愯慏愩慀戠酨戣戥戤揅揱揫搐搒搉搠搤"], ["dda1", "搳摃搟搕搘搹搷搢搣搌搦搰搨摁搵搯搊搚摀搥搧搋揧搛搮搡搎敯斒旓暆暌暕暐暋暊暙暔晸朠楦楟椸楎楢楱椿楅楪椹楂楗楙楺楈楉椵楬椳椽楥棰楸椴楩楀楯楄楶楘楁楴楌椻楋椷楜楏楑椲楒椯楻椼歆歅歃歂歈歁殛嗀毻毼"], ["de40", "毹毷毸溛滖滈溏滀溟溓溔溠溱溹滆滒溽滁溞滉溷溰滍溦滏溲溾滃滜滘溙溒溎溍溤溡溿溳滐滊溗溮溣煇煔煒煣煠煁煝煢煲煸煪煡煂煘煃煋煰煟煐煓"], ["dea1", "煄煍煚牏犍犌犑犐犎猼獂猻猺獀獊獉瑄瑊瑋瑒瑑瑗瑀瑏瑐瑎瑂瑆瑍瑔瓡瓿瓾瓽甝畹畷榃痯瘏瘃痷痾痼痹痸瘐痻痶痭痵痽皙皵盝睕睟睠睒睖睚睩睧睔睙睭矠碇碚碔碏碄碕碅碆碡碃硹碙碀碖硻祼禂祽祹稑稘稙稒稗稕稢稓"], ["df40", "稛稐窣窢窞竫筦筤筭筴筩筲筥筳筱筰筡筸筶筣粲粴粯綈綆綀綍絿綅絺綎絻綃絼綌綔綄絽綒罭罫罧罨罬羦羥羧翛翜耡腤腠腷腜腩腛腢腲朡腞腶腧腯"], ["dfa1", "腄腡舝艉艄艀艂艅蓱萿葖葶葹蒏蒍葥葑葀蒆葧萰葍葽葚葙葴葳葝蔇葞萷萺萴葺葃葸萲葅萩菙葋萯葂萭葟葰萹葎葌葒葯蓅蒎萻葇萶萳葨葾葄萫葠葔葮葐蜋蜄蛷蜌蛺蛖蛵蝍蛸蜎蜉蜁蛶蜍蜅裖裋裍裎裞裛裚裌裐覅覛觟觥觤"], ["e040", "觡觠觢觜触詶誆詿詡訿詷誂誄詵誃誁詴詺谼豋豊豥豤豦貆貄貅賌赨赩趑趌趎趏趍趓趔趐趒跰跠跬跱跮跐跩跣跢跧跲跫跴輆軿輁輀輅輇輈輂輋遒逿"], ["e0a1", "遄遉逽鄐鄍鄏鄑鄖鄔鄋鄎酮酯鉈鉒鈰鈺鉦鈳鉥鉞銃鈮鉊鉆鉭鉬鉏鉠鉧鉯鈶鉡鉰鈱鉔鉣鉐鉲鉎鉓鉌鉖鈲閟閜閞閛隒隓隑隗雎雺雽雸雵靳靷靸靲頏頍頎颬飶飹馯馲馰馵骭骫魛鳪鳭鳧麀黽僦僔僗僨僳僛僪僝僤僓僬僰僯僣僠"], ["e140", "凘劀劁勩勫匰厬嘧嘕嘌嘒嗼嘏嘜嘁嘓嘂嗺嘝嘄嗿嗹墉塼墐墘墆墁塿塴墋塺墇墑墎塶墂墈塻墔墏壾奫嫜嫮嫥嫕嫪嫚嫭嫫嫳嫢嫠嫛嫬嫞嫝嫙嫨嫟孷寠"], ["e1a1", "寣屣嶂嶀嵽嶆嵺嶁嵷嶊嶉嶈嵾嵼嶍嵹嵿幘幙幓廘廑廗廎廜廕廙廒廔彄彃彯徶愬愨慁慞慱慳慒慓慲慬憀慴慔慺慛慥愻慪慡慖戩戧戫搫摍摛摝摴摶摲摳摽摵摦撦摎撂摞摜摋摓摠摐摿搿摬摫摙摥摷敳斠暡暠暟朅朄朢榱榶槉"], ["e240", "榠槎榖榰榬榼榑榙榎榧榍榩榾榯榿槄榽榤槔榹槊榚槏榳榓榪榡榞槙榗榐槂榵榥槆歊歍歋殞殟殠毃毄毾滎滵滱漃漥滸漷滻漮漉潎漙漚漧漘漻漒滭漊"], ["e2a1", "漶潳滹滮漭潀漰漼漵滫漇漎潃漅滽滶漹漜滼漺漟漍漞漈漡熇熐熉熀熅熂熏煻熆熁熗牄牓犗犕犓獃獍獑獌瑢瑳瑱瑵瑲瑧瑮甀甂甃畽疐瘖瘈瘌瘕瘑瘊瘔皸瞁睼瞅瞂睮瞀睯睾瞃碲碪碴碭碨硾碫碞碥碠碬碢碤禘禊禋禖禕禔禓"], ["e340", "禗禈禒禐稫穊稰稯稨稦窨窫窬竮箈箜箊箑箐箖箍箌箛箎箅箘劄箙箤箂粻粿粼粺綧綷緂綣綪緁緀緅綝緎緄緆緋緌綯綹綖綼綟綦綮綩綡緉罳翢翣翥翞"], ["e3a1", "耤聝聜膉膆膃膇膍膌膋舕蒗蒤蒡蒟蒺蓎蓂蒬蒮蒫蒹蒴蓁蓍蒪蒚蒱蓐蒝蒧蒻蒢蒔蓇蓌蒛蒩蒯蒨蓖蒘蒶蓏蒠蓗蓔蓒蓛蒰蒑虡蜳蜣蜨蝫蝀蜮蜞蜡蜙蜛蝃蜬蝁蜾蝆蜠蜲蜪蜭蜼蜒蜺蜱蜵蝂蜦蜧蜸蜤蜚蜰蜑裷裧裱裲裺裾裮裼裶裻"], ["e440", "裰裬裫覝覡覟覞觩觫觨誫誙誋誒誏誖谽豨豩賕賏賗趖踉踂跿踍跽踊踃踇踆踅跾踀踄輐輑輎輍鄣鄜鄠鄢鄟鄝鄚鄤鄡鄛酺酲酹酳銥銤鉶銛鉺銠銔銪銍"], ["e4a1", "銦銚銫鉹銗鉿銣鋮銎銂銕銢鉽銈銡銊銆銌銙銧鉾銇銩銝銋鈭隞隡雿靘靽靺靾鞃鞀鞂靻鞄鞁靿韎韍頖颭颮餂餀餇馝馜駃馹馻馺駂馽駇骱髣髧鬾鬿魠魡魟鳱鳲鳵麧僿儃儰僸儆儇僶僾儋儌僽儊劋劌勱勯噈噂噌嘵噁噊噉噆噘"], ["e540", "噚噀嘳嘽嘬嘾嘸嘪嘺圚墫墝墱墠墣墯墬墥墡壿嫿嫴嫽嫷嫶嬃嫸嬂嫹嬁嬇嬅嬏屧嶙嶗嶟嶒嶢嶓嶕嶠嶜嶡嶚嶞幩幝幠幜緳廛廞廡彉徲憋憃慹憱憰憢憉"], ["e5a1", "憛憓憯憭憟憒憪憡憍慦憳戭摮摰撖撠撅撗撜撏撋撊撌撣撟摨撱撘敶敺敹敻斲斳暵暰暩暲暷暪暯樀樆樗槥槸樕槱槤樠槿槬槢樛樝槾樧槲槮樔槷槧橀樈槦槻樍槼槫樉樄樘樥樏槶樦樇槴樖歑殥殣殢殦氁氀毿氂潁漦潾澇濆澒"], ["e640", "澍澉澌潢潏澅潚澖潶潬澂潕潲潒潐潗澔澓潝漀潡潫潽潧澐潓澋潩潿澕潣潷潪潻熲熯熛熰熠熚熩熵熝熥熞熤熡熪熜熧熳犘犚獘獒獞獟獠獝獛獡獚獙"], ["e6a1", "獢璇璉璊璆璁瑽璅璈瑼瑹甈甇畾瘥瘞瘙瘝瘜瘣瘚瘨瘛皜皝皞皛瞍瞏瞉瞈磍碻磏磌磑磎磔磈磃磄磉禚禡禠禜禢禛歶稹窲窴窳箷篋箾箬篎箯箹篊箵糅糈糌糋緷緛緪緧緗緡縃緺緦緶緱緰緮緟罶羬羰羭翭翫翪翬翦翨聤聧膣膟"], ["e740", "膞膕膢膙膗舖艏艓艒艐艎艑蔤蔻蔏蔀蔩蔎蔉蔍蔟蔊蔧蔜蓻蔫蓺蔈蔌蓴蔪蓲蔕蓷蓫蓳蓼蔒蓪蓩蔖蓾蔨蔝蔮蔂蓽蔞蓶蔱蔦蓧蓨蓰蓯蓹蔘蔠蔰蔋蔙蔯虢"], ["e7a1", "蝖蝣蝤蝷蟡蝳蝘蝔蝛蝒蝡蝚蝑蝞蝭蝪蝐蝎蝟蝝蝯蝬蝺蝮蝜蝥蝏蝻蝵蝢蝧蝩衚褅褌褔褋褗褘褙褆褖褑褎褉覢覤覣觭觰觬諏諆誸諓諑諔諕誻諗誾諀諅諘諃誺誽諙谾豍貏賥賟賙賨賚賝賧趠趜趡趛踠踣踥踤踮踕踛踖踑踙踦踧"], ["e840", "踔踒踘踓踜踗踚輬輤輘輚輠輣輖輗遳遰遯遧遫鄯鄫鄩鄪鄲鄦鄮醅醆醊醁醂醄醀鋐鋃鋄鋀鋙銶鋏鋱鋟鋘鋩鋗鋝鋌鋯鋂鋨鋊鋈鋎鋦鋍鋕鋉鋠鋞鋧鋑鋓"], ["e8a1", "銵鋡鋆銴镼閬閫閮閰隤隢雓霅霈霂靚鞊鞎鞈韐韏頞頝頦頩頨頠頛頧颲餈飺餑餔餖餗餕駜駍駏駓駔駎駉駖駘駋駗駌骳髬髫髳髲髱魆魃魧魴魱魦魶魵魰魨魤魬鳼鳺鳽鳿鳷鴇鴀鳹鳻鴈鴅鴄麃黓鼏鼐儜儓儗儚儑凞匴叡噰噠噮"], ["e940", "噳噦噣噭噲噞噷圜圛壈墽壉墿墺壂墼壆嬗嬙嬛嬡嬔嬓嬐嬖嬨嬚嬠嬞寯嶬嶱嶩嶧嶵嶰嶮嶪嶨嶲嶭嶯嶴幧幨幦幯廩廧廦廨廥彋徼憝憨憖懅憴懆懁懌憺"], ["e9a1", "憿憸憌擗擖擐擏擉撽撉擃擛擳擙攳敿敼斢曈暾曀曊曋曏暽暻暺曌朣樴橦橉橧樲橨樾橝橭橶橛橑樨橚樻樿橁橪橤橐橏橔橯橩橠樼橞橖橕橍橎橆歕歔歖殧殪殫毈毇氄氃氆澭濋澣濇澼濎濈潞濄澽澞濊澨瀄澥澮澺澬澪濏澿澸"], ["ea40", "澢濉澫濍澯澲澰燅燂熿熸燖燀燁燋燔燊燇燏熽燘熼燆燚燛犝犞獩獦獧獬獥獫獪瑿璚璠璔璒璕璡甋疀瘯瘭瘱瘽瘳瘼瘵瘲瘰皻盦瞚瞝瞡瞜瞛瞢瞣瞕瞙"], ["eaa1", "瞗磝磩磥磪磞磣磛磡磢磭磟磠禤穄穈穇窶窸窵窱窷篞篣篧篝篕篥篚篨篹篔篪篢篜篫篘篟糒糔糗糐糑縒縡縗縌縟縠縓縎縜縕縚縢縋縏縖縍縔縥縤罃罻罼罺羱翯耪耩聬膱膦膮膹膵膫膰膬膴膲膷膧臲艕艖艗蕖蕅蕫蕍蕓蕡蕘"], ["eb40", "蕀蕆蕤蕁蕢蕄蕑蕇蕣蔾蕛蕱蕎蕮蕵蕕蕧蕠薌蕦蕝蕔蕥蕬虣虥虤螛螏螗螓螒螈螁螖螘蝹螇螣螅螐螑螝螄螔螜螚螉褞褦褰褭褮褧褱褢褩褣褯褬褟觱諠"], ["eba1", "諢諲諴諵諝謔諤諟諰諈諞諡諨諿諯諻貑貒貐賵賮賱賰賳赬赮趥趧踳踾踸蹀蹅踶踼踽蹁踰踿躽輶輮輵輲輹輷輴遶遹遻邆郺鄳鄵鄶醓醐醑醍醏錧錞錈錟錆錏鍺錸錼錛錣錒錁鍆錭錎錍鋋錝鋺錥錓鋹鋷錴錂錤鋿錩錹錵錪錔錌"], ["ec40", "錋鋾錉錀鋻錖閼闍閾閹閺閶閿閵閽隩雔霋霒霐鞙鞗鞔韰韸頵頯頲餤餟餧餩馞駮駬駥駤駰駣駪駩駧骹骿骴骻髶髺髹髷鬳鮀鮅鮇魼魾魻鮂鮓鮒鮐魺鮕"], ["eca1", "魽鮈鴥鴗鴠鴞鴔鴩鴝鴘鴢鴐鴙鴟麈麆麇麮麭黕黖黺鼒鼽儦儥儢儤儠儩勴嚓嚌嚍嚆嚄嚃噾嚂噿嚁壖壔壏壒嬭嬥嬲嬣嬬嬧嬦嬯嬮孻寱寲嶷幬幪徾徻懃憵憼懧懠懥懤懨懞擯擩擣擫擤擨斁斀斶旚曒檍檖檁檥檉檟檛檡檞檇檓檎"], ["ed40", "檕檃檨檤檑橿檦檚檅檌檒歛殭氉濌澩濴濔濣濜濭濧濦濞濲濝濢濨燡燱燨燲燤燰燢獳獮獯璗璲璫璐璪璭璱璥璯甐甑甒甏疄癃癈癉癇皤盩瞵瞫瞲瞷瞶"], ["eda1", "瞴瞱瞨矰磳磽礂磻磼磲礅磹磾礄禫禨穜穛穖穘穔穚窾竀竁簅簏篲簀篿篻簎篴簋篳簂簉簃簁篸篽簆篰篱簐簊糨縭縼繂縳顈縸縪繉繀繇縩繌縰縻縶繄縺罅罿罾罽翴翲耬膻臄臌臊臅臇膼臩艛艚艜薃薀薏薧薕薠薋薣蕻薤薚薞"], ["ee40", "蕷蕼薉薡蕺蕸蕗薎薖薆薍薙薝薁薢薂薈薅蕹蕶薘薐薟虨螾螪螭蟅螰螬螹螵螼螮蟉蟃蟂蟌螷螯蟄蟊螴螶螿螸螽蟞螲褵褳褼褾襁襒褷襂覭覯覮觲觳謞"], ["eea1", "謘謖謑謅謋謢謏謒謕謇謍謈謆謜謓謚豏豰豲豱豯貕貔賹赯蹎蹍蹓蹐蹌蹇轃轀邅遾鄸醚醢醛醙醟醡醝醠鎡鎃鎯鍤鍖鍇鍼鍘鍜鍶鍉鍐鍑鍠鍭鎏鍌鍪鍹鍗鍕鍒鍏鍱鍷鍻鍡鍞鍣鍧鎀鍎鍙闇闀闉闃闅閷隮隰隬霠霟霘霝霙鞚鞡鞜"], ["ef40", "鞞鞝韕韔韱顁顄顊顉顅顃餥餫餬餪餳餲餯餭餱餰馘馣馡騂駺駴駷駹駸駶駻駽駾駼騃骾髾髽鬁髼魈鮚鮨鮞鮛鮦鮡鮥鮤鮆鮢鮠鮯鴳鵁鵧鴶鴮鴯鴱鴸鴰"], ["efa1", "鵅鵂鵃鴾鴷鵀鴽翵鴭麊麉麍麰黈黚黻黿鼤鼣鼢齔龠儱儭儮嚘嚜嚗嚚嚝嚙奰嬼屩屪巀幭幮懘懟懭懮懱懪懰懫懖懩擿攄擽擸攁攃擼斔旛曚曛曘櫅檹檽櫡櫆檺檶檷櫇檴檭歞毉氋瀇瀌瀍瀁瀅瀔瀎濿瀀濻瀦濼濷瀊爁燿燹爃燽獶"], ["f040", "璸瓀璵瓁璾璶璻瓂甔甓癜癤癙癐癓癗癚皦皽盬矂瞺磿礌礓礔礉礐礒礑禭禬穟簜簩簙簠簟簭簝簦簨簢簥簰繜繐繖繣繘繢繟繑繠繗繓羵羳翷翸聵臑臒"], ["f0a1", "臐艟艞薴藆藀藃藂薳薵薽藇藄薿藋藎藈藅薱薶藒蘤薸薷薾虩蟧蟦蟢蟛蟫蟪蟥蟟蟳蟤蟔蟜蟓蟭蟘蟣螤蟗蟙蠁蟴蟨蟝襓襋襏襌襆襐襑襉謪謧謣謳謰謵譇謯謼謾謱謥謷謦謶謮謤謻謽謺豂豵貙貘貗賾贄贂贀蹜蹢蹠蹗蹖蹞蹥蹧"], ["f140", "蹛蹚蹡蹝蹩蹔轆轇轈轋鄨鄺鄻鄾醨醥醧醯醪鎵鎌鎒鎷鎛鎝鎉鎧鎎鎪鎞鎦鎕鎈鎙鎟鎍鎱鎑鎲鎤鎨鎴鎣鎥闒闓闑隳雗雚巂雟雘雝霣霢霥鞬鞮鞨鞫鞤鞪"], ["f1a1", "鞢鞥韗韙韖韘韺顐顑顒颸饁餼餺騏騋騉騍騄騑騊騅騇騆髀髜鬈鬄鬅鬩鬵魊魌魋鯇鯆鯃鮿鯁鮵鮸鯓鮶鯄鮹鮽鵜鵓鵏鵊鵛鵋鵙鵖鵌鵗鵒鵔鵟鵘鵚麎麌黟鼁鼀鼖鼥鼫鼪鼩鼨齌齕儴儵劖勷厴嚫嚭嚦嚧嚪嚬壚壝壛夒嬽嬾嬿巃幰"], ["f240", "徿懻攇攐攍攉攌攎斄旞旝曞櫧櫠櫌櫑櫙櫋櫟櫜櫐櫫櫏櫍櫞歠殰氌瀙瀧瀠瀖瀫瀡瀢瀣瀩瀗瀤瀜瀪爌爊爇爂爅犥犦犤犣犡瓋瓅璷瓃甖癠矉矊矄矱礝礛"], ["f2a1", "礡礜礗礞禰穧穨簳簼簹簬簻糬糪繶繵繸繰繷繯繺繲繴繨罋罊羃羆羷翽翾聸臗臕艤艡艣藫藱藭藙藡藨藚藗藬藲藸藘藟藣藜藑藰藦藯藞藢蠀蟺蠃蟶蟷蠉蠌蠋蠆蟼蠈蟿蠊蠂襢襚襛襗襡襜襘襝襙覈覷覶觶譐譈譊譀譓譖譔譋譕"], ["f340", "譑譂譒譗豃豷豶貚贆贇贉趬趪趭趫蹭蹸蹳蹪蹯蹻軂轒轑轏轐轓辴酀鄿醰醭鏞鏇鏏鏂鏚鏐鏹鏬鏌鏙鎩鏦鏊鏔鏮鏣鏕鏄鏎鏀鏒鏧镽闚闛雡霩霫霬霨霦"], ["f3a1", "鞳鞷鞶韝韞韟顜顙顝顗颿颽颻颾饈饇饃馦馧騚騕騥騝騤騛騢騠騧騣騞騜騔髂鬋鬊鬎鬌鬷鯪鯫鯠鯞鯤鯦鯢鯰鯔鯗鯬鯜鯙鯥鯕鯡鯚鵷鶁鶊鶄鶈鵱鶀鵸鶆鶋鶌鵽鵫鵴鵵鵰鵩鶅鵳鵻鶂鵯鵹鵿鶇鵨麔麑黀黼鼭齀齁齍齖齗齘匷嚲"], ["f440", "嚵嚳壣孅巆巇廮廯忀忁懹攗攖攕攓旟曨曣曤櫳櫰櫪櫨櫹櫱櫮櫯瀼瀵瀯瀷瀴瀱灂瀸瀿瀺瀹灀瀻瀳灁爓爔犨獽獼璺皫皪皾盭矌矎矏矍矲礥礣礧礨礤礩"], ["f4a1", "禲穮穬穭竷籉籈籊籇籅糮繻繾纁纀羺翿聹臛臙舋艨艩蘢藿蘁藾蘛蘀藶蘄蘉蘅蘌藽蠙蠐蠑蠗蠓蠖襣襦覹觷譠譪譝譨譣譥譧譭趮躆躈躄轙轖轗轕轘轚邍酃酁醷醵醲醳鐋鐓鏻鐠鐏鐔鏾鐕鐐鐨鐙鐍鏵鐀鏷鐇鐎鐖鐒鏺鐉鏸鐊鏿"], ["f540", "鏼鐌鏶鐑鐆闞闠闟霮霯鞹鞻韽韾顠顢顣顟飁飂饐饎饙饌饋饓騲騴騱騬騪騶騩騮騸騭髇髊髆鬐鬒鬑鰋鰈鯷鰅鰒鯸鱀鰇鰎鰆鰗鰔鰉鶟鶙鶤鶝鶒鶘鶐鶛"], ["f5a1", "鶠鶔鶜鶪鶗鶡鶚鶢鶨鶞鶣鶿鶩鶖鶦鶧麙麛麚黥黤黧黦鼰鼮齛齠齞齝齙龑儺儹劘劗囃嚽嚾孈孇巋巏廱懽攛欂櫼欃櫸欀灃灄灊灈灉灅灆爝爚爙獾甗癪矐礭礱礯籔籓糲纊纇纈纋纆纍罍羻耰臝蘘蘪蘦蘟蘣蘜蘙蘧蘮蘡蘠蘩蘞蘥"], ["f640", "蠩蠝蠛蠠蠤蠜蠫衊襭襩襮襫觺譹譸譅譺譻贐贔趯躎躌轞轛轝酆酄酅醹鐿鐻鐶鐩鐽鐼鐰鐹鐪鐷鐬鑀鐱闥闤闣霵霺鞿韡顤飉飆飀饘饖騹騽驆驄驂驁騺"], ["f6a1", "騿髍鬕鬗鬘鬖鬺魒鰫鰝鰜鰬鰣鰨鰩鰤鰡鶷鶶鶼鷁鷇鷊鷏鶾鷅鷃鶻鶵鷎鶹鶺鶬鷈鶱鶭鷌鶳鷍鶲鹺麜黫黮黭鼛鼘鼚鼱齎齥齤龒亹囆囅囋奱孋孌巕巑廲攡攠攦攢欋欈欉氍灕灖灗灒爞爟犩獿瓘瓕瓙瓗癭皭礵禴穰穱籗籜籙籛籚"], ["f740", "糴糱纑罏羇臞艫蘴蘵蘳蘬蘲蘶蠬蠨蠦蠪蠥襱覿覾觻譾讄讂讆讅譿贕躕躔躚躒躐躖躗轠轢酇鑌鑐鑊鑋鑏鑇鑅鑈鑉鑆霿韣顪顩飋饔饛驎驓驔驌驏驈驊"], ["f7a1", "驉驒驐髐鬙鬫鬻魖魕鱆鱈鰿鱄鰹鰳鱁鰼鰷鰴鰲鰽鰶鷛鷒鷞鷚鷋鷐鷜鷑鷟鷩鷙鷘鷖鷵鷕鷝麶黰鼵鼳鼲齂齫龕龢儽劙壨壧奲孍巘蠯彏戁戃戄攩攥斖曫欑欒欏毊灛灚爢玂玁玃癰矔籧籦纕艬蘺虀蘹蘼蘱蘻蘾蠰蠲蠮蠳襶襴襳觾"], ["f840", "讌讎讋讈豅贙躘轤轣醼鑢鑕鑝鑗鑞韄韅頀驖驙鬞鬟鬠鱒鱘鱐鱊鱍鱋鱕鱙鱌鱎鷻鷷鷯鷣鷫鷸鷤鷶鷡鷮鷦鷲鷰鷢鷬鷴鷳鷨鷭黂黐黲黳鼆鼜鼸鼷鼶齃齏"], ["f8a1", "齱齰齮齯囓囍孎屭攭曭曮欓灟灡灝灠爣瓛瓥矕礸禷禶籪纗羉艭虃蠸蠷蠵衋讔讕躞躟躠躝醾醽釂鑫鑨鑩雥靆靃靇韇韥驞髕魙鱣鱧鱦鱢鱞鱠鸂鷾鸇鸃鸆鸅鸀鸁鸉鷿鷽鸄麠鼞齆齴齵齶囔攮斸欘欙欗欚灢爦犪矘矙礹籩籫糶纚"], ["f940", "纘纛纙臠臡虆虇虈襹襺襼襻觿讘讙躥躤躣鑮鑭鑯鑱鑳靉顲饟鱨鱮鱭鸋鸍鸐鸏鸒鸑麡黵鼉齇齸齻齺齹圞灦籯蠼趲躦釃鑴鑸鑶鑵驠鱴鱳鱱鱵鸔鸓黶鼊"], ["f9a1", "龤灨灥糷虪蠾蠽蠿讞貜躩軉靋顳顴飌饡馫驤驦驧鬤鸕鸗齈戇欞爧虌躨钂钀钁驩驨鬮鸙爩虋讟钃鱹麷癵驫鱺鸝灩灪麤齾齉龘碁銹裏墻恒粧嫺╔╦╗╠╬╣╚╩╝╒╤╕╞╪╡╘╧╛╓╥╖╟╫╢╙╨╜║═╭╮╰╯▓"]];
    }, {}],
    23: [function (require, module, exports) {
      module.exports = [["0", "\0", 127], ["8ea1", "｡", 62], ["a1a1", "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈", 9, "＋－±×÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇"], ["a2a1", "◆□■△▲▽▼※〒→←↑↓〓"], ["a2ba", "∈∋⊆⊇⊂⊃∪∩"], ["a2ca", "∧∨￢⇒⇔∀∃"], ["a2dc", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"], ["a2f2", "Å‰♯♭♪†‡¶"], ["a2fe", "◯"], ["a3b0", "０", 9], ["a3c1", "Ａ", 25], ["a3e1", "ａ", 25], ["a4a1", "ぁ", 82], ["a5a1", "ァ", 85], ["a6a1", "Α", 16, "Σ", 6], ["a6c1", "α", 16, "σ", 6], ["a7a1", "А", 5, "ЁЖ", 25], ["a7d1", "а", 5, "ёж", 25], ["a8a1", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"], ["ada1", "①", 19, "Ⅰ", 9], ["adc0", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"], ["addf", "㍻〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"], ["b0a1", "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"], ["b1a1", "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応"], ["b2a1", "押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"], ["b3a1", "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱"], ["b4a1", "粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"], ["b5a1", "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京"], ["b6a1", "供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"], ["b7a1", "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲"], ["b8a1", "検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"], ["b9a1", "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込"], ["baa1", "此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"], ["bba1", "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時"], ["bca1", "次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"], ["bda1", "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償"], ["bea1", "勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"], ["bfa1", "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾"], ["c0a1", "澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"], ["c1a1", "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎"], ["c2a1", "臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"], ["c3a1", "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵"], ["c4a1", "帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"], ["c5a1", "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到"], ["c6a1", "董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"], ["c7a1", "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦"], ["c8a1", "函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"], ["c9a1", "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服"], ["caa1", "福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"], ["cba1", "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満"], ["cca1", "漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"], ["cda1", "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃"], ["cea1", "痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"], ["cfa1", "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"], ["d0a1", "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"], ["d1a1", "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨"], ["d2a1", "辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"], ["d3a1", "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉"], ["d4a1", "圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"], ["d5a1", "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓"], ["d6a1", "屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"], ["d7a1", "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚"], ["d8a1", "悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"], ["d9a1", "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼"], ["daa1", "據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"], ["dba1", "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍"], ["dca1", "棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"], ["dda1", "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾"], ["dea1", "沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"], ["dfa1", "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼"], ["e0a1", "燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"], ["e1a1", "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰"], ["e2a1", "癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"], ["e3a1", "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐"], ["e4a1", "筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"], ["e5a1", "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺"], ["e6a1", "罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"], ["e7a1", "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙"], ["e8a1", "茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"], ["e9a1", "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙"], ["eaa1", "蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"], ["eba1", "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫"], ["eca1", "譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"], ["eda1", "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸"], ["eea1", "遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"], ["efa1", "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞"], ["f0a1", "陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"], ["f1a1", "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷"], ["f2a1", "髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"], ["f3a1", "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠"], ["f4a1", "堯槇遙瑤凜熙"], ["f9a1", "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德"], ["faa1", "忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"], ["fba1", "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚"], ["fca1", "釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"], ["fcf1", "ⅰ", 9, "￢￤＇＂"], ["8fa2af", "˘ˇ¸˙˝¯˛˚～΄΅"], ["8fa2c2", "¡¦¿"], ["8fa2eb", "ºª©®™¤№"], ["8fa6e1", "ΆΈΉΊΪ"], ["8fa6e7", "Ό"], ["8fa6e9", "ΎΫ"], ["8fa6ec", "Ώ"], ["8fa6f1", "άέήίϊΐόςύϋΰώ"], ["8fa7c2", "Ђ", 10, "ЎЏ"], ["8fa7f2", "ђ", 10, "ўџ"], ["8fa9a1", "ÆĐ"], ["8fa9a4", "Ħ"], ["8fa9a6", "Ĳ"], ["8fa9a8", "ŁĿ"], ["8fa9ab", "ŊØŒ"], ["8fa9af", "ŦÞ"], ["8fa9c1", "æđðħıĳĸłŀŉŋøœßŧþ"], ["8faaa1", "ÁÀÄÂĂǍĀĄÅÃĆĈČÇĊĎÉÈËÊĚĖĒĘ"], ["8faaba", "ĜĞĢĠĤÍÌÏÎǏİĪĮĨĴĶĹĽĻŃŇŅÑÓÒÖÔǑŐŌÕŔŘŖŚŜŠŞŤŢÚÙÜÛŬǓŰŪŲŮŨǗǛǙǕŴÝŸŶŹŽŻ"], ["8faba1", "áàäâăǎāąåãćĉčçċďéèëêěėēęǵĝğ"], ["8fabbd", "ġĥíìïîǐ"], ["8fabc5", "īįĩĵķĺľļńňņñóòöôǒőōõŕřŗśŝšşťţúùüûŭǔűūųůũǘǜǚǖŵýÿŷźžż"], ["8fb0a1", "丂丄丅丌丒丟丣两丨丫丮丯丰丵乀乁乄乇乑乚乜乣乨乩乴乵乹乿亍亖亗亝亯亹仃仐仚仛仠仡仢仨仯仱仳仵份仾仿伀伂伃伈伋伌伒伕伖众伙伮伱你伳伵伷伹伻伾佀佂佈佉佋佌佒佔佖佘佟佣佪佬佮佱佷佸佹佺佽佾侁侂侄"], ["8fb1a1", "侅侉侊侌侎侐侒侓侔侗侙侚侞侟侲侷侹侻侼侽侾俀俁俅俆俈俉俋俌俍俏俒俜俠俢俰俲俼俽俿倀倁倄倇倊倌倎倐倓倗倘倛倜倝倞倢倧倮倰倲倳倵偀偁偂偅偆偊偌偎偑偒偓偗偙偟偠偢偣偦偧偪偭偰偱倻傁傃傄傆傊傎傏傐"], ["8fb2a1", "傒傓傔傖傛傜傞", 4, "傪傯傰傹傺傽僀僃僄僇僌僎僐僓僔僘僜僝僟僢僤僦僨僩僯僱僶僺僾儃儆儇儈儋儌儍儎僲儐儗儙儛儜儝儞儣儧儨儬儭儯儱儳儴儵儸儹兂兊兏兓兕兗兘兟兤兦兾冃冄冋冎冘冝冡冣冭冸冺冼冾冿凂"], ["8fb3a1", "凈减凑凒凓凕凘凞凢凥凮凲凳凴凷刁刂刅划刓刕刖刘刢刨刱刲刵刼剅剉剕剗剘剚剜剟剠剡剦剮剷剸剹劀劂劅劊劌劓劕劖劗劘劚劜劤劥劦劧劯劰劶劷劸劺劻劽勀勄勆勈勌勏勑勔勖勛勜勡勥勨勩勪勬勰勱勴勶勷匀匃匊匋"], ["8fb4a1", "匌匑匓匘匛匜匞匟匥匧匨匩匫匬匭匰匲匵匼匽匾卂卌卋卙卛卡卣卥卬卭卲卹卾厃厇厈厎厓厔厙厝厡厤厪厫厯厲厴厵厷厸厺厽叀叅叏叒叓叕叚叝叞叠另叧叵吂吓吚吡吧吨吪启吱吴吵呃呄呇呍呏呞呢呤呦呧呩呫呭呮呴呿"], ["8fb5a1", "咁咃咅咈咉咍咑咕咖咜咟咡咦咧咩咪咭咮咱咷咹咺咻咿哆哊响哎哠哪哬哯哶哼哾哿唀唁唅唈唉唌唍唎唕唪唫唲唵唶唻唼唽啁啇啉啊啍啐啑啘啚啛啞啠啡啤啦啿喁喂喆喈喎喏喑喒喓喔喗喣喤喭喲喿嗁嗃嗆嗉嗋嗌嗎嗑嗒"], ["8fb6a1", "嗓嗗嗘嗛嗞嗢嗩嗶嗿嘅嘈嘊嘍", 5, "嘙嘬嘰嘳嘵嘷嘹嘻嘼嘽嘿噀噁噃噄噆噉噋噍噏噔噞噠噡噢噣噦噩噭噯噱噲噵嚄嚅嚈嚋嚌嚕嚙嚚嚝嚞嚟嚦嚧嚨嚩嚫嚬嚭嚱嚳嚷嚾囅囉囊囋囏囐囌囍囙囜囝囟囡囤", 4, "囱囫园"], ["8fb7a1", "囶囷圁圂圇圊圌圑圕圚圛圝圠圢圣圤圥圩圪圬圮圯圳圴圽圾圿坅坆坌坍坒坢坥坧坨坫坭", 4, "坳坴坵坷坹坺坻坼坾垁垃垌垔垗垙垚垜垝垞垟垡垕垧垨垩垬垸垽埇埈埌埏埕埝埞埤埦埧埩埭埰埵埶埸埽埾埿堃堄堈堉埡"], ["8fb8a1", "堌堍堛堞堟堠堦堧堭堲堹堿塉塌塍塏塐塕塟塡塤塧塨塸塼塿墀墁墇墈墉墊墌墍墏墐墔墖墝墠墡墢墦墩墱墲壄墼壂壈壍壎壐壒壔壖壚壝壡壢壩壳夅夆夋夌夒夓夔虁夝夡夣夤夨夯夰夳夵夶夿奃奆奒奓奙奛奝奞奟奡奣奫奭"], ["8fb9a1", "奯奲奵奶她奻奼妋妌妎妒妕妗妟妤妧妭妮妯妰妳妷妺妼姁姃姄姈姊姍姒姝姞姟姣姤姧姮姯姱姲姴姷娀娄娌娍娎娒娓娞娣娤娧娨娪娭娰婄婅婇婈婌婐婕婞婣婥婧婭婷婺婻婾媋媐媓媖媙媜媞媟媠媢媧媬媱媲媳媵媸媺媻媿"], ["8fbaa1", "嫄嫆嫈嫏嫚嫜嫠嫥嫪嫮嫵嫶嫽嬀嬁嬈嬗嬴嬙嬛嬝嬡嬥嬭嬸孁孋孌孒孖孞孨孮孯孼孽孾孿宁宄宆宊宎宐宑宓宔宖宨宩宬宭宯宱宲宷宺宼寀寁寍寏寖", 4, "寠寯寱寴寽尌尗尞尟尣尦尩尫尬尮尰尲尵尶屙屚屜屢屣屧屨屩"], ["8fbba1", "屭屰屴屵屺屻屼屽岇岈岊岏岒岝岟岠岢岣岦岪岲岴岵岺峉峋峒峝峗峮峱峲峴崁崆崍崒崫崣崤崦崧崱崴崹崽崿嵂嵃嵆嵈嵕嵑嵙嵊嵟嵠嵡嵢嵤嵪嵭嵰嵹嵺嵾嵿嶁嶃嶈嶊嶒嶓嶔嶕嶙嶛嶟嶠嶧嶫嶰嶴嶸嶹巃巇巋巐巎巘巙巠巤"], ["8fbca1", "巩巸巹帀帇帍帒帔帕帘帟帠帮帨帲帵帾幋幐幉幑幖幘幛幜幞幨幪", 4, "幰庀庋庎庢庤庥庨庪庬庱庳庽庾庿廆廌廋廎廑廒廔廕廜廞廥廫异弆弇弈弎弙弜弝弡弢弣弤弨弫弬弮弰弴弶弻弽弿彀彄彅彇彍彐彔彘彛彠彣彤彧"], ["8fbda1", "彯彲彴彵彸彺彽彾徉徍徏徖徜徝徢徧徫徤徬徯徰徱徸忄忇忈忉忋忐", 4, "忞忡忢忨忩忪忬忭忮忯忲忳忶忺忼怇怊怍怓怔怗怘怚怟怤怭怳怵恀恇恈恉恌恑恔恖恗恝恡恧恱恾恿悂悆悈悊悎悑悓悕悘悝悞悢悤悥您悰悱悷"], ["8fbea1", "悻悾惂惄惈惉惊惋惎惏惔惕惙惛惝惞惢惥惲惵惸惼惽愂愇愊愌愐", 4, "愖愗愙愜愞愢愪愫愰愱愵愶愷愹慁慅慆慉慞慠慬慲慸慻慼慿憀憁憃憄憋憍憒憓憗憘憜憝憟憠憥憨憪憭憸憹憼懀懁懂懎懏懕懜懝懞懟懡懢懧懩懥"], ["8fbfa1", "懬懭懯戁戃戄戇戓戕戜戠戢戣戧戩戫戹戽扂扃扄扆扌扐扑扒扔扖扚扜扤扭扯扳扺扽抍抎抏抐抦抨抳抶抷抺抾抿拄拎拕拖拚拪拲拴拼拽挃挄挊挋挍挐挓挖挘挩挪挭挵挶挹挼捁捂捃捄捆捊捋捎捒捓捔捘捛捥捦捬捭捱捴捵"], ["8fc0a1", "捸捼捽捿掂掄掇掊掐掔掕掙掚掞掤掦掭掮掯掽揁揅揈揎揑揓揔揕揜揠揥揪揬揲揳揵揸揹搉搊搐搒搔搘搞搠搢搤搥搩搪搯搰搵搽搿摋摏摑摒摓摔摚摛摜摝摟摠摡摣摭摳摴摻摽撅撇撏撐撑撘撙撛撝撟撡撣撦撨撬撳撽撾撿"], ["8fc1a1", "擄擉擊擋擌擎擐擑擕擗擤擥擩擪擭擰擵擷擻擿攁攄攈攉攊攏攓攔攖攙攛攞攟攢攦攩攮攱攺攼攽敃敇敉敐敒敔敟敠敧敫敺敽斁斅斊斒斕斘斝斠斣斦斮斲斳斴斿旂旈旉旎旐旔旖旘旟旰旲旴旵旹旾旿昀昄昈昉昍昑昒昕昖昝"], ["8fc2a1", "昞昡昢昣昤昦昩昪昫昬昮昰昱昳昹昷晀晅晆晊晌晑晎晗晘晙晛晜晠晡曻晪晫晬晾晳晵晿晷晸晹晻暀晼暋暌暍暐暒暙暚暛暜暟暠暤暭暱暲暵暻暿曀曂曃曈曌曎曏曔曛曟曨曫曬曮曺朅朇朎朓朙朜朠朢朳朾杅杇杈杌杔杕杝"], ["8fc3a1", "杦杬杮杴杶杻极构枎枏枑枓枖枘枙枛枰枱枲枵枻枼枽柹柀柂柃柅柈柉柒柗柙柜柡柦柰柲柶柷桒栔栙栝栟栨栧栬栭栯栰栱栳栻栿桄桅桊桌桕桗桘桛桫桮", 4, "桵桹桺桻桼梂梄梆梈梖梘梚梜梡梣梥梩梪梮梲梻棅棈棌棏"], ["8fc4a1", "棐棑棓棖棙棜棝棥棨棪棫棬棭棰棱棵棶棻棼棽椆椉椊椐椑椓椖椗椱椳椵椸椻楂楅楉楎楗楛楣楤楥楦楨楩楬楰楱楲楺楻楿榀榍榒榖榘榡榥榦榨榫榭榯榷榸榺榼槅槈槑槖槗槢槥槮槯槱槳槵槾樀樁樃樏樑樕樚樝樠樤樨樰樲"], ["8fc5a1", "樴樷樻樾樿橅橆橉橊橎橐橑橒橕橖橛橤橧橪橱橳橾檁檃檆檇檉檋檑檛檝檞檟檥檫檯檰檱檴檽檾檿櫆櫉櫈櫌櫐櫔櫕櫖櫜櫝櫤櫧櫬櫰櫱櫲櫼櫽欂欃欆欇欉欏欐欑欗欛欞欤欨欫欬欯欵欶欻欿歆歊歍歒歖歘歝歠歧歫歮歰歵歽"], ["8fc6a1", "歾殂殅殗殛殟殠殢殣殨殩殬殭殮殰殸殹殽殾毃毄毉毌毖毚毡毣毦毧毮毱毷毹毿氂氄氅氉氍氎氐氒氙氟氦氧氨氬氮氳氵氶氺氻氿汊汋汍汏汒汔汙汛汜汫汭汯汴汶汸汹汻沅沆沇沉沔沕沗沘沜沟沰沲沴泂泆泍泏泐泑泒泔泖"], ["8fc7a1", "泚泜泠泧泩泫泬泮泲泴洄洇洊洎洏洑洓洚洦洧洨汧洮洯洱洹洼洿浗浞浟浡浥浧浯浰浼涂涇涑涒涔涖涗涘涪涬涴涷涹涽涿淄淈淊淎淏淖淛淝淟淠淢淥淩淯淰淴淶淼渀渄渞渢渧渲渶渹渻渼湄湅湈湉湋湏湑湒湓湔湗湜湝湞"], ["8fc8a1", "湢湣湨湳湻湽溍溓溙溠溧溭溮溱溳溻溿滀滁滃滇滈滊滍滎滏滫滭滮滹滻滽漄漈漊漌漍漖漘漚漛漦漩漪漯漰漳漶漻漼漭潏潑潒潓潗潙潚潝潞潡潢潨潬潽潾澃澇澈澋澌澍澐澒澓澔澖澚澟澠澥澦澧澨澮澯澰澵澶澼濅濇濈濊"], ["8fc9a1", "濚濞濨濩濰濵濹濼濽瀀瀅瀆瀇瀍瀗瀠瀣瀯瀴瀷瀹瀼灃灄灈灉灊灋灔灕灝灞灎灤灥灬灮灵灶灾炁炅炆炔", 4, "炛炤炫炰炱炴炷烊烑烓烔烕烖烘烜烤烺焃", 4, "焋焌焏焞焠焫焭焯焰焱焸煁煅煆煇煊煋煐煒煗煚煜煞煠"], ["8fcaa1", "煨煹熀熅熇熌熒熚熛熠熢熯熰熲熳熺熿燀燁燄燋燌燓燖燙燚燜燸燾爀爇爈爉爓爗爚爝爟爤爫爯爴爸爹牁牂牃牅牎牏牐牓牕牖牚牜牞牠牣牨牫牮牯牱牷牸牻牼牿犄犉犍犎犓犛犨犭犮犱犴犾狁狇狉狌狕狖狘狟狥狳狴狺狻"], ["8fcba1", "狾猂猄猅猇猋猍猒猓猘猙猞猢猤猧猨猬猱猲猵猺猻猽獃獍獐獒獖獘獝獞獟獠獦獧獩獫獬獮獯獱獷獹獼玀玁玃玅玆玎玐玓玕玗玘玜玞玟玠玢玥玦玪玫玭玵玷玹玼玽玿珅珆珉珋珌珏珒珓珖珙珝珡珣珦珧珩珴珵珷珹珺珻珽"], ["8fcca1", "珿琀琁琄琇琊琑琚琛琤琦琨", 9, "琹瑀瑃瑄瑆瑇瑋瑍瑑瑒瑗瑝瑢瑦瑧瑨瑫瑭瑮瑱瑲璀璁璅璆璇璉璏璐璑璒璘璙璚璜璟璠璡璣璦璨璩璪璫璮璯璱璲璵璹璻璿瓈瓉瓌瓐瓓瓘瓚瓛瓞瓟瓤瓨瓪瓫瓯瓴瓺瓻瓼瓿甆"], ["8fcda1", "甒甖甗甠甡甤甧甩甪甯甶甹甽甾甿畀畃畇畈畎畐畒畗畞畟畡畯畱畹", 5, "疁疅疐疒疓疕疙疜疢疤疴疺疿痀痁痄痆痌痎痏痗痜痟痠痡痤痧痬痮痯痱痹瘀瘂瘃瘄瘇瘈瘊瘌瘏瘒瘓瘕瘖瘙瘛瘜瘝瘞瘣瘥瘦瘩瘭瘲瘳瘵瘸瘹"], ["8fcea1", "瘺瘼癊癀癁癃癄癅癉癋癕癙癟癤癥癭癮癯癱癴皁皅皌皍皕皛皜皝皟皠皢", 6, "皪皭皽盁盅盉盋盌盎盔盙盠盦盨盬盰盱盶盹盼眀眆眊眎眒眔眕眗眙眚眜眢眨眭眮眯眴眵眶眹眽眾睂睅睆睊睍睎睏睒睖睗睜睞睟睠睢"], ["8fcfa1", "睤睧睪睬睰睲睳睴睺睽瞀瞄瞌瞍瞔瞕瞖瞚瞟瞢瞧瞪瞮瞯瞱瞵瞾矃矉矑矒矕矙矞矟矠矤矦矪矬矰矱矴矸矻砅砆砉砍砎砑砝砡砢砣砭砮砰砵砷硃硄硇硈硌硎硒硜硞硠硡硣硤硨硪确硺硾碊碏碔碘碡碝碞碟碤碨碬碭碰碱碲碳"], ["8fd0a1", "碻碽碿磇磈磉磌磎磒磓磕磖磤磛磟磠磡磦磪磲磳礀磶磷磺磻磿礆礌礐礚礜礞礟礠礥礧礩礭礱礴礵礻礽礿祄祅祆祊祋祏祑祔祘祛祜祧祩祫祲祹祻祼祾禋禌禑禓禔禕禖禘禛禜禡禨禩禫禯禱禴禸离秂秄秇秈秊秏秔秖秚秝秞"], ["8fd1a1", "秠秢秥秪秫秭秱秸秼稂稃稇稉稊稌稑稕稛稞稡稧稫稭稯稰稴稵稸稹稺穄穅穇穈穌穕穖穙穜穝穟穠穥穧穪穭穵穸穾窀窂窅窆窊窋窐窑窔窞窠窣窬窳窵窹窻窼竆竉竌竎竑竛竨竩竫竬竱竴竻竽竾笇笔笟笣笧笩笪笫笭笮笯笰"], ["8fd2a1", "笱笴笽笿筀筁筇筎筕筠筤筦筩筪筭筯筲筳筷箄箉箎箐箑箖箛箞箠箥箬箯箰箲箵箶箺箻箼箽篂篅篈篊篔篖篗篙篚篛篨篪篲篴篵篸篹篺篼篾簁簂簃簄簆簉簋簌簎簏簙簛簠簥簦簨簬簱簳簴簶簹簺籆籊籕籑籒籓籙", 5], ["8fd3a1", "籡籣籧籩籭籮籰籲籹籼籽粆粇粏粔粞粠粦粰粶粷粺粻粼粿糄糇糈糉糍糏糓糔糕糗糙糚糝糦糩糫糵紃紇紈紉紏紑紒紓紖紝紞紣紦紪紭紱紼紽紾絀絁絇絈絍絑絓絗絙絚絜絝絥絧絪絰絸絺絻絿綁綂綃綅綆綈綋綌綍綑綖綗綝"], ["8fd4a1", "綞綦綧綪綳綶綷綹緂", 4, "緌緍緎緗緙縀緢緥緦緪緫緭緱緵緶緹緺縈縐縑縕縗縜縝縠縧縨縬縭縯縳縶縿繄繅繇繎繐繒繘繟繡繢繥繫繮繯繳繸繾纁纆纇纊纍纑纕纘纚纝纞缼缻缽缾缿罃罄罇罏罒罓罛罜罝罡罣罤罥罦罭"], ["8fd5a1", "罱罽罾罿羀羋羍羏羐羑羖羗羜羡羢羦羪羭羴羼羿翀翃翈翎翏翛翟翣翥翨翬翮翯翲翺翽翾翿耇耈耊耍耎耏耑耓耔耖耝耞耟耠耤耦耬耮耰耴耵耷耹耺耼耾聀聄聠聤聦聭聱聵肁肈肎肜肞肦肧肫肸肹胈胍胏胒胔胕胗胘胠胭胮"], ["8fd6a1", "胰胲胳胶胹胺胾脃脋脖脗脘脜脞脠脤脧脬脰脵脺脼腅腇腊腌腒腗腠腡腧腨腩腭腯腷膁膐膄膅膆膋膎膖膘膛膞膢膮膲膴膻臋臃臅臊臎臏臕臗臛臝臞臡臤臫臬臰臱臲臵臶臸臹臽臿舀舃舏舓舔舙舚舝舡舢舨舲舴舺艃艄艅艆"], ["8fd7a1", "艋艎艏艑艖艜艠艣艧艭艴艻艽艿芀芁芃芄芇芉芊芎芑芔芖芘芚芛芠芡芣芤芧芨芩芪芮芰芲芴芷芺芼芾芿苆苐苕苚苠苢苤苨苪苭苯苶苷苽苾茀茁茇茈茊茋荔茛茝茞茟茡茢茬茭茮茰茳茷茺茼茽荂荃荄荇荍荎荑荕荖荗荰荸"], ["8fd8a1", "荽荿莀莂莄莆莍莒莔莕莘莙莛莜莝莦莧莩莬莾莿菀菇菉菏菐菑菔菝荓菨菪菶菸菹菼萁萆萊萏萑萕萙莭萯萹葅葇葈葊葍葏葑葒葖葘葙葚葜葠葤葥葧葪葰葳葴葶葸葼葽蒁蒅蒒蒓蒕蒞蒦蒨蒩蒪蒯蒱蒴蒺蒽蒾蓀蓂蓇蓈蓌蓏蓓"], ["8fd9a1", "蓜蓧蓪蓯蓰蓱蓲蓷蔲蓺蓻蓽蔂蔃蔇蔌蔎蔐蔜蔞蔢蔣蔤蔥蔧蔪蔫蔯蔳蔴蔶蔿蕆蕏", 4, "蕖蕙蕜", 6, "蕤蕫蕯蕹蕺蕻蕽蕿薁薅薆薉薋薌薏薓薘薝薟薠薢薥薧薴薶薷薸薼薽薾薿藂藇藊藋藎薭藘藚藟藠藦藨藭藳藶藼"], ["8fdaa1", "藿蘀蘄蘅蘍蘎蘐蘑蘒蘘蘙蘛蘞蘡蘧蘩蘶蘸蘺蘼蘽虀虂虆虒虓虖虗虘虙虝虠", 4, "虩虬虯虵虶虷虺蚍蚑蚖蚘蚚蚜蚡蚦蚧蚨蚭蚱蚳蚴蚵蚷蚸蚹蚿蛀蛁蛃蛅蛑蛒蛕蛗蛚蛜蛠蛣蛥蛧蚈蛺蛼蛽蜄蜅蜇蜋蜎蜏蜐蜓蜔蜙蜞蜟蜡蜣"], ["8fdba1", "蜨蜮蜯蜱蜲蜹蜺蜼蜽蜾蝀蝃蝅蝍蝘蝝蝡蝤蝥蝯蝱蝲蝻螃", 6, "螋螌螐螓螕螗螘螙螞螠螣螧螬螭螮螱螵螾螿蟁蟈蟉蟊蟎蟕蟖蟙蟚蟜蟟蟢蟣蟤蟪蟫蟭蟱蟳蟸蟺蟿蠁蠃蠆蠉蠊蠋蠐蠙蠒蠓蠔蠘蠚蠛蠜蠞蠟蠨蠭蠮蠰蠲蠵"], ["8fdca1", "蠺蠼衁衃衅衈衉衊衋衎衑衕衖衘衚衜衟衠衤衩衱衹衻袀袘袚袛袜袟袠袨袪袺袽袾裀裊", 4, "裑裒裓裛裞裧裯裰裱裵裷褁褆褍褎褏褕褖褘褙褚褜褠褦褧褨褰褱褲褵褹褺褾襀襂襅襆襉襏襒襗襚襛襜襡襢襣襫襮襰襳襵襺"], ["8fdda1", "襻襼襽覉覍覐覔覕覛覜覟覠覥覰覴覵覶覷覼觔", 4, "觥觩觫觭觱觳觶觹觽觿訄訅訇訏訑訒訔訕訞訠訢訤訦訫訬訯訵訷訽訾詀詃詅詇詉詍詎詓詖詗詘詜詝詡詥詧詵詶詷詹詺詻詾詿誀誃誆誋誏誐誒誖誗誙誟誧誩誮誯誳"], ["8fdea1", "誶誷誻誾諃諆諈諉諊諑諓諔諕諗諝諟諬諰諴諵諶諼諿謅謆謋謑謜謞謟謊謭謰謷謼譂", 4, "譈譒譓譔譙譍譞譣譭譶譸譹譼譾讁讄讅讋讍讏讔讕讜讞讟谸谹谽谾豅豇豉豋豏豑豓豔豗豘豛豝豙豣豤豦豨豩豭豳豵豶豻豾貆"], ["8fdfa1", "貇貋貐貒貓貙貛貜貤貹貺賅賆賉賋賏賖賕賙賝賡賨賬賯賰賲賵賷賸賾賿贁贃贉贒贗贛赥赩赬赮赿趂趄趈趍趐趑趕趞趟趠趦趫趬趯趲趵趷趹趻跀跅跆跇跈跊跎跑跔跕跗跙跤跥跧跬跰趼跱跲跴跽踁踄踅踆踋踑踔踖踠踡踢"], ["8fe0a1", "踣踦踧踱踳踶踷踸踹踽蹀蹁蹋蹍蹎蹏蹔蹛蹜蹝蹞蹡蹢蹩蹬蹭蹯蹰蹱蹹蹺蹻躂躃躉躐躒躕躚躛躝躞躢躧躩躭躮躳躵躺躻軀軁軃軄軇軏軑軔軜軨軮軰軱軷軹軺軭輀輂輇輈輏輐輖輗輘輞輠輡輣輥輧輨輬輭輮輴輵輶輷輺轀轁"], ["8fe1a1", "轃轇轏轑", 4, "轘轝轞轥辝辠辡辤辥辦辵辶辸达迀迁迆迊迋迍运迒迓迕迠迣迤迨迮迱迵迶迻迾适逄逈逌逘逛逨逩逯逪逬逭逳逴逷逿遃遄遌遛遝遢遦遧遬遰遴遹邅邈邋邌邎邐邕邗邘邙邛邠邡邢邥邰邲邳邴邶邽郌邾郃"], ["8fe2a1", "郄郅郇郈郕郗郘郙郜郝郟郥郒郶郫郯郰郴郾郿鄀鄄鄅鄆鄈鄍鄐鄔鄖鄗鄘鄚鄜鄞鄠鄥鄢鄣鄧鄩鄮鄯鄱鄴鄶鄷鄹鄺鄼鄽酃酇酈酏酓酗酙酚酛酡酤酧酭酴酹酺酻醁醃醅醆醊醎醑醓醔醕醘醞醡醦醨醬醭醮醰醱醲醳醶醻醼醽醿"], ["8fe3a1", "釂釃釅釓釔釗釙釚釞釤釥釩釪釬", 5, "釷釹釻釽鈀鈁鈄鈅鈆鈇鈉鈊鈌鈐鈒鈓鈖鈘鈜鈝鈣鈤鈥鈦鈨鈮鈯鈰鈳鈵鈶鈸鈹鈺鈼鈾鉀鉂鉃鉆鉇鉊鉍鉎鉏鉑鉘鉙鉜鉝鉠鉡鉥鉧鉨鉩鉮鉯鉰鉵", 4, "鉻鉼鉽鉿銈銉銊銍銎銒銗"], ["8fe4a1", "銙銟銠銤銥銧銨銫銯銲銶銸銺銻銼銽銿", 4, "鋅鋆鋇鋈鋋鋌鋍鋎鋐鋓鋕鋗鋘鋙鋜鋝鋟鋠鋡鋣鋥鋧鋨鋬鋮鋰鋹鋻鋿錀錂錈錍錑錔錕錜錝錞錟錡錤錥錧錩錪錳錴錶錷鍇鍈鍉鍐鍑鍒鍕鍗鍘鍚鍞鍤鍥鍧鍩鍪鍭鍯鍰鍱鍳鍴鍶"], ["8fe5a1", "鍺鍽鍿鎀鎁鎂鎈鎊鎋鎍鎏鎒鎕鎘鎛鎞鎡鎣鎤鎦鎨鎫鎴鎵鎶鎺鎩鏁鏄鏅鏆鏇鏉", 4, "鏓鏙鏜鏞鏟鏢鏦鏧鏹鏷鏸鏺鏻鏽鐁鐂鐄鐈鐉鐍鐎鐏鐕鐖鐗鐟鐮鐯鐱鐲鐳鐴鐻鐿鐽鑃鑅鑈鑊鑌鑕鑙鑜鑟鑡鑣鑨鑫鑭鑮鑯鑱鑲钄钃镸镹"], ["8fe6a1", "镾閄閈閌閍閎閝閞閟閡閦閩閫閬閴閶閺閽閿闆闈闉闋闐闑闒闓闙闚闝闞闟闠闤闦阝阞阢阤阥阦阬阱阳阷阸阹阺阼阽陁陒陔陖陗陘陡陮陴陻陼陾陿隁隂隃隄隉隑隖隚隝隟隤隥隦隩隮隯隳隺雊雒嶲雘雚雝雞雟雩雯雱雺霂"], ["8fe7a1", "霃霅霉霚霛霝霡霢霣霨霱霳靁靃靊靎靏靕靗靘靚靛靣靧靪靮靳靶靷靸靻靽靿鞀鞉鞕鞖鞗鞙鞚鞞鞟鞢鞬鞮鞱鞲鞵鞶鞸鞹鞺鞼鞾鞿韁韄韅韇韉韊韌韍韎韐韑韔韗韘韙韝韞韠韛韡韤韯韱韴韷韸韺頇頊頙頍頎頔頖頜頞頠頣頦"], ["8fe8a1", "頫頮頯頰頲頳頵頥頾顄顇顊顑顒顓顖顗顙顚顢顣顥顦顪顬颫颭颮颰颴颷颸颺颻颿飂飅飈飌飡飣飥飦飧飪飳飶餂餇餈餑餕餖餗餚餛餜餟餢餦餧餫餱", 4, "餹餺餻餼饀饁饆饇饈饍饎饔饘饙饛饜饞饟饠馛馝馟馦馰馱馲馵"], ["8fe9a1", "馹馺馽馿駃駉駓駔駙駚駜駞駧駪駫駬駰駴駵駹駽駾騂騃騄騋騌騐騑騖騞騠騢騣騤騧騭騮騳騵騶騸驇驁驄驊驋驌驎驑驔驖驝骪骬骮骯骲骴骵骶骹骻骾骿髁髃髆髈髎髐髒髕髖髗髛髜髠髤髥髧髩髬髲髳髵髹髺髽髿", 4], ["8feaa1", "鬄鬅鬈鬉鬋鬌鬍鬎鬐鬒鬖鬙鬛鬜鬠鬦鬫鬭鬳鬴鬵鬷鬹鬺鬽魈魋魌魕魖魗魛魞魡魣魥魦魨魪", 4, "魳魵魷魸魹魿鮀鮄鮅鮆鮇鮉鮊鮋鮍鮏鮐鮔鮚鮝鮞鮦鮧鮩鮬鮰鮱鮲鮷鮸鮻鮼鮾鮿鯁鯇鯈鯎鯐鯗鯘鯝鯟鯥鯧鯪鯫鯯鯳鯷鯸"], ["8feba1", "鯹鯺鯽鯿鰀鰂鰋鰏鰑鰖鰘鰙鰚鰜鰞鰢鰣鰦", 4, "鰱鰵鰶鰷鰽鱁鱃鱄鱅鱉鱊鱎鱏鱐鱓鱔鱖鱘鱛鱝鱞鱟鱣鱩鱪鱜鱫鱨鱮鱰鱲鱵鱷鱻鳦鳲鳷鳹鴋鴂鴑鴗鴘鴜鴝鴞鴯鴰鴲鴳鴴鴺鴼鵅鴽鵂鵃鵇鵊鵓鵔鵟鵣鵢鵥鵩鵪鵫鵰鵶鵷鵻"], ["8feca1", "鵼鵾鶃鶄鶆鶊鶍鶎鶒鶓鶕鶖鶗鶘鶡鶪鶬鶮鶱鶵鶹鶼鶿鷃鷇鷉鷊鷔鷕鷖鷗鷚鷞鷟鷠鷥鷧鷩鷫鷮鷰鷳鷴鷾鸊鸂鸇鸎鸐鸑鸒鸕鸖鸙鸜鸝鹺鹻鹼麀麂麃麄麅麇麎麏麖麘麛麞麤麨麬麮麯麰麳麴麵黆黈黋黕黟黤黧黬黭黮黰黱黲黵"], ["8feda1", "黸黿鼂鼃鼉鼏鼐鼑鼒鼔鼖鼗鼙鼚鼛鼟鼢鼦鼪鼫鼯鼱鼲鼴鼷鼹鼺鼼鼽鼿齁齃", 4, "齓齕齖齗齘齚齝齞齨齩齭", 4, "齳齵齺齽龏龐龑龒龔龖龗龞龡龢龣龥"]];
    }, {}],
    24: [function (require, module, exports) {
      module.exports = {
        "uChars": [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536],
        "gbChars": [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000]
      };
    }, {}],
    25: [function (require, module, exports) {
      module.exports = [["a140", "", 62], ["a180", "", 32], ["a240", "", 62], ["a280", "", 32], ["a2ab", "", 5], ["a2e3", "€"], ["a2ef", ""], ["a2fd", ""], ["a340", "", 62], ["a380", "", 31, "　"], ["a440", "", 62], ["a480", "", 32], ["a4f4", "", 10], ["a540", "", 62], ["a580", "", 32], ["a5f7", "", 7], ["a640", "", 62], ["a680", "", 32], ["a6b9", "", 7], ["a6d9", "", 6], ["a6ec", ""], ["a6f3", ""], ["a6f6", "", 8], ["a740", "", 62], ["a780", "", 32], ["a7c2", "", 14], ["a7f2", "", 12], ["a896", "", 10], ["a8bc", ""], ["a8bf", "ǹ"], ["a8c1", ""], ["a8ea", "", 20], ["a958", ""], ["a95b", ""], ["a95d", ""], ["a989", "〾⿰", 11], ["a997", "", 12], ["a9f0", "", 14], ["aaa1", "", 93], ["aba1", "", 93], ["aca1", "", 93], ["ada1", "", 93], ["aea1", "", 93], ["afa1", "", 93], ["d7fa", "", 4], ["f8a1", "", 93], ["f9a1", "", 93], ["faa1", "", 93], ["fba1", "", 93], ["fca1", "", 93], ["fda1", "", 93], ["fe50", "⺁⺄㑳㑇⺈⺋㖞㘚㘎⺌⺗㥮㤘㧏㧟㩳㧐㭎㱮㳠⺧⺪䁖䅟⺮䌷⺳⺶⺷䎱䎬⺻䏝䓖䙡䙌"], ["fe80", "䜣䜩䝼䞍⻊䥇䥺䥽䦂䦃䦅䦆䦟䦛䦷䦶䲣䲟䲠䲡䱷䲢䴓", 6, "䶮", 93]];
    }, {}],
    26: [function (require, module, exports) {
      module.exports = [["0", "\0", 128], ["a1", "｡", 62], ["8140", "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈", 9, "＋－±×"], ["8180", "÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇◆□■△▲▽▼※〒→←↑↓〓"], ["81b8", "∈∋⊆⊇⊂⊃∪∩"], ["81c8", "∧∨￢⇒⇔∀∃"], ["81da", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"], ["81f0", "Å‰♯♭♪†‡¶"], ["81fc", "◯"], ["824f", "０", 9], ["8260", "Ａ", 25], ["8281", "ａ", 25], ["829f", "ぁ", 82], ["8340", "ァ", 62], ["8380", "ム", 22], ["839f", "Α", 16, "Σ", 6], ["83bf", "α", 16, "σ", 6], ["8440", "А", 5, "ЁЖ", 25], ["8470", "а", 5, "ёж", 7], ["8480", "о", 17], ["849f", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"], ["8740", "①", 19, "Ⅰ", 9], ["875f", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"], ["877e", "㍻"], ["8780", "〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"], ["889f", "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"], ["8940", "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円"], ["8980", "園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"], ["8a40", "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫"], ["8a80", "橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"], ["8b40", "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救"], ["8b80", "朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"], ["8c40", "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨"], ["8c80", "劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"], ["8d40", "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降"], ["8d80", "項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"], ["8e40", "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止"], ["8e80", "死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"], ["8f40", "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳"], ["8f80", "準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"], ["9040", "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨"], ["9080", "逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"], ["9140", "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻"], ["9180", "操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"], ["9240", "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄"], ["9280", "逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"], ["9340", "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬"], ["9380", "凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"], ["9440", "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅"], ["9480", "楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"], ["9540", "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷"], ["9580", "斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"], ["9640", "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆"], ["9680", "摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"], ["9740", "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲"], ["9780", "沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"], ["9840", "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"], ["989f", "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"], ["9940", "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭"], ["9980", "凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"], ["9a40", "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸"], ["9a80", "噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"], ["9b40", "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀"], ["9b80", "它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"], ["9c40", "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠"], ["9c80", "怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"], ["9d40", "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫"], ["9d80", "捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"], ["9e40", "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎"], ["9e80", "梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"], ["9f40", "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯"], ["9f80", "麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"], ["e040", "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝"], ["e080", "烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"], ["e140", "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿"], ["e180", "痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"], ["e240", "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰"], ["e280", "窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"], ["e340", "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷"], ["e380", "縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"], ["e440", "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤"], ["e480", "艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"], ["e540", "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬"], ["e580", "蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"], ["e640", "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧"], ["e680", "諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"], ["e740", "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜"], ["e780", "轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"], ["e840", "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙"], ["e880", "閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"], ["e940", "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃"], ["e980", "騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"], ["ea40", "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯"], ["ea80", "黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠堯槇遙瑤凜熙"], ["ed40", "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏"], ["ed80", "塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"], ["ee40", "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙"], ["ee80", "蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"], ["eeef", "ⅰ", 9, "￢￤＇＂"], ["f040", "", 62], ["f080", "", 124], ["f140", "", 62], ["f180", "", 124], ["f240", "", 62], ["f280", "", 124], ["f340", "", 62], ["f380", "", 124], ["f440", "", 62], ["f480", "", 124], ["f540", "", 62], ["f580", "", 124], ["f640", "", 62], ["f680", "", 124], ["f740", "", 62], ["f780", "", 124], ["f840", "", 62], ["f880", "", 124], ["f940", ""], ["fa40", "ⅰ", 9, "Ⅰ", 9, "￢￤＇＂㈱№℡∵纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊"], ["fa80", "兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯"], ["fb40", "涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神"], ["fb80", "祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙"], ["fc40", "髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"]];
    }, {}],
    27: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

      // == UTF16-BE codec. ==========================================================

      exports.utf16be = Utf16BECodec;
      function Utf16BECodec() {}
      Utf16BECodec.prototype.encoder = Utf16BEEncoder;
      Utf16BECodec.prototype.decoder = Utf16BEDecoder;
      Utf16BECodec.prototype.bomAware = true;

      // -- Encoding

      function Utf16BEEncoder() {}
      Utf16BEEncoder.prototype.write = function (str) {
        var buf = Buffer.from(str, 'ucs2');
        for (var i = 0; i < buf.length; i += 2) {
          var tmp = buf[i];
          buf[i] = buf[i + 1];
          buf[i + 1] = tmp;
        }
        return buf;
      };
      Utf16BEEncoder.prototype.end = function () {};

      // -- Decoding

      function Utf16BEDecoder() {
        this.overflowByte = -1;
      }
      Utf16BEDecoder.prototype.write = function (buf) {
        if (buf.length == 0) return '';
        var buf2 = Buffer.alloc(buf.length + 1),
          i = 0,
          j = 0;
        if (this.overflowByte !== -1) {
          buf2[0] = buf[0];
          buf2[1] = this.overflowByte;
          i = 1;
          j = 2;
        }
        for (; i < buf.length - 1; i += 2, j += 2) {
          buf2[j] = buf[i + 1];
          buf2[j + 1] = buf[i];
        }
        this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
        return buf2.slice(0, j).toString('ucs2');
      };
      Utf16BEDecoder.prototype.end = function () {};

      // == UTF-16 codec =============================================================
      // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
      // Defaults to UTF-16LE, as it's prevalent and default in Node.
      // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
      // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

      // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

      exports.utf16 = Utf16Codec;
      function Utf16Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf16Codec.prototype.encoder = Utf16Encoder;
      Utf16Codec.prototype.decoder = Utf16Decoder;

      // -- Encoding (pass-through)

      function Utf16Encoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder('utf-16le', options);
      }
      Utf16Encoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf16Encoder.prototype.end = function () {
        return this.encoder.end();
      };

      // -- Decoding

      function Utf16Decoder(options, codec) {
        this.decoder = null;
        this.initialBytes = [];
        this.initialBytesLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf16Decoder.prototype.write = function (buf) {
        if (!this.decoder) {
          // Codec is not chosen yet. Accumulate initial bytes.
          this.initialBytes.push(buf);
          this.initialBytesLen += buf.length;
          if (this.initialBytesLen < 16)
            // We need more bytes to use space heuristic (see below)
            return '';

          // We have enough bytes -> detect endianness.
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          this.initialBytes.length = this.initialBytesLen = 0;
        }
        return this.decoder.write(buf);
      };
      Utf16Decoder.prototype.end = function () {
        if (!this.decoder) {
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var res = this.decoder.write(buf),
            trail = this.decoder.end();
          return trail ? res + trail : res;
        }
        return this.decoder.end();
      };
      function detectEncoding(buf, defaultEncoding) {
        var enc = defaultEncoding || 'utf-16le';
        if (buf.length >= 2) {
          // Check BOM.
          if (buf[0] == 0xFE && buf[1] == 0xFF)
            // UTF-16BE BOM
            enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE)
            // UTF-16LE BOM
            enc = 'utf-16le';else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0,
              asciiCharsBE = 0,
              // Counts of chars in both positions
              _len = Math.min(buf.length - buf.length % 2, 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
              if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
              if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
            }
            if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
          }
        }
        return enc;
      }
    }, {
      "safer-buffer": 56
    }],
    28: [function (require, module, exports) {
      'use strict';

      var Buffer = require('safer-buffer').Buffer;

      // == UTF32-LE/BE codec. ==========================================================

      exports._utf32 = Utf32Codec;
      function Utf32Codec(codecOptions, iconv) {
        this.iconv = iconv;
        this.bomAware = true;
        this.isLE = codecOptions.isLE;
      }
      exports.utf32le = {
        type: '_utf32',
        isLE: true
      };
      exports.utf32be = {
        type: '_utf32',
        isLE: false
      };

      // Aliases
      exports.ucs4le = 'utf32le';
      exports.ucs4be = 'utf32be';
      Utf32Codec.prototype.encoder = Utf32Encoder;
      Utf32Codec.prototype.decoder = Utf32Decoder;

      // -- Encoding

      function Utf32Encoder(options, codec) {
        this.isLE = codec.isLE;
        this.highSurrogate = 0;
      }
      Utf32Encoder.prototype.write = function (str) {
        var src = Buffer.from(str, 'ucs2');
        var dst = Buffer.alloc(src.length * 2);
        var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
        var offset = 0;
        for (var i = 0; i < src.length; i += 2) {
          var code = src.readUInt16LE(i);
          var isHighSurrogate = 0xD800 <= code && code < 0xDC00;
          var isLowSurrogate = 0xDC00 <= code && code < 0xE000;
          if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
              // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
              // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
              // (technically wrong, but expected by some applications, like Windows file names).
              write32.call(dst, this.highSurrogate, offset);
              offset += 4;
            } else {
              // Create 32-bit value from high and low surrogates;
              var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;
              write32.call(dst, codepoint, offset);
              offset += 4;
              this.highSurrogate = 0;
              continue;
            }
          }
          if (isHighSurrogate) this.highSurrogate = code;else {
            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
            // unpaired high surrogates.
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
          }
        }
        if (offset < dst.length) dst = dst.slice(0, offset);
        return dst;
      };
      Utf32Encoder.prototype.end = function () {
        // Treat any leftover high surrogate as a semi-valid independent character.
        if (!this.highSurrogate) return;
        var buf = Buffer.alloc(4);
        if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);
        this.highSurrogate = 0;
        return buf;
      };

      // -- Decoding

      function Utf32Decoder(options, codec) {
        this.isLE = codec.isLE;
        this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
        this.overflow = null;
      }
      Utf32Decoder.prototype.write = function (src) {
        if (src.length === 0) return '';
        if (this.overflow) src = Buffer.concat([this.overflow, src]);
        var goodLength = src.length - src.length % 4;
        if (src.length !== goodLength) {
          this.overflow = src.slice(goodLength);
          src = src.slice(0, goodLength);
        } else this.overflow = null;
        var dst = Buffer.alloc(goodLength);
        var offset = 0;
        for (var i = 0; i < goodLength; i += 4) {
          var codepoint = this.isLE ? src.readUInt32LE(i) : src.readUInt32BE(i);
          if (codepoint < 0x10000) {
            // Simple 16-bit character
            dst.writeUInt16LE(codepoint, offset);
            offset += 2;
          } else {
            if (codepoint > 0x10FFFF) {
              // Not a valid Unicode codepoint
              dst.writeUInt16LE(this.badChar, offset);
              offset += 2;
            } else {
              // Create high and low surrogates.
              codepoint -= 0x10000;
              var high = 0xD800 | codepoint >> 10;
              var low = 0xDC00 + (codepoint & 0x3FF);
              dst.writeUInt16LE(high, offset);
              offset += 2;
              dst.writeUInt16LE(low, offset);
              offset += 2;
            }
          }
        }
        return dst.slice(0, offset).toString('ucs2');
      };
      Utf32Decoder.prototype.end = function () {
        this.overflow = null;
      };

      // == UTF-32 Auto codec =============================================================
      // Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
      // Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
      // Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

      // Encoder prepends BOM (which can be overridden with (addBOM: false}).

      exports.utf32 = Utf32AutoCodec;
      exports.ucs4 = Utf32AutoCodec;
      function Utf32AutoCodec(options, iconv) {
        this.iconv = iconv;
      }
      Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
      Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

      // -- Encoding

      function Utf32AutoEncoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
      }
      Utf32AutoEncoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf32AutoEncoder.prototype.end = function () {
        return this.encoder.end();
      };

      // -- Decoding

      function Utf32AutoDecoder(options, codec) {
        this.decoder = null;
        this.initialBytes = [];
        this.initialBytesLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf32AutoDecoder.prototype.write = function (buf) {
        if (!this.decoder) {
          // Codec is not chosen yet. Accumulate initial bytes.
          this.initialBytes.push(buf);
          this.initialBytesLen += buf.length;
          if (this.initialBytesLen < 32)
            // We need more bytes to use space heuristic (see below)
            return '';

          // We have enough bytes -> detect endianness.
          var buf2 = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf2, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          this.initialBytes.length = this.initialBytesLen = 0;
        }
        return this.decoder.write(buf);
      };
      Utf32AutoDecoder.prototype.end = function () {
        if (!this.decoder) {
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var res = this.decoder.write(buf),
            trail = this.decoder.end();
          return trail ? res + trail : res;
        }
        return this.decoder.end();
      };
      function detectEncoding(buf, defaultEncoding) {
        var enc = defaultEncoding || 'utf-32le';
        if (buf.length >= 4) {
          // Check BOM.
          if (buf.readUInt32BE(0) === 0xFEFF)
            // UTF-32LE BOM
            enc = 'utf-32be';else if (buf.readUInt32LE(0) === 0xFEFF)
            // UTF-32LE BOM
            enc = 'utf-32le';else {
            // No BOM found. Try to deduce encoding from initial content.
            // Using the wrong endian-ism for UTF-32 will very often result in codepoints that are beyond
            // the valid Unicode limit of 0x10FFFF. That will be used as the primary determinant.
            //
            // Further, we can suppose the content is mostly plain ASCII chars (U+00**).
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var invalidLE = 0,
              invalidBE = 0;
            var asciiCharsLE = 0,
              asciiCharsBE = 0,
              // Counts of chars in both positions
              _len = Math.min(buf.length - buf.length % 4, 128); // Len is always even.

            for (var i = 0; i < _len; i += 4) {
              var b0 = buf[i],
                b1 = buf[i + 1],
                b2 = buf[i + 2],
                b3 = buf[i + 3];
              if (b0 !== 0 || b1 > 0x10) ++invalidBE;
              if (b3 !== 0 || b2 > 0x10) ++invalidLE;
              if (b0 === 0 && b1 === 0 && b2 === 0 && b3 !== 0) asciiCharsBE++;
              if (b0 !== 0 && b1 === 0 && b2 === 0 && b3 === 0) asciiCharsLE++;
            }
            if (invalidBE < invalidLE) enc = 'utf-32be';else if (invalidLE < invalidBE) enc = 'utf-32le';
            if (asciiCharsBE > asciiCharsLE) enc = 'utf-32be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-32le';
          }
        }
        return enc;
      }
    }, {
      "safer-buffer": 56
    }],
    29: [function (require, module, exports) {
      "use strict";

      var Buffer = require("safer-buffer").Buffer;

      // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
      // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

      exports.utf7 = Utf7Codec;
      exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
      function Utf7Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      ;
      Utf7Codec.prototype.encoder = Utf7Encoder;
      Utf7Codec.prototype.decoder = Utf7Decoder;
      Utf7Codec.prototype.bomAware = true;

      // -- Encoding

      var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
      function Utf7Encoder(options, codec) {
        this.iconv = codec.iconv;
      }
      Utf7Encoder.prototype.write = function (str) {
        // Naive implementation.
        // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
        return Buffer.from(str.replace(nonDirectChars, function (chunk) {
          return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
        }.bind(this)));
      };
      Utf7Encoder.prototype.end = function () {};

      // -- Decoding

      function Utf7Decoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = '';
      }
      var base64Regex = /[A-Za-z0-9\/+]/;
      var base64Chars = [];
      for (var i = 0; i < 256; i++) {
        base64Chars[i] = base64Regex.test(String.fromCharCode(i));
      }
      var plusChar = '+'.charCodeAt(0),
        minusChar = '-'.charCodeAt(0),
        andChar = '&'.charCodeAt(0);
      Utf7Decoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.

        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            // We decode base64.
            if (!base64Chars[buf[i]]) {
              // Base64 ended.
              if (i == lastI && buf[i] == minusChar) {
                // "+-" -> "+"
                res += "+";
              } else {
                var b64str = base64Accum + buf.slice(lastI, i).toString();
                res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
              }
              if (buf[i] != minusChar)
                // Minus is absorbed after base64.
                i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = '';
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
          var b64str = base64Accum + buf.slice(lastI).toString();
          var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
          base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7Decoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
      };

      // UTF-7-IMAP codec.
      // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
      // Differences:
      //  * Base64 part is started by "&" instead of "+"
      //  * Direct characters are 0x20-0x7E, except "&" (0x26)
      //  * In Base64, "," is used instead of "/"
      //  * Base64 must not be used to represent direct characters.
      //  * No implicit shift back from Base64 (should always end with '-')
      //  * String must end in non-shifted position.
      //  * "-&" while in base64 is not allowed.

      exports.utf7imap = Utf7IMAPCodec;
      function Utf7IMAPCodec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      ;
      Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
      Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
      Utf7IMAPCodec.prototype.bomAware = true;

      // -- Encoding

      function Utf7IMAPEncoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = Buffer.alloc(6);
        this.base64AccumIdx = 0;
      }
      Utf7IMAPEncoder.prototype.write = function (str) {
        var inBase64 = this.inBase64,
          base64Accum = this.base64Accum,
          base64AccumIdx = this.base64AccumIdx,
          buf = Buffer.alloc(str.length * 5 + 10),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var uChar = str.charCodeAt(i);
          if (0x20 <= uChar && uChar <= 0x7E) {
            // Direct character or '&'.
            if (inBase64) {
              if (base64AccumIdx > 0) {
                bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                base64AccumIdx = 0;
              }
              buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
              inBase64 = false;
            }
            if (!inBase64) {
              buf[bufIdx++] = uChar; // Write direct character

              if (uChar === andChar)
                // Ampersand -> '&-'
                buf[bufIdx++] = minusChar;
            }
          } else {
            // Non-direct character
            if (!inBase64) {
              buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
              inBase64 = true;
            }
            if (inBase64) {
              base64Accum[base64AccumIdx++] = uChar >> 8;
              base64Accum[base64AccumIdx++] = uChar & 0xFF;
              if (base64AccumIdx == base64Accum.length) {
                bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                base64AccumIdx = 0;
              }
            }
          }
        }
        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;
        return buf.slice(0, bufIdx);
      };
      Utf7IMAPEncoder.prototype.end = function () {
        var buf = Buffer.alloc(10),
          bufIdx = 0;
        if (this.inBase64) {
          if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
          this.inBase64 = false;
        }
        return buf.slice(0, bufIdx);
      };

      // -- Decoding

      function Utf7IMAPDecoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = '';
      }
      var base64IMAPChars = base64Chars.slice();
      base64IMAPChars[','.charCodeAt(0)] = true;
      Utf7IMAPDecoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.
        // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            // We decode base64.
            if (!base64IMAPChars[buf[i]]) {
              // Base64 ended.
              if (i == lastI && buf[i] == minusChar) {
                // "&-" -> "&"
                res += "&";
              } else {
                var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
              }
              if (buf[i] != minusChar)
                // Minus may be absorbed after base64.
                i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = '';
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
          var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
          var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
          base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7IMAPDecoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");
        this.inBase64 = false;
        this.base64Accum = '';
        return res;
      };
    }, {
      "safer-buffer": 56
    }],
    30: [function (require, module, exports) {
      "use strict";

      var BOMChar = "\uFEFF";
      exports.PrependBOM = PrependBOMWrapper;
      function PrependBOMWrapper(encoder, options) {
        this.encoder = encoder;
        this.addBOM = true;
      }
      PrependBOMWrapper.prototype.write = function (str) {
        if (this.addBOM) {
          str = BOMChar + str;
          this.addBOM = false;
        }
        return this.encoder.write(str);
      };
      PrependBOMWrapper.prototype.end = function () {
        return this.encoder.end();
      };

      //------------------------------------------------------------------------------

      exports.StripBOM = StripBOMWrapper;
      function StripBOMWrapper(decoder, options) {
        this.decoder = decoder;
        this.pass = false;
        this.options = options || {};
      }
      StripBOMWrapper.prototype.write = function (buf) {
        var res = this.decoder.write(buf);
        if (this.pass || !res) return res;
        if (res[0] === BOMChar) {
          res = res.slice(1);
          if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
        }
        this.pass = true;
        return res;
      };
      StripBOMWrapper.prototype.end = function () {
        return this.decoder.end();
      };
    }, {}],
    31: [function (require, module, exports) {
      (function (process) {
        (function () {
          "use strict";

          // Some environments don't have global Buffer (e.g. React Native).
          // Solution would be installing npm modules "buffer" and "stream" explicitly.
          var Buffer = require("safer-buffer").Buffer;
          var bomHandling = require("./bom-handling"),
            iconv = module.exports;

          // All codecs and aliases are kept here, keyed by encoding name/alias.
          // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
          iconv.encodings = null;

          // Characters emitted in case of error.
          iconv.defaultCharUnicode = '�';
          iconv.defaultCharSingleByte = '?';

          // Public API.
          iconv.encode = function encode(str, encoding, options) {
            str = "" + (str || ""); // Ensure string.

            var encoder = iconv.getEncoder(encoding, options);
            var res = encoder.write(str);
            var trail = encoder.end();
            return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
          };
          iconv.decode = function decode(buf, encoding, options) {
            if (typeof buf === 'string') {
              if (!iconv.skipDecodeWarning) {
                console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
                iconv.skipDecodeWarning = true;
              }
              buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
            }

            var decoder = iconv.getDecoder(encoding, options);
            var res = decoder.write(buf);
            var trail = decoder.end();
            return trail ? res + trail : res;
          };
          iconv.encodingExists = function encodingExists(enc) {
            try {
              iconv.getCodec(enc);
              return true;
            } catch (e) {
              return false;
            }
          };

          // Legacy aliases to convert functions
          iconv.toEncoding = iconv.encode;
          iconv.fromEncoding = iconv.decode;

          // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
          iconv._codecDataCache = {};
          iconv.getCodec = function getCodec(encoding) {
            if (!iconv.encodings) iconv.encodings = require("../encodings"); // Lazy load all encoding definitions.

            // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
            var enc = iconv._canonicalizeEncoding(encoding);

            // Traverse iconv.encodings to find actual codec.
            var codecOptions = {};
            while (true) {
              var codec = iconv._codecDataCache[enc];
              if (codec) return codec;
              var codecDef = iconv.encodings[enc];
              switch (_typeof(codecDef)) {
                case "string":
                  // Direct alias to other encoding.
                  enc = codecDef;
                  break;
                case "object":
                  // Alias with options. Can be layered.
                  for (var key in codecDef) {
                    codecOptions[key] = codecDef[key];
                  }
                  if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                  enc = codecDef.type;
                  break;
                case "function":
                  // Codec itself.
                  if (!codecOptions.encodingName) codecOptions.encodingName = enc;

                  // The codec function must load all tables and return object with .encoder and .decoder methods.
                  // It'll be called only once (for each different options object).
                  codec = new codecDef(codecOptions, iconv);
                  iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                  return codec;
                default:
                  throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
              }
            }
          };
          iconv._canonicalizeEncoding = function (encoding) {
            // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
            return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
          };
          iconv.getEncoder = function getEncoder(encoding, options) {
            var codec = iconv.getCodec(encoding),
              encoder = new codec.encoder(options, codec);
            if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
            return encoder;
          };
          iconv.getDecoder = function getDecoder(encoding, options) {
            var codec = iconv.getCodec(encoding),
              decoder = new codec.decoder(options, codec);
            if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
            return decoder;
          };

          // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
          var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
          if (nodeVer) {
            // Load streaming support in Node v0.10+
            var nodeVerArr = nodeVer.split(".").map(Number);
            if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
              require("./streams")(iconv);
            }

            // Load Node primitive extensions.
            require("./extend-node")(iconv);
          }
          if ("Ā" != "\u0100") {
            console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
          }
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "../encodings": 14,
      "./bom-handling": 30,
      "./extend-node": 5,
      "./streams": 5,
      "_process": 36,
      "safer-buffer": 56
    }],
    32: [function (require, module, exports) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128;
      };
    }, {}],
    33: [function (require, module, exports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function TempCtor() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }, {}],
    34: [function (require, module, exports) {
      //! moment.js
      //! version : 2.29.4
      //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
      //! license : MIT
      //! momentjs.com

      ;
      (function (global, factory) {
        _typeof(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
      })(this, function () {
        'use strict';

        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
        }
        function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
        }
        function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
        }
        function map(arr, fn) {
          var res = [],
            i,
            arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
        }
        function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function some(fun) {
            var t = Object(this),
              len = t.length >>> 0,
              i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m),
              parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
              }),
              isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = hooks.momentProperties = [],
          updateInProgress = false;
        function copyConfig(to, from) {
          var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
            to._i = from._i;
          }
          if (!isUndefined(from._f)) {
            to._f = from._f;
          }
          if (!isUndefined(from._l)) {
            to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
            to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
            to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
            to._locale = from._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from[prop];
              if (!isUndefined(val)) {
                to[prop] = val;
              }
            }
          }
          return to;
        }

        // Moment prototype object
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend(function () {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [],
                arg,
                i,
                key,
                argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = '';
                if (_typeof(arguments[i]) === 'object') {
                  arg += '\n[' + i + '] ';
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ': ' + arguments[0][key] + ', ';
                    }
                  }
                  arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
        }
        function set(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this['_' + i] = prop;
              }
            }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
            prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys;
        if (Object.keys) {
          keys = Object.keys;
        } else {
          keys = function keys(obj) {
            var i,
              res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        };
        function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
          return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
            func = function func() {
              return this[callback]();
            };
          }
          if (token) {
            formatTokenFunctions[token] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(func.apply(this, arguments), token);
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
        }
        function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
            i,
            length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function (mom) {
            var output = '',
              i;
            for (i = 0; i < length; i++) {
              output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
          };
        }

        // format date using native date object
        function formatMoment(m, format) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
          return formatFunctions[format](m);
        }
        function expandFormat(format, locale) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format;
        }
        var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        };
        function longDateFormat(key) {
          var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format || !formatUpper) {
            return format;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
            if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
              return tok.slice(1);
            }
            return tok;
          }).join('');
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = 'Invalid date';
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace('%d', number);
        }
        var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
            normalizedProp,
            prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [],
            u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({
                unit: u,
                priority: priorities[u]
              });
            }
          }
          units.sort(function (a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
            value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function (value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get(this, unit);
            }
          };
        }
        function get(mom, unit) {
          return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
          }
        }

        // MOMENTS

        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (_typeof(units) === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
              i,
              prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/,
          //       0 - 9
          match2 = /\d\d/,
          //      00 - 99
          match3 = /\d{3}/,
          //     000 - 999
          match4 = /\d{4}/,
          //    0000 - 9999
          match6 = /[+-]?\d{6}/,
          // -999999 - 999999
          match1to2 = /\d\d?/,
          //       0 - 99
          match3to4 = /\d\d\d\d?/,
          //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/,
          //   99999 - 999999
          match1to3 = /\d{1,3}/,
          //       0 - 999
          match1to4 = /\d{1,4}/,
          //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/,
          // -999999 - 999999
          matchUnsigned = /\d+/,
          //       0 - inf
          matchSigned = /[+-]?\d+/,
          //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi,
          // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
          // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
          // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          regexes;
        regexes = {};
        function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
          }
          return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }));
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }
        var tokens = {};
        function addParseToken(token, callback) {
          var i,
            func = callback,
            tokenLen;
          if (typeof token === 'string') {
            token = [token];
          }
          if (isNumber(callback)) {
            func = function func(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
          }
        }
        function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
          });
        }
        function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
          }
        }
        var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf;
        if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
        } else {
          indexOf = function indexOf(o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
        });
        addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
        });
        addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
        });
        addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
          defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;
        function localeMonths(m, format) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months['standalone'];
          }
          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
        }
        function localeMonthsShort(m, format) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
        }
        function handleStrictParse(monthName, format, strict) {
          var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
              this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
              regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            // No op
            return mom;
          }
          if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              // TODO: Another silent failure?
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get(this, 'Month');
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
          for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });
        addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
        });
        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);
        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
          var
            // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);
        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6 // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');
        addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
        });
        addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
        });
        addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
        });
        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
        });
        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format, strict) {
          var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
              this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
              this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
              regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
          for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);
        addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
        }
        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
        }
        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);
        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);
        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
            pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);
        function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? 'pm' : 'PM';
          } else {
            return isLower ? 'am' : 'AM';
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };

        // internal storage for locale config files
        var locales = {},
          localeFamilies = {},
          globalLocale;
        function commonPrefix(arr1, arr2) {
          var i,
            minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
          var i = 0,
            j,
            next,
            locale,
            split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));
              if (locale) {
                return locale;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          // Prevent names that look like filesystem paths, i.e contain '/' or '\'
          return name.match('^[^/\\\\]*$') != null;
        }
        function loadLocale(name) {
          var oldLocale = null,
            aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (locales[name] === undefined && typeof module !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = require;
              aliasedRequire('./locale/' + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              // mark as not found to avoid repeating expensive file require call causing high CPU
              // when trying to find en-US, en_US, en-us for every format call
              locales[name] = null; // null means not found
            }
          }

          return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
            } else {
              if (typeof console !== 'undefined' && console.warn) {
                //warn user if arguments are passed but the locale could not be set
                console.warn('Locale ' + key + ' not found. Did you forget to load it?');
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale,
              parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale = loadLocale(config.parentLocale);
                if (locale != null) {
                  parentConfig = locale._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
              });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            // useful for testing
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale,
              tmpLocale,
              parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              // Update existing child locale in-place to avoid memory-leaks
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                // updateLocale is called for creating a new locale
                // Set abbr so it will have a name (getters return
                // undefined otherwise).
                config.abbr = name;
              }
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
          } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }

        // returns locale data
        function getLocale(key) {
          var locale;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
              return locale;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys(locales);
        }
        function checkOverflow(m) {
          var overflow,
            a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
          // iso time formats and regexes
          isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60
          };

        // date from iso format
        function configFromISO(config) {
          var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  // match[2] should be 'T' or space
                  timeFormat = (match[2] || ' ') + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2000 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s.replace(/\([^()]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
              weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
          } else {
            var hm = parseInt(numOffset, 10),
              m = hm % 100,
              h = (hm - m) / 100;
            return h * 60 + m;
          }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        });

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
          var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              // local weekday -- counting starts from beginning of week
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              // default to beginning of week
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;
          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens.length;
          for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token);
              }
              addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
            }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;
          if (meridiem == null) {
            // nothing to do
            return hour;
          }
          if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            // this is not supposed to happen
            return hour;
          }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
          var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
          });
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i,
            format = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format === undefined && input === '') {
            return createInvalid({
              nullInput: true
            });
          }
          if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
            config._d = input;
          } else if (isArray(format)) {
            configFromStringAndArray(config);
          } else if (format) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
            configFromString(config);
          } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};
          if (format === true || format === false) {
            strict = format;
            format = undefined;
          }
          if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
          }
          if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
        }
        var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }),
          prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          });

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }

        // TODO: Use [].sort instead?
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isBefore', args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy('isAfter', args);
        }
        var now = function now() {
          return Date.now ? Date.now() : +new Date();
        };
        var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
        function isDurationValid(m) {
          var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
              }

              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds = +milliseconds + seconds * 1e3 +
          // 1000
          minutes * 6e4 +
          // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
              sign = '+';
            if (offset < 0) {
              offset = -offset;
              sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
          });
        }
        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);
          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
            localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, 'm');
            }
            if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== 'string') {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {},
            other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign,
              h: toInt(match[HOUR]) * sign,
              m: toInt(match[MINUTE]) * sign,
              s: toInt(match[SECOND]) * sign,
              ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign)
            };
          } else if (duration == null) {
            // checks for null or undefined
            duration = {};
          } else if (_typeof(duration) === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, 'M');
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return {
              milliseconds: 0,
              months: 0
            };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
          return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
          if (!mom.isValid()) {
            // No op
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days || months);
          }
        }
        var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');
        function isString(input) {
          return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
          return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
            i,
            property,
            propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input),
            dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function (item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
            i,
            property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        }
        function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = undefined;
              formats = undefined;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = undefined;
            }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case 'year':
              output = monthDiff(this, that) / 12;
              break;
            case 'month':
              output = monthDiff(this, that);
              break;
            case 'quarter':
              output = monthDiff(this, that) / 3;
              break;
            case 'second':
              output = (this - that) / 1e3;
              break;
            // 1000
            case 'minute':
              output = (this - that) / 6e4;
              break;
            // 1000 * 60
            case 'hour':
              output = (this - that) / 36e5;
              break;
            // 1000 * 60 * 60
            case 'day':
              output = (this - that - zoneDelta) / 864e5;
              break;
            // 1000 * 60 * 60 * 24, negate dst
            case 'week':
              output = (this - that - zoneDelta) / 6048e5;
              break;
            // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
        function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }
          if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
          }
          return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
          if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              to: this,
              from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({
              from: this,
              to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
          var newLocaleData;
          if (key === undefined) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
          if (key === undefined) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        });
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year(), 0, 1);
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
            case 'month':
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case 'hour':
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
            case 'minute':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case 'second':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case 'year':
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case 'month':
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case 'day':
            case 'date':
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case 'hour':
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
            case 'minute':
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case 'second':
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1000);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');
        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);
        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
          var era = config._locale.erasParse(input, token, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        });
        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);
        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format) {
          var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (_typeof(eras[i].since)) {
              case 'string':
                // truncate time
                date = hooks(eras[i].since).startOf('day');
                eras[i].since = date.valueOf();
                break;
            }
            switch (_typeof(eras[i].until)) {
              case 'undefined':
                eras[i].until = +Infinity;
                break;
              case 'string':
                // truncate time
                date = hooks(eras[i].until).startOf('day').valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format, strict) {
          var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format) {
                case 'N':
                case 'NN':
                case 'NNN':
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNN':
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case 'NNNNN':
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return '';
        }
        function getEraNarrow() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return '';
        }
        function getEraAbbr() {
          var i,
            l,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return '';
        }
        function getEraYear() {
          var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
        }
        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);
        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
        });
        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);
        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }
        for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
        }
        function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
        }
        var proto = Moment.prototype;
        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
        proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
        proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
        proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
        proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
        function createUnix(input) {
          return createLocal(input * 1000);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format, index, field, setter) {
          var locale = getLocale(),
            utc = createUTC().set(setter, index);
          return locale[field](utc, format);
        }
        function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
            index = format;
            format = undefined;
          }
          format = format || '';
          if (index != null) {
            return get$1(format, index, field, 'month');
          }
          var i,
            out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
          }
          return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (isNumber(format)) {
              index = format;
              format = undefined;
            }
            format = format || '';
          }
          var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];
          if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
        }
        function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
        }
        function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
        }
        function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }
        function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }
        function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }
        getSetGlobalLocale('en', {
          eras: [{
            since: '0001-01-01',
            until: +Infinity,
            offset: 1,
            name: 'Anno Domini',
            narrow: 'AD',
            abbr: 'AD'
          }, {
            since: '0000-12-31',
            until: -Infinity,
            offset: 1,
            name: 'Before Christ',
            narrow: 'BC',
            abbr: 'BC'
          }],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function ordinal(number) {
            var b = number % 10,
              output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
            return number + output;
          }
        });

        // Side effect imports

        hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
        hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;
          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;
          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;
          hours = absFloor(minutes / 60);
          data.hours = hours % 24;
          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;
          data.days = days;
          data.months = months;
          data.years = years;
          return this;
        }
        function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
        }
        function monthsToDays(months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days,
            months,
            milliseconds = this._milliseconds;
          units = normalizeUnits(units);
          if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
              case 'month':
                return months;
              case 'quarter':
                return months / 3;
              case 'year':
                return months / 12;
            }
          } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case 'week':
                return days / 7 + milliseconds / 6048e5;
              case 'day':
                return days + milliseconds / 864e5;
              case 'hour':
                return days * 24 + milliseconds / 36e5;
              case 'minute':
                return days * 1440 + milliseconds / 6e4;
              case 'second':
                return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here
              case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;
              default:
                throw new Error('Unknown unit ' + units);
            }
          }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function () {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y');
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
        }
        function makeGetter(name) {
          return function () {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round,
          thresholds = {
            ss: 44,
            // a few seconds to seconds
            s: 45,
            // seconds to minute
            m: 45,
            // minutes to hour
            h: 22,
            // hours to day
            d: 26,
            // days to month/week
            w: null,
            // weeks to month
            M: 11 // months to year
          };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];
          if (thresholds.w != null) {
            a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
          }
          a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
            return round;
          }
          if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
          }
          return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
            return false;
          }
          if (limit === undefined) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false,
            th = thresholds,
            locale,
            output;
          if (_typeof(argWithSuffix) === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
          }
          if (_typeof(argThresholds) === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);
          if (withSuffix) {
            output = locale.pastFuture(+this, output);
          }
          return locale.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;
          if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
          return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.4';
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
          // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD',
          // <input type="date" />
          TIME: 'HH:mm',
          // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss',
          // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS',
          // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW',
          // <input type="week" />
          MONTH: 'YYYY-MM' // <input type="month" />
        };

        return hooks;
      });
    }, {}],
    35: [function (require, module, exports) {
      (function (process) {
        (function () {
          // 'path' module extracted from Node.js v8.11.1 (only the posix part)
          // transplited with Babel

          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          'use strict';

          function assertPath(path) {
            if (typeof path !== 'string') {
              throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
            }
          }

          // Resolves . and .. elements in a path with directory names
          function normalizeStringPosix(path, allowAboveRoot) {
            var res = '';
            var lastSegmentLength = 0;
            var lastSlash = -1;
            var dots = 0;
            var code;
            for (var i = 0; i <= path.length; ++i) {
              if (i < path.length) code = path.charCodeAt(i);else if (code === 47 /*/*/) break;else code = 47 /*/*/;
              if (code === 47 /*/*/) {
                if (lastSlash === i - 1 || dots === 1) {
                  // NOOP
                } else if (lastSlash !== i - 1 && dots === 2) {
                  if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
                    if (res.length > 2) {
                      var lastSlashIndex = res.lastIndexOf('/');
                      if (lastSlashIndex !== res.length - 1) {
                        if (lastSlashIndex === -1) {
                          res = '';
                          lastSegmentLength = 0;
                        } else {
                          res = res.slice(0, lastSlashIndex);
                          lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                      }
                    } else if (res.length === 2 || res.length === 1) {
                      res = '';
                      lastSegmentLength = 0;
                      lastSlash = i;
                      dots = 0;
                      continue;
                    }
                  }
                  if (allowAboveRoot) {
                    if (res.length > 0) res += '/..';else res = '..';
                    lastSegmentLength = 2;
                  }
                } else {
                  if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
                  lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
              } else if (code === 46 /*.*/ && dots !== -1) {
                ++dots;
              } else {
                dots = -1;
              }
            }
            return res;
          }
          function _format(sep, pathObject) {
            var dir = pathObject.dir || pathObject.root;
            var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
            if (!dir) {
              return base;
            }
            if (dir === pathObject.root) {
              return dir + base;
            }
            return dir + sep + base;
          }
          var posix = {
            // path.resolve([from ...], to)
            resolve: function resolve() {
              var resolvedPath = '';
              var resolvedAbsolute = false;
              var cwd;
              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path;
                if (i >= 0) path = arguments[i];else {
                  if (cwd === undefined) cwd = process.cwd();
                  path = cwd;
                }
                assertPath(path);

                // Skip empty entries
                if (path.length === 0) {
                  continue;
                }
                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
              }

              // At this point the path should be resolved to a full absolute path, but
              // handle relative paths to be safe (might happen when process.cwd() fails)

              // Normalize the path
              resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
              if (resolvedAbsolute) {
                if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
              } else if (resolvedPath.length > 0) {
                return resolvedPath;
              } else {
                return '.';
              }
            },
            normalize: function normalize(path) {
              assertPath(path);
              if (path.length === 0) return '.';
              var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
              var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

              // Normalize the path
              path = normalizeStringPosix(path, !isAbsolute);
              if (path.length === 0 && !isAbsolute) path = '.';
              if (path.length > 0 && trailingSeparator) path += '/';
              if (isAbsolute) return '/' + path;
              return path;
            },
            isAbsolute: function isAbsolute(path) {
              assertPath(path);
              return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
            },

            join: function join() {
              if (arguments.length === 0) return '.';
              var joined;
              for (var i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                assertPath(arg);
                if (arg.length > 0) {
                  if (joined === undefined) joined = arg;else joined += '/' + arg;
                }
              }
              if (joined === undefined) return '.';
              return posix.normalize(joined);
            },
            relative: function relative(from, to) {
              assertPath(from);
              assertPath(to);
              if (from === to) return '';
              from = posix.resolve(from);
              to = posix.resolve(to);
              if (from === to) return '';

              // Trim any leading backslashes
              var fromStart = 1;
              for (; fromStart < from.length; ++fromStart) {
                if (from.charCodeAt(fromStart) !== 47 /*/*/) break;
              }
              var fromEnd = from.length;
              var fromLen = fromEnd - fromStart;

              // Trim any leading backslashes
              var toStart = 1;
              for (; toStart < to.length; ++toStart) {
                if (to.charCodeAt(toStart) !== 47 /*/*/) break;
              }
              var toEnd = to.length;
              var toLen = toEnd - toStart;

              // Compare paths to find the longest common path from root
              var length = fromLen < toLen ? fromLen : toLen;
              var lastCommonSep = -1;
              var i = 0;
              for (; i <= length; ++i) {
                if (i === length) {
                  if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/) {
                      // We get here if `from` is the exact base path for `to`.
                      // For example: from='/foo/bar'; to='/foo/bar/baz'
                      return to.slice(toStart + i + 1);
                    } else if (i === 0) {
                      // We get here if `from` is the root
                      // For example: from='/'; to='/foo'
                      return to.slice(toStart + i);
                    }
                  } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
                      // We get here if `to` is the exact base path for `from`.
                      // For example: from='/foo/bar/baz'; to='/foo/bar'
                      lastCommonSep = i;
                    } else if (i === 0) {
                      // We get here if `to` is the root.
                      // For example: from='/foo'; to='/'
                      lastCommonSep = 0;
                    }
                  }
                  break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                var toCode = to.charCodeAt(toStart + i);
                if (fromCode !== toCode) break;else if (fromCode === 47 /*/*/) lastCommonSep = i;
              }
              var out = '';
              // Generate the relative path based on the path difference between `to`
              // and `from`
              for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
                if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
                  if (out.length === 0) out += '..';else out += '/..';
                }
              }

              // Lastly, append the rest of the destination (`to`) path that comes after
              // the common path parts
              if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
                toStart += lastCommonSep;
                if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;
                return to.slice(toStart);
              }
            },
            _makeLong: function _makeLong(path) {
              return path;
            },
            dirname: function dirname(path) {
              assertPath(path);
              if (path.length === 0) return '.';
              var code = path.charCodeAt(0);
              var hasRoot = code === 47 /*/*/;
              var end = -1;
              var matchedSlash = true;
              for (var i = path.length - 1; i >= 1; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                  if (!matchedSlash) {
                    end = i;
                    break;
                  }
                } else {
                  // We saw the first non-path separator
                  matchedSlash = false;
                }
              }
              if (end === -1) return hasRoot ? '/' : '.';
              if (hasRoot && end === 1) return '//';
              return path.slice(0, end);
            },
            basename: function basename(path, ext) {
              if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
              assertPath(path);
              var start = 0;
              var end = -1;
              var matchedSlash = true;
              var i;
              if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path) return '';
                var extIdx = ext.length - 1;
                var firstNonSlashEnd = -1;
                for (i = path.length - 1; i >= 0; --i) {
                  var code = path.charCodeAt(i);
                  if (code === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      start = i + 1;
                      break;
                    }
                  } else {
                    if (firstNonSlashEnd === -1) {
                      // We saw the first non-path separator, remember this index in case
                      // we need it if the extension ends up not matching
                      matchedSlash = false;
                      firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                      // Try to match the explicit extension
                      if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                          // We matched the extension, so mark this as the end of our path
                          // component
                          end = i;
                        }
                      } else {
                        // Extension does not match, so our result is the entire path
                        // component
                        extIdx = -1;
                        end = firstNonSlashEnd;
                      }
                    }
                  }
                }
                if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
                return path.slice(start, end);
              } else {
                for (i = path.length - 1; i >= 0; --i) {
                  if (path.charCodeAt(i) === 47 /*/*/) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                      start = i + 1;
                      break;
                    }
                  } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                  }
                }
                if (end === -1) return '';
                return path.slice(start, end);
              }
            },
            extname: function extname(path) {
              assertPath(path);
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;
              for (var i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                  // If we reached a path separator that was not part of a set of path
                  // separators at the end of the string, stop now
                  if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                  }
                  continue;
                }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                  // If this is our first dot, mark it as the start of our extension
                  if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
                } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }
              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                return '';
              }
              return path.slice(startDot, end);
            },
            format: function format(pathObject) {
              if (pathObject === null || _typeof(pathObject) !== 'object') {
                throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + _typeof(pathObject));
              }
              return _format('/', pathObject);
            },
            parse: function parse(path) {
              assertPath(path);
              var ret = {
                root: '',
                dir: '',
                base: '',
                ext: '',
                name: ''
              };
              if (path.length === 0) return ret;
              var code = path.charCodeAt(0);
              var isAbsolute = code === 47 /*/*/;
              var start;
              if (isAbsolute) {
                ret.root = '/';
                start = 1;
              } else {
                start = 0;
              }
              var startDot = -1;
              var startPart = 0;
              var end = -1;
              var matchedSlash = true;
              var i = path.length - 1;

              // Track the state of characters (if any) we see before our first dot and
              // after any path separator we find
              var preDotState = 0;

              // Get non-dir info
              for (; i >= start; --i) {
                code = path.charCodeAt(i);
                if (code === 47 /*/*/) {
                  // If we reached a path separator that was not part of a set of path
                  // separators at the end of the string, stop now
                  if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                  }
                  continue;
                }
                if (end === -1) {
                  // We saw the first non-path separator, mark this as the end of our
                  // extension
                  matchedSlash = false;
                  end = i + 1;
                }
                if (code === 46 /*.*/) {
                  // If this is our first dot, mark it as the start of our extension
                  if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
                } else if (startDot !== -1) {
                  // We saw a non-dot and non-path separator before our dot, so we should
                  // have a good chance at having a non-empty extension
                  preDotState = -1;
                }
              }
              if (startDot === -1 || end === -1 ||
              // We saw a non-dot character immediately before the dot
              preDotState === 0 ||
              // The (right-most) trimmed path component is exactly '..'
              preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                if (end !== -1) {
                  if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
                }
              } else {
                if (startPart === 0 && isAbsolute) {
                  ret.name = path.slice(1, startDot);
                  ret.base = path.slice(1, end);
                } else {
                  ret.name = path.slice(startPart, startDot);
                  ret.base = path.slice(startPart, end);
                }
                ret.ext = path.slice(startDot, end);
              }
              if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
              return ret;
            },
            sep: '/',
            delimiter: ':',
            win32: null,
            posix: null
          };
          posix.posix = posix;
          module.exports = posix;
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "_process": 36
    }],
    36: [function (require, module, exports) {
      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};
      function noop() {}
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function (name) {
        return [];
      };
      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };
      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };
    }, {}],
    37: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ProcessTokens = exports.procTokensDefaultOptions = void 0;
          var stream_1 = require("stream");
          var decode_1 = require("./decode");
          var utils_1 = require("./utils");
          var defaultStringDecoder = function defaultStringDecoder(buf, enc) {
            return buf.toString(enc);
          };
          var defaultStringEncoder = function defaultStringEncoder(str, enc) {
            return Buffer.from(str, enc);
          };
          exports.procTokensDefaultOptions = {
            decode: defaultStringDecoder,
            encode: defaultStringEncoder,
            outputMode: 'string',
            replaceSymbolFontChars: false,
            warn: console.warn
          };
          var knownSymbolFontNames = {
            Wingdings: true,
            'Wingdings 2': true,
            'Wingdings 3': true,
            Webdings: true,
            Symbol: true
          };
          function isKnownSymbolFont(thisFont) {
            return !!thisFont && (thisFont.fcharsetCpg === 42 || thisFont.cpg === 42 || knownSymbolFontNames[thisFont.fontName || ''] === true);
          }
          var ProcessTokens = /*#__PURE__*/function (_stream_1$Transform) {
            _inherits(ProcessTokens, _stream_1$Transform);
            var _super2 = _createSuper(ProcessTokens);
            function ProcessTokens(options) {
              var _this3;
              _classCallCheck2(this, ProcessTokens);
              _this3 = _super2.call(this, {
                writableObjectMode: true,
                readableObjectMode: true
              });
              _this3._rootState = {
                uc: 1,
                groupDepth: 0,
                destDepth: 0,
                destGroupDepth: 0
              };
              _this3._state = _this3._rootState;
              _this3._cpg = 1252;
              _this3._count = 0;
              _this3._lastLastToken = null;
              _this3._lastToken = null;
              _this3._currToken = null;
              _this3._done = false;
              _this3._ansicpg = false;
              _this3._skip = 0;
              _this3._options = Object.assign(Object.assign({}, exports.procTokensDefaultOptions), options);
              _this3._pushOutput = _this3._pushOutput.bind(_assertThisInitialized(_this3));
              return _this3;
            }
            _createClass2(ProcessTokens, [{
              key: "defaultCodepage",
              get: function get() {
                return this._cpg;
              }
            }, {
              key: "_getOutputAsString",
              value: function _getOutputAsString(data, font) {
                var outStr;
                var areSymbolFontCodepoints = false;
                if (font && isKnownSymbolFont(font)) {
                  var chunks = [];
                  if (utils_1.isStr(data)) {
                    var _iterator = _createForOfIteratorHelper(data),
                      _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var c = _step.value;
                        var codepoint = c.codePointAt(0);
                        if (codepoint >= 0 && codepoint <= 0xFF || codepoint >= 0xF000 && codepoint <= 0xF0FF) {
                          chunks.push(String.fromCodePoint(codepoint % 0xF000));
                        } else {
                          chunks.push(String.fromCodePoint(codepoint));
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  } else {
                    chunks.push(data.toString('latin1'));
                  }
                  var str1 = chunks.join('');
                  var fontname = font.fontName;
                  if (fontname && (this._options.replaceSymbolFontChars === true || this._options.replaceSymbolFontChars && this._options.replaceSymbolFontChars[fontname])) {
                    var str2 = decode_1.recodeSymbolFontText(str1, fontname, 'keep');
                    outStr = str2 || '';
                  } else {
                    outStr = str1;
                    areSymbolFontCodepoints = true;
                  }
                } else if (utils_1.isStr(data)) {
                  outStr = data;
                } else {
                  var cpg = font ? font.cpg || font.fcharsetCpg || this._cpg : this._cpg;
                  if (cpg === 20127 || cpg === 65001) {
                    outStr = data.toString('utf8');
                  } else if (cpg === 1200) {
                    throw new Error('Decoding 1200');
                    outStr = data.toString('utf16le');
                  } else if (cpg) {
                    outStr = this._options.decode(data, 'cp' + cpg);
                  } else {
                    console.log('HELP1!');
                    throw new Error('text with no codepage');
                  }
                }
                return [outStr, areSymbolFontCodepoints];
              }
            }, {
              key: "_pushOutputData",
              value: function _pushOutputData(outStr, areSymbolFontCodepoints) {
                if (this._options.outputMode === 'buffer-utf8') {
                  this.push(Buffer.from(outStr, 'utf8'));
                } else if (this._options.outputMode === 'buffer-default-cpg' && this._options.encode) {
                  if (this._cpg === 20127 || this._cpg === 65001) {
                    this.push(Buffer.from(outStr, 'utf8'));
                  } else if (this._cpg === 1200) {
                    this.push(Buffer.from(outStr, 'utf16le'));
                  } else if (areSymbolFontCodepoints) {
                    var bytes = [];
                    var _iterator2 = _createForOfIteratorHelper(outStr),
                      _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var c = _step2.value;
                        var codepoint = c.charCodeAt(0);
                        if (codepoint > 0xFF) {
                          bytes.push(0x20);
                        } else {
                          bytes.push(codepoint);
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    this.push(Buffer.from(bytes));
                  } else {
                    try {
                      var buf = this._options.encode(outStr, 'cp' + this._cpg);
                      this.push(buf);
                    } catch (err) {
                      this._options.warn('Unable to encode to cp' + this._cpg);
                    }
                  }
                } else {
                  this.push(outStr);
                }
              }
            }, {
              key: "_getCurrentFont",
              value: function _getCurrentFont() {
                var state = this._state;
                var f = state.font || this._deff || '';
                var finfo = this._fonttbl && this._fonttbl[f];
                return finfo;
              }
            }, {
              key: "_pushOutput",
              value: function _pushOutput(data) {
                var _iterator3 = _createForOfIteratorHelper(this._featureHandlers),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var feature = _step3.value;
                    if (feature.outputDataFilter) {
                      var handled = feature.outputDataFilter(this, data);
                      if (handled) {
                        return;
                      }
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
                var font = this._getCurrentFont();
                var _this$_getOutputAsStr = this._getOutputAsString(data, font),
                  _this$_getOutputAsStr2 = _slicedToArray(_this$_getOutputAsStr, 2),
                  outStr = _this$_getOutputAsStr2[0],
                  areSymbolFontCodepoints = _this$_getOutputAsStr2[1];
                this._pushOutputData(outStr, areSymbolFontCodepoints);
              }
            }, {
              key: "_handleToken",
              value: function _handleToken(token) {
                try {
                  var _iterator4 = _createForOfIteratorHelper(this._featureHandlers),
                    _step4;
                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      var _feature = _step4.value;
                      if (_feature.allTokenHandler) {
                        var _result = _feature.allTokenHandler(this, token);
                        if (_result) {
                          return;
                        }
                      }
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                  var _iterator5 = _createForOfIteratorHelper(this._featureHandlers),
                    _step5;
                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                      var _feature2 = _step5.value;
                      if (_feature2.tokenHandlers) {
                        var tokenHandler = _feature2.tokenHandlers[token.type];
                        if (tokenHandler) {
                          var _result2 = tokenHandler(this, token);
                          if (_result2) {
                            return;
                          }
                        }
                      }
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                  if (token.type === 2) {
                    var _iterator6 = _createForOfIteratorHelper(this._featureHandlers),
                      _step6;
                    try {
                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                        var feature = _step6.value;
                        if (feature.controlHandlers && feature.controlHandlers[token.word]) {
                          var result = feature.controlHandlers[token.word](this, token);
                          if (result) {
                            return;
                          }
                        }
                      }
                    } catch (err) {
                      _iterator6.e(err);
                    } finally {
                      _iterator6.f();
                    }
                  }
                } catch (err) {
                  return err;
                }
              }
            }, {
              key: "_transform",
              value: function _transform(token, encoding, cb) {
                var error = this._handleToken(token);
                cb(error);
              }
            }, {
              key: "_flush",
              value: function _flush(cb) {
                var error;
                try {
                  var _iterator7 = _createForOfIteratorHelper(this._featureHandlers),
                    _step7;
                  try {
                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                      var feature = _step7.value;
                      if (feature.preStreamFlushHandler) {
                        feature.preStreamFlushHandler(this);
                      }
                    }
                  } catch (err) {
                    _iterator7.e(err);
                  } finally {
                    _iterator7.f();
                  }
                } catch (err) {
                  error = err;
                }
                cb(error);
              }
            }]);
            return ProcessTokens;
          }(stream_1.Transform);
          exports.ProcessTokens = ProcessTokens;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "./decode": 39,
      "./utils": 53,
      "buffer": 7,
      "stream": 57
    }],
    38: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DeEncapsulate = void 0;
      var checkVersion_1 = require("./features/checkVersion");
      var countTokens_1 = require("./features/countTokens");
      var handleCharacterSet_1 = require("./features/handleCharacterSet");
      var handleControlsAndDestinations_1 = require("./features/handleControlsAndDestinations");
      var handleDeEncapsulation_1 = require("./features/handleDeEncapsulation");
      var handleFonts_1 = require("./features/handleFonts");
      var handleGroupState_1 = require("./features/handleGroupState");
      var handleOutput_1 = require("./features/handleOutput");
      var handleUnicodeSkip_1 = require("./features/handleUnicodeSkip");
      var textEscapes_1 = require("./features/textEscapes");
      var ProcessTokens_1 = require("./ProcessTokens");
      var deEncExtraDefaultOptions = {
        htmlEncodeNonAscii: false,
        htmlFixContentType: false,
        htmlPreserveSpaces: false,
        mode: 'either',
        prefix: false,
        outlookQuirksMode: false
      };
      function htmlEntityEncode(str) {
        var pieces = [];
        var ascii = true;
        var _iterator8 = _createForOfIteratorHelper(str),
          _step8;
        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var char = _step8.value;
            var codepoint = char.codePointAt(0);
            if (codepoint === 0xA0) {
              ascii = false;
              pieces.push('&nbsp;');
            } else if (codepoint > 0x7F) {
              ascii = false;
              pieces.push('&#x' + codepoint.toString(16) + ';');
            } else {
              pieces.push(char);
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
        var out = ascii ? str : pieces.join('');
        return out;
      }
      var rxCharset = /(\bcharset=)([\w-]+)(")/i;
      var DeEncapsulate = /*#__PURE__*/function (_ProcessTokens_1$Proc) {
        _inherits(DeEncapsulate, _ProcessTokens_1$Proc);
        var _super3 = _createSuper(DeEncapsulate);
        function DeEncapsulate(options) {
          var _this4;
          _classCallCheck2(this, DeEncapsulate);
          _this4 = _super3.call(this, options);
          _this4._featureHandlers = [countTokens_1.countTokens, checkVersion_1.checkVersion, handleGroupState_1.handleGroupState, handleUnicodeSkip_1.handleUnicodeSkip, handleControlsAndDestinations_1.handleControlsAndDestinations, handleCharacterSet_1.handleCharacterSet, handleFonts_1.handleFonts, handleDeEncapsulation_1.handleDeEncapsulation, handleOutput_1.handleOutput, textEscapes_1.handleTextEscapes];
          _this4._rootState = {
            uc: 1,
            groupDepth: 0,
            destDepth: 0,
            destGroupDepth: 0
          };
          _this4._state = _this4._rootState;
          _this4._fromhtml = false;
          _this4._fromtext = false;
          _this4._didHtmlCharsetReplace = false;
          _this4._options = Object.assign(Object.assign(Object.assign({}, ProcessTokens_1.procTokensDefaultOptions), deEncExtraDefaultOptions), options);
          return _this4;
        }
        _createClass2(DeEncapsulate, [{
          key: "isHtml",
          get: function get() {
            return this._fromhtml;
          }
        }, {
          key: "isText",
          get: function get() {
            return this._fromtext;
          }
        }, {
          key: "originalHtmlCharset",
          get: function get() {
            return this._originalHtmlCharset;
          }
        }, {
          key: "_getOutputAsString",
          value: function _getOutputAsString(data, font) {
            var _this5 = this;
            var _a;
            var _get$call = _get(_getPrototypeOf(DeEncapsulate.prototype), "_getOutputAsString", this).call(this, data, font),
              _get$call2 = _slicedToArray(_get$call, 2),
              outStr = _get$call2[0],
              areSymbolFontCodepoints = _get$call2[1];
            if (this._fromhtml) {
              var insideHtmltag = !!((_a = this._state.allDestinations) === null || _a === void 0 ? void 0 : _a['htmltag']);
              if (insideHtmltag) {
                if (this._options.htmlFixContentType && !this._didHtmlCharsetReplace) {
                  outStr = outStr.replace(rxCharset, function (match, pre, charset, post) {
                    _this5._didHtmlCharsetReplace = true;
                    _this5._originalHtmlCharset = charset;
                    return pre + 'UTF-8' + post;
                  });
                }
              } else {
                outStr = outStr.replace(/<|>/g, function (match) {
                  return match === '<' ? '&lt;' : '&gt;';
                });
                if (this._options.htmlPreserveSpaces) {
                  if (outStr === ' ') {
                    outStr = "\xA0";
                  } else {
                    outStr = outStr.replace(/  +/g, function (match) {
                      return ' ' + "\xA0".repeat(match.length - 1);
                    }).replace(/^ +/, function (match) {
                      return "\xA0".repeat(match.length);
                    }).replace(/ +$/, function (match) {
                      return "\xA0".repeat(match.length);
                    });
                  }
                }
                if (this._options.htmlEncodeNonAscii) {
                  outStr = htmlEntityEncode(outStr);
                }
              }
            }
            return [outStr, areSymbolFontCodepoints];
          }
        }, {
          key: "_getCurrentFont",
          value: function _getCurrentFont() {
            var allDests = this._state.allDestinations || {};
            var insideHtmltag = !!allDests['htmltag'];
            return insideHtmltag ? undefined : _get(_getPrototypeOf(DeEncapsulate.prototype), "_getCurrentFont", this).call(this);
          }
        }]);
        return DeEncapsulate;
      }(ProcessTokens_1.ProcessTokens);
      exports.DeEncapsulate = DeEncapsulate;
      exports.default = DeEncapsulate;
    }, {
      "./ProcessTokens": 37,
      "./features/checkVersion": 40,
      "./features/countTokens": 41,
      "./features/handleCharacterSet": 42,
      "./features/handleControlsAndDestinations": 43,
      "./features/handleDeEncapsulation": 44,
      "./features/handleFonts": 45,
      "./features/handleGroupState": 46,
      "./features/handleOutput": 47,
      "./features/handleUnicodeSkip": 48,
      "./features/textEscapes": 49
    }],
    39: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.recodeSymbolFontText = exports.fontToUnicode = void 0;
      var utils_1 = require("./utils");
      exports.fontToUnicode = {
        Wingdings: [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x1F589, 0x02702, 0x02701, 0x1F453, 0x1F56D, 0x1F56E, 0x1F56F, 0x1F57F, 0x02706, 0x1F582, 0x1F583, 0x1F4EA, 0x1F4EB, 0x1F4EC, 0x1F4ED, 0x1F4C1, 0x1F4C2, 0x1F4C4, 0x1F5CF, 0x1F5D0, 0x1F5C4, 0x0231B, 0x1F5AE, 0x1F5B0, 0x1F5B2, 0x1F5B3, 0x1F5B4, 0x1F5AB, 0x1F5AC, 0x02707, 0x0270D, 0x1F58E, 0x0270C, 0x1F44C, 0x1F44D, 0x1F44E, 0x0261C, 0x0261E, 0x0261D, 0x0261F, 0x1F590, 0x0263A, 0x1F610, 0x02639, 0x1F4A3, 0x02620, 0x1F3F3, 0x1F3F1, 0x02708, 0x0263C, 0x1F4A7, 0x02744, 0x1F546, 0x0271E, 0x1F548, 0x02720, 0x02721, 0x0262A, 0x0262F, 0x00950, 0x02638, 0x02648, 0x02649, 0x0264A, 0x0264B, 0x0264C, 0x0264D, 0x0264E, 0x0264F, 0x02650, 0x02651, 0x02652, 0x02653, 0x1F670, 0x1F675, 0x025CF, 0x1F53E, 0x025A0, 0x025A1, 0x1F790, 0x02751, 0x02752, 0x02B27, 0x029EB, 0x025C6, 0x02756, 0x02B25, 0x02327, 0x02BB9, 0x02318, 0x1F3F5, 0x1F3F6, 0x1F676, 0x1F677, 0x00020, 0x024EA, 0x02460, 0x02461, 0x02462, 0x02463, 0x02464, 0x02465, 0x02466, 0x02467, 0x02468, 0x02469, 0x024FF, 0x02776, 0x02777, 0x02778, 0x02779, 0x0277A, 0x0277B, 0x0277C, 0x0277D, 0x0277E, 0x0277F, 0x1F662, 0x1F660, 0x1F661, 0x1F663, 0x1F65E, 0x1F65C, 0x1F65D, 0x1F65F, 0x000B7, 0x02022, 0x025AA, 0x026AA, 0x1F786, 0x1F788, 0x025C9, 0x025CE, 0x1F53F, 0x025AA, 0x025FB, 0x1F7C2, 0x02726, 0x02605, 0x02736, 0x02734, 0x02739, 0x02735, 0x02BD0, 0x02316, 0x027E1, 0x02311, 0x02BD1, 0x0272A, 0x02730, 0x1F550, 0x1F551, 0x1F552, 0x1F553, 0x1F554, 0x1F555, 0x1F556, 0x1F557, 0x1F558, 0x1F559, 0x1F55A, 0x1F55B, 0x02BB0, 0x02BB1, 0x02BB2, 0x02BB3, 0x02BB4, 0x02BB5, 0x02BB6, 0x02BB7, 0x1F66A, 0x1F66B, 0x1F655, 0x1F654, 0x1F657, 0x1F656, 0x1F650, 0x1F651, 0x1F652, 0x1F653, 0x0232B, 0x02326, 0x02B98, 0x02B9A, 0x02B99, 0x02B9B, 0x02B88, 0x02B8A, 0x02B89, 0x02B8B, 0x1F868, 0x1F86A, 0x1F869, 0x1F86B, 0x1F86C, 0x1F86D, 0x1F86F, 0x1F86E, 0x1F878, 0x1F87A, 0x1F879, 0x1F87B, 0x1F87C, 0x1F87D, 0x1F87F, 0x1F87E, 0x021E6, 0x021E8, 0x021E7, 0x021E9, 0x02B04, 0x021F3, 0x02B00, 0x02B01, 0x02B03, 0x02B02, 0x1F8AC, 0x1F8AD, 0x1F5F6, 0x02714, 0x1F5F7, 0x1F5F9, 0x0229E],
        'Wingdings 2': [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x1F58A, 0x1F58B, 0x1F58C, 0x1F58D, 0x02704, 0x02700, 0x1F57E, 0x1F57D, 0x1F5C5, 0x1F5C6, 0x1F5C7, 0x1F5C8, 0x1F5C9, 0x1F5CA, 0x1F5CB, 0x1F5CC, 0x1F5CD, 0x1F4CB, 0x1F5D1, 0x1F5D4, 0x1F5B5, 0x1F5B6, 0x1F5B7, 0x1F5B8, 0x1F5AD, 0x1F5AF, 0x1F5B1, 0x1F592, 0x1F593, 0x1F598, 0x1F599, 0x1F59A, 0x1F59B, 0x1F448, 0x1F449, 0x1F59C, 0x1F59D, 0x1F59E, 0x1F59F, 0x1F5A0, 0x1F5A1, 0x1F446, 0x1F447, 0x1F5A2, 0x1F5A3, 0x1F591, 0x1F5F4, 0x02713, 0x1F5F5, 0x02611, 0x02612, 0x02612, 0x02BBE, 0x02BBF, 0x029B8, 0x029B8, 0x1F671, 0x1F674, 0x1F672, 0x1F673, 0x0203D, 0x1F679, 0x1F67A, 0x1F67B, 0x1F666, 0x1F664, 0x1F665, 0x1F667, 0x1F65A, 0x1F658, 0x1F659, 0x1F65B, 0x024EA, 0x02460, 0x02461, 0x02462, 0x02463, 0x02464, 0x02465, 0x02466, 0x02467, 0x02468, 0x02469, 0x024FF, 0x02776, 0x02777, 0x02778, 0x02779, 0x0277A, 0x0277B, 0x0277C, 0x0277D, 0x0277E, 0x0277F, 0x00020, 0x02609, 0x1F315, 0x0263D, 0x0263E, 0x02E3F, 0x0271D, 0x1F547, 0x1F55C, 0x1F55D, 0x1F55E, 0x1F55F, 0x1F560, 0x1F561, 0x1F562, 0x1F563, 0x1F564, 0x1F565, 0x1F566, 0x1F567, 0x1F668, 0x1F669, 0x02022, 0x025CF, 0x026AB, 0x02B24, 0x1F785, 0x1F786, 0x1F787, 0x1F788, 0x1F78A, 0x029BF, 0x025FE, 0x025A0, 0x025FC, 0x02B1B, 0x02B1C, 0x1F791, 0x1F792, 0x1F793, 0x1F794, 0x025A3, 0x1F795, 0x1F796, 0x1F797, 0x02B29, 0x02B25, 0x025C6, 0x025C7, 0x1F79A, 0x025C8, 0x1F79B, 0x1F79C, 0x1F79D, 0x02B2A, 0x02B27, 0x029EB, 0x025CA, 0x1F7A0, 0x025D6, 0x025D7, 0x02BCA, 0x02BCB, 0x025FC, 0x02B25, 0x02B1F, 0x02BC2, 0x02B23, 0x02B22, 0x02BC3, 0x02BC4, 0x1F7A1, 0x1F7A2, 0x1F7A3, 0x1F7A4, 0x1F7A5, 0x1F7A6, 0x1F7A7, 0x1F7A8, 0x1F7A9, 0x1F7AA, 0x1F7AB, 0x1F7AC, 0x1F7AD, 0x1F7AE, 0x1F7AF, 0x1F7B0, 0x1F7B1, 0x1F7B2, 0x1F7B3, 0x1F7B4, 0x1F7B5, 0x1F7B6, 0x1F7B7, 0x1F7B8, 0x1F7B9, 0x1F7BA, 0x1F7BB, 0x1F7BC, 0x1F7BD, 0x1F7BE, 0x1F7BF, 0x1F7C0, 0x1F7C2, 0x1F7C4, 0x02726, 0x1F7C9, 0x02605, 0x02736, 0x1F7CB, 0x02737, 0x1F7CF, 0x1F7D2, 0x02739, 0x1F7C3, 0x1F7C7, 0x0272F, 0x1F7CD, 0x1F7D4, 0x02BCC, 0x02BCD, 0x0203B, 0x02042, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020],
        'Wingdings 3': [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x02B60, 0x02B62, 0x02B61, 0x02B63, 0x02B66, 0x02B67, 0x02B69, 0x02B68, 0x02B70, 0x02B72, 0x02B71, 0x02B73, 0x02B76, 0x02B78, 0x02B7B, 0x02B7D, 0x02B64, 0x02B65, 0x02B6A, 0x02B6C, 0x02B6B, 0x02B6D, 0x02B4D, 0x02BA0, 0x02BA1, 0x02BA2, 0x02BA3, 0x02BA4, 0x02BA5, 0x02BA6, 0x02BA7, 0x02B90, 0x02B91, 0x02B92, 0x02B93, 0x02B80, 0x02B83, 0x02B7E, 0x02B7F, 0x02B84, 0x02B86, 0x02B85, 0x02B87, 0x02B8F, 0x02B8D, 0x02B8E, 0x02B8C, 0x02B6E, 0x02B6F, 0x0238B, 0x02324, 0x02303, 0x02325, 0x023B5, 0x0237D, 0x021EA, 0x02BB8, 0x1F8A0, 0x1F8A1, 0x1F8A2, 0x1F8A3, 0x1F8A4, 0x1F8A5, 0x1F8A6, 0x1F8A7, 0x1F8A8, 0x1F8A9, 0x1F8AA, 0x1F8AB, 0x02190, 0x02192, 0x02191, 0x02193, 0x02196, 0x02197, 0x02199, 0x02198, 0x1F858, 0x1F859, 0x025B2, 0x025BC, 0x025B3, 0x025BD, 0x025C4, 0x025BA, 0x025C1, 0x025B7, 0x025E3, 0x025E2, 0x025E4, 0x025E5, 0x1F780, 0x1F782, 0x1F781, 0x00020, 0x1F783, 0x025B2, 0x025BC, 0x025C0, 0x025B6, 0x02B9C, 0x02B9E, 0x02B9D, 0x02B9F, 0x1F810, 0x1F812, 0x1F811, 0x1F813, 0x1F814, 0x1F816, 0x1F815, 0x1F817, 0x1F818, 0x1F81A, 0x1F819, 0x1F81B, 0x1F81C, 0x1F81E, 0x1F81D, 0x1F81F, 0x1F800, 0x1F802, 0x1F801, 0x1F803, 0x1F804, 0x1F806, 0x1F805, 0x1F807, 0x1F808, 0x1F80A, 0x1F809, 0x1F80B, 0x1F820, 0x1F822, 0x1F824, 0x1F826, 0x1F828, 0x1F82A, 0x1F82C, 0x1F89C, 0x1F89D, 0x1F89E, 0x1F89F, 0x1F82E, 0x1F830, 0x1F832, 0x1F834, 0x1F836, 0x1F838, 0x1F83A, 0x1F839, 0x1F83B, 0x1F898, 0x1F89A, 0x1F899, 0x1F89B, 0x1F83C, 0x1F83E, 0x1F83D, 0x1F83F, 0x1F840, 0x1F842, 0x1F841, 0x1F843, 0x1F844, 0x1F846, 0x1F845, 0x1F847, 0x02BA8, 0x02BA9, 0x02BAA, 0x02BAB, 0x02BAC, 0x02BAD, 0x02BAE, 0x02BAF, 0x1F860, 0x1F862, 0x1F861, 0x1F863, 0x1F864, 0x1F865, 0x1F867, 0x1F866, 0x1F870, 0x1F872, 0x1F871, 0x1F873, 0x1F874, 0x1F875, 0x1F877, 0x1F876, 0x1F880, 0x1F882, 0x1F881, 0x1F883, 0x1F884, 0x1F885, 0x1F887, 0x1F886, 0x1F890, 0x1F892, 0x1F891, 0x1F893, 0x1F894, 0x1F896, 0x1F895, 0x1F897, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020],
        Webdings: [0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x00020, 0x1F577, 0x1F578, 0x1F572, 0x1F576, 0x1F3C6, 0x1F396, 0x1F587, 0x1F5E8, 0x1F5E9, 0x1F5F0, 0x1F5F1, 0x1F336, 0x1F397, 0x1F67E, 0x1F67C, 0x1F5D5, 0x1F5D6, 0x1F5D7, 0x023F4, 0x023F5, 0x023F6, 0x023F7, 0x023EA, 0x023E9, 0x023EE, 0x023ED, 0x023F8, 0x023F9, 0x023FA, 0x1F5DA, 0x1F5F3, 0x1F6E0, 0x1F3D7, 0x1F3D8, 0x1F3D9, 0x1F3DA, 0x1F3DC, 0x1F3ED, 0x1F3DB, 0x1F3E0, 0x1F3D6, 0x1F3DD, 0x1F6E3, 0x1F50D, 0x1F3D4, 0x1F441, 0x1F442, 0x1F3DE, 0x1F3D5, 0x1F6E4, 0x1F3DF, 0x1F6F3, 0x1F56C, 0x1F56B, 0x1F568, 0x1F508, 0x1F394, 0x1F395, 0x1F5EC, 0x1F67D, 0x1F5ED, 0x1F5EA, 0x1F5EB, 0x02B94, 0x02714, 0x1F6B2, 0x02B1C, 0x1F6E1, 0x1F381, 0x1F6F1, 0x02B1B, 0x1F691, 0x1F6C8, 0x1F6E9, 0x1F6F0, 0x1F7C8, 0x1F574, 0x02B24, 0x1F6E5, 0x1F694, 0x1F5D8, 0x1F5D9, 0x02753, 0x1F6F2, 0x1F687, 0x1F68D, 0x1F6A9, 0x029B8, 0x02296, 0x1F6AD, 0x1F5EE, 0x023D0, 0x1F5EF, 0x1F5F2, 0x025AF, 0x1F6B9, 0x1F6BA, 0x1F6C9, 0x1F6CA, 0x1F6BC, 0x1F47D, 0x1F3CB, 0x026F7, 0x1F3C2, 0x1F3CC, 0x1F3CA, 0x1F3C4, 0x1F3CD, 0x1F3CE, 0x1F698, 0x1F4C8, 0x1F6E2, 0x1F4B0, 0x1F3F7, 0x1F4B3, 0x1F46A, 0x1F5E1, 0x1F5E2, 0x1F5E3, 0x0272F, 0x1F584, 0x1F585, 0x1F583, 0x1F586, 0x1F5B9, 0x1F5BA, 0x1F5BB, 0x1F575, 0x1F570, 0x1F5BD, 0x1F5BE, 0x1F4CB, 0x1F5D2, 0x1F5D3, 0x1F56E, 0x1F4DA, 0x1F5DE, 0x1F5DF, 0x1F5C3, 0x1F4C7, 0x1F5BC, 0x1F3AD, 0x1F39C, 0x1F398, 0x1F399, 0x1F3A7, 0x1F4BF, 0x1F39E, 0x1F4F7, 0x1F39F, 0x1F3AC, 0x1F4FD, 0x1F4F9, 0x1F4FE, 0x1F4FB, 0x1F39A, 0x1F39B, 0x1F4FA, 0x1F4BB, 0x1F5A5, 0x1F5A6, 0x1F5A7, 0x1F579, 0x1F3AE, 0x1F57B, 0x1F57C, 0x1F4DF, 0x1F581, 0x1F580, 0x1F5A8, 0x1F5A9, 0x1F5BF, 0x1F5AA, 0x1F5DC, 0x1F512, 0x1F513, 0x1F5DD, 0x1F4E5, 0x1F4E4, 0x1F573, 0x1F323, 0x1F324, 0x1F325, 0x1F326, 0x02601, 0x1F328, 0x1F327, 0x1F329, 0x1F32A, 0x1F32C, 0x1F32B, 0x1F31C, 0x1F321, 0x1F6CB, 0x1F6CF, 0x1F37D, 0x1F378, 0x1F6CE, 0x1F6CD, 0x024C5, 0x0267F, 0x1F6C6, 0x1F588, 0x1F393, 0x1F5E4, 0x1F5E5, 0x1F5E6, 0x1F5E7, 0x1F6EA, 0x1F43F, 0x1F426, 0x1F41F, 0x1F415, 0x1F408, 0x1F66C, 0x1F66E, 0x1F66D, 0x1F66F, 0x1F5FA, 0x1F30D, 0x1F30F, 0x1F30E, 0x1F54A],
        Symbol: '' + "        " + "        " + "        " + "        " + " !\u2200#\u2203%&\u220D" + "()\u2217+,\u2212./" + "01234567" + "89:;<=>?" + "\u2245\u0391\u0392\u03A7\u0394\u0395\u03A6\u0393" + "\u0397\u0399\u03D1\u039A\u039B\u039C\u039D\u039F" + "\u03A0\u0398\u03A1\u03A3\u03A4\u03A5\u03C2\u03A9" + "\u039E\u03A8\u0396[\u2234]\u22A5_" + "\u203E\u03B1\u03B2\u03C7\u03B4\u03B5\u03C6\u03B3" + "\u03B7\u03B9\u03D5\u03BA\u03BB\u03BC\u03BD\u03BF" + "\u03C0\u03B8\u03C1\u03C3\u03C4\u03C5\u03D6\u03C9" + "\u03BE\u03C8\u03B6{|}\u223C " + "        " + "        " + "        " + "        " + " \u03D2\u2032\u2264\u2044\u221E\u0192\u2663" + "\u2666\u2665\u2660\u2194\u2190\u2191\u2192\u2193" + "\xB0\xB1\u2033\u2265\xD7\u221D\u2202\u2022" + "\xF7\u2260\u2261\u2248\u2026\u23D0\u23AF\u21B5" + "\u2135\u2111\u211C\u2118\u2297\u2295\u2205\u2229" + "\u222A\u2283\u2287\u2284\u2282\u2286\u2208\u2209" + "\u2220\u2207\xAE\xA9\u2122\u220F\u221A\u22C5" + "\xAC\u2227\u2228\u21D4\u21D0\u21D1\u21D2\u21D3" + "\u25CA\u2329\xAE\xA9\u2122\u2211\u239B\u239C" + "\u239D\u23A1\u23A2\u23A3\u23A7\u23A8\u23A9\u23AA" + "\u20AC\u232A\u222B\u2320\u23AE\u2321\u239E\u239F" + "\u23A0\u23A4\u23A5\u23A6\u23AB\u23AC\u23AD "
      };
      function recodeSymbolFontText(input, font) {
        var unmapped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '?';
        var mapping = exports.fontToUnicode[font];
        if (mapping) {
          var parts = [];
          var _iterator9 = _createForOfIteratorHelper(input),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var c = _step9.value;
              var codepoint = c.codePointAt(0);
              var codepoint2 = mapping[codepoint];
              if (utils_1.isDef(codepoint2)) {
                parts.push(utils_1.isStr(codepoint2) ? codepoint2 : String.fromCodePoint(codepoint2));
              } else {
                if (unmapped === 'keep') {
                  parts.push(c);
                } else if (unmapped === '?') {
                  parts.push('?');
                }
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
          return parts.join('');
        }
      }
      exports.recodeSymbolFontText = recodeSymbolFontText;
    }, {
      "./utils": 53
    }],
    40: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.checkVersion = void 0;
      exports.checkVersion = {
        allTokenHandler: function allTokenHandler(global, token) {
          if (global._count === 1 && token.type !== 0) {
            throw new Error('File should start with "{"');
          }
          if (global._count === 2 && (token.word !== 'rtf' || token.param && token.param !== 1)) {
            throw new Error('File should start with "{\\rtf[0,1]"');
          }
        },
        preStreamFlushHandler: function preStreamFlushHandler(global) {
          if (global._count === 0) {
            throw new Error('File should start with "{"');
          } else if (global._count === 1) {
            throw new Error('File should start with "{\\rtf"');
          }
        }
      };
    }, {}],
    41: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.countTokens = void 0;
      exports.countTokens = {
        allTokenHandler: function allTokenHandler(global) {
          ++global._count;
        }
      };
    }, {}],
    42: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleCharacterSet = void 0;
      var utils_1 = require("../utils");
      var characterSetControlHandlers = {
        mac: function mac() {
          throw new Error('Unsupported character set \\mac');
        },
        pc: function pc() {
          throw new Error('Unsupported character set \\pc');
        },
        pca: function pca() {
          throw new Error('Unsupported character set \\pca');
        },
        ansicpg: function ansicpg(global, token) {
          if (global._state.destination === 'rtf' && global._state.destDepth > 1 && global._ansicpg) {
            return;
          }
          if (global._ansicpg) {
            global._options.warn('\\ansicpg already defined');
            return;
          }
          if (!utils_1.isNum(token.param)) {
            global._options.warn('\\ansicpg with no param');
            return;
          }
          global._ansicpg = true;
          global._cpg = token.param;
        }
      };
      exports.handleCharacterSet = {
        controlHandlers: characterSetControlHandlers
      };
    }, {
      "../utils": 53
    }],
    43: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleControlsAndDestinations = void 0;
      var words_1 = require("../words");
      function addDestination(state, destination) {
        state.destDepth = (state.destDepth || 0) + 1;
        state.destGroupDepth = state.groupDepth;
        if (!state.allDestinations) {
          state.allDestinations = {};
          state.allDestinations[destination] = true;
        } else if (!state.allDestinations[destination]) {
          state.allDestinations = Object.create(state.allDestinations);
          state.allDestinations[destination] = true;
        }
      }
      var destinationControlHandlers = _defineProperty2({}, 2, function _(global, token) {
        var _a;
        if (token.word === '*' && ((_a = global._lastToken) === null || _a === void 0 ? void 0 : _a.type) !== 0) {
          global._options.warn('Got control symbol "\\*" but not immediately after "{"');
        }
        var wordType = words_1.words[token.word] || 0;
        if (wordType === 5) {
          if (global._lastToken && global._lastToken.type === 0) {
            global._state.destination = token.word;
            global._state.destIgnorableImmediate = false;
            addDestination(global._state, token.word);
          } else if (global._lastToken && global._lastLastToken && global._lastToken.type === 2 && global._lastToken.word === '*' && global._lastLastToken.type === 0) {
            global._state.destination = token.word;
            global._state.destIgnorableImmediate = global._state.destIgnorable = true;
            addDestination(global._state, token.word);
          } else {
            global._options.warn('Got destination control word but not immediately after "{" or "{\\*": ' + token.word);
          }
        } else if (wordType === 0) {
          if (global._lastToken && global._lastLastToken && global._lastToken.type === 2 && global._lastToken.word === '*' && global._lastLastToken.type === 0) {
            global._state.destination = token.word;
            global._state.destIgnorableImmediate = global._state.destIgnorable = true;
            addDestination(global._state, token.word);
          }
        }
      });
      exports.handleControlsAndDestinations = {
        tokenHandlers: destinationControlHandlers,
        allTokenHandler: function allTokenHandler(global, token) {
          global._lastLastToken = global._lastToken;
          global._lastToken = global._currToken;
          global._currToken = token;
        }
      };
    }, {
      "../words": 54
    }],
    44: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleDeEncapsulation = void 0;
      function getModeError(global) {
        if (global._options.mode === 'html') {
          return new Error('Not encapsulated HTML file');
        } else if (global._options.mode === 'text') {
          return new Error('Not encapsulated text file');
        } else {
          return new Error('Not encapsulated HTML or text file');
        }
      }
      var allTokenHandler = function allTokenHandler(global, token) {
        if (global._count <= 10) {
          if (token.type === 3) {
            throw getModeError(global);
          }
        } else if (!global._fromhtml && !global._fromtext) {
          throw getModeError(global);
        }
        if (global._state.htmlrtf && global._options.outlookQuirksMode) {
          if (token.type !== 2 || token.word !== 'f' && token.word !== 'htmlrtf') {
            return true;
          }
        }
      };
      var deEncapsulationControlHandlers = {
        fromhtml: function fromhtml(global) {
          if (global._state.destination !== 'rtf') {
            throw new Error('\\fromhtml not at root group');
          }
          if (global._fromhtml !== false || global._fromtext !== false) {
            throw new Error('\\fromhtml or \\fromtext already defined');
          }
          if (global._options.mode !== 'html' && global._options.mode !== 'either') {
            throw getModeError(global);
          }
          global._fromhtml = true;
          if (global._options.prefix) {
            global._pushOutput('html:');
          }
          return true;
        },
        fromtext: function fromtext(global) {
          if (global._state.destination !== 'rtf') {
            throw new Error('\\fromtext not at root group');
          }
          if (global._fromhtml !== false || global._fromtext !== false) {
            throw new Error('\\fromhtml or \\fromtext already defined');
          }
          if (global._options.mode !== 'text' && global._options.mode !== 'either') {
            throw getModeError(global);
          }
          global._fromtext = true;
          if (global._options.prefix) {
            global._pushOutput('text:');
          }
          return true;
        },
        htmlrtf: function htmlrtf(global, token) {
          var on = token.param !== 0;
          global._state.htmlrtf = on;
        }
      };
      exports.handleDeEncapsulation = {
        allTokenHandler: allTokenHandler,
        controlHandlers: deEncapsulationControlHandlers,
        outputDataFilter: function outputDataFilter(global) {
          if (global._state.htmlrtf) {
            return true;
          }
          var allDests = global._state.allDestinations || {};
          var insideHtmltag = !!allDests['htmltag'];
          if (!insideHtmltag && global._state.destIgnorable) {
            return true;
          }
          if (!insideHtmltag && (allDests['fonttbl'] || allDests['colortbl'] || allDests['stylesheet'] || allDests['pntext'])) {
            return true;
          }
        },
        preStreamFlushHandler: function preStreamFlushHandler(global) {
          if (!global._fromhtml && !global._fromtext) {
            throw getModeError(global);
          }
        }
      };
    }, {}],
    45: [function (require, module, exports) {
      "use strict";

      var _fontTokenHandlers;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleFonts = void 0;
      var utils_1 = require("../utils");
      var charsetToCpg = {
        0: 1252,
        2: 42,
        77: 10000,
        78: 10001,
        79: 10003,
        80: 10008,
        81: 10002,
        83: 10005,
        84: 10004,
        85: 10006,
        86: 10081,
        87: 10021,
        88: 10029,
        89: 10007,
        128: 932,
        129: 949,
        130: 1361,
        134: 936,
        136: 950,
        161: 1253,
        162: 1254,
        163: 1258,
        177: 1255,
        178: 1256,
        186: 1257,
        204: 1251,
        222: 874,
        238: 1250,
        254: 437,
        255: 850
      };
      var codepages = {
        20127: true,
        28591: true
      };
      for (var charset in charsetToCpg) {
        var cpg = charsetToCpg[charset];
        codepages[cpg] = true;
      }
      var handleThemeFont = function handleThemeFont(global, cw) {
        if (global._constructingFontTableEntry) {
          global._constructingFontTableEntry.themeFont = cw.word.slice(1);
        }
      };
      var handleFontFamily = function handleFontFamily(global, cw) {
        if (global._constructingFontTableEntry) {
          global._constructingFontTableEntry.fontFamily = cw.word.slice(1);
        }
      };
      var fontTokenHandlers = (_fontTokenHandlers = {}, _defineProperty2(_fontTokenHandlers, 0, function _(global) {
        if (global._constructingFontTable && global._state.destination === 'fonttbl' && global._state.groupDepth === global._state.destGroupDepth + 1) {
          global._constructingFontTableEntry = {};
        }
      }), _defineProperty2(_fontTokenHandlers, 1, function _(global) {
        if (global._constructingFontTable && global._state.destination === 'fonttbl' && global._state.groupDepth === global._state.destGroupDepth) {
          if (!global._constructingFontTableEntry || !global._constructingFontTableKey) {
            throw new Error('Finished a font table group but no key?');
          }
          global._fonttbl[global._constructingFontTableKey] = global._constructingFontTableEntry;
          global._constructingFontTableEntry = undefined;
          global._constructingFontTableKey = undefined;
        }
        if (global._constructingFontTable && global._state.destGroupDepth === 1) {
          global._constructingFontTable = false;
        }
      }), _fontTokenHandlers);
      var fontControlHandlers = {
        deff: function deff(global, cw) {
          if (global._state.destination === 'rtf' && global._state.destDepth > 1 && typeof global._deff !== 'undefined') {
            return;
          }
          if (global._state.destination !== 'rtf' || global._state.destDepth !== 1) throw new Error('\\deff not at root group');
          if (typeof global._deff !== 'undefined') throw new Error('\\deff already defined');
          global._deff = cw.param + '';
        },
        fonttbl: function fonttbl(global) {
          if (global._fonttbl && global._state.destGroupDepth > 2) {
            global._options.warn('Got additional \\fonttbl');
            return;
          }
          if (global._fonttbl) {
            throw new Error('fonttbl already created');
          } else if (global._state.destDepth !== 2 || global._state.destGroupDepth !== 2) {
            throw new Error('fonttbl not in header');
          }
          global._constructingFontTable = true;
          global._fonttbl = {};
        },
        f: function f(global, cw) {
          if (typeof cw.param === 'undefined') {
            throw new Error('No param for \\f');
          }
          var f = cw.param + '';
          if (global._constructingFontTableEntry && global._constructingFontTableKey) {
            throw new Error('\\f control word in font group which already has \\f');
          } else if (global._constructingFontTableEntry) {
            global._constructingFontTableKey = f;
          } else {
            global._state.font = f;
          }
        },
        fcharset: function fcharset(global, cw) {
          if (!global._constructingFontTableEntry) {
            return;
          }
          if (!utils_1.isNum(cw.param)) {
            throw new Error('fcharset with no param');
          }
          if (cw.param !== 1) {
            var _cpg = charsetToCpg[cw.param];
            if (!utils_1.isNum(_cpg) && codepages[cw.param]) {
              _cpg = cw.param;
            }
            if (!utils_1.isNum(_cpg)) {
              global._options.warn('No codepage for charset ' + cw.param);
            } else {
              global._constructingFontTableEntry.fcharsetCpg = _cpg;
            }
          }
        },
        cpg: function cpg(global, cw) {
          if (!global._constructingFontTableEntry) {
            return;
          }
          var cpg = cw.param;
          if (!utils_1.isNum(cpg)) {
            global._options.warn('No codepage given');
          } else {
            global._constructingFontTableEntry.cpg = cpg;
          }
        },
        flomajor: handleThemeFont,
        fhimajor: handleThemeFont,
        fdbmajor: handleThemeFont,
        fbimajor: handleThemeFont,
        flominor: handleThemeFont,
        fhiminor: handleThemeFont,
        fdbminor: handleThemeFont,
        fbiminor: handleThemeFont,
        fnil: handleFontFamily,
        froman: handleFontFamily,
        fswiss: handleFontFamily,
        fmodern: handleFontFamily,
        fscript: handleFontFamily,
        fdecor: handleFontFamily,
        ftech: handleFontFamily,
        fbidi: handleFontFamily
      };
      var fontTextHandler = function fontTextHandler(global, data) {
        if (global._constructingFontTableEntry) {
          if (!utils_1.isStr(data)) {
            data = data.toString('latin1');
          }
          data = data.replace(/[^\x00-\x7F]/g, function (c) {
            var hex = c.charCodeAt(0).toString(16).toUpperCase();
            return "\\u" + '0000'.slice(0, 4 - hex.length) + hex;
          });
          var str = (global._constructingFontTableEntry.fontName || '') + data;
          if (str.endsWith(';')) {
            str = str.substr(0, str.length - 1);
            if (str.length > 2 && str.startsWith('"') && str.endsWith('"')) {
              str = str.substr(1, str.length - 2);
            }
          }
          global._constructingFontTableEntry.fontName = str;
          return true;
        }
      };
      exports.handleFonts = {
        tokenHandlers: fontTokenHandlers,
        controlHandlers: fontControlHandlers,
        outputDataFilter: fontTextHandler
      };
    }, {
      "../utils": 53
    }],
    46: [function (require, module, exports) {
      "use strict";

      var _groupTokenHandlers;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleGroupState = void 0;
      var allTokenhandler = function allTokenhandler(global, token) {
        if (global._done) {
          if (token.type === 3 && token.data.length === 1 && token.data[0] === 0) {} else {
            global._options.warn('Additional tokens after final closing bracket');
          }
          return true;
        }
      };
      var groupTokenHandlers = (_groupTokenHandlers = {}, _defineProperty2(_groupTokenHandlers, 0, function _(global) {
        var oldState = global._state;
        var newState = Object.create(oldState);
        ++newState.groupDepth;
        global._state = newState;
      }), _defineProperty2(_groupTokenHandlers, 1, function _(global) {
        global._state = Object.getPrototypeOf(global._state);
        if (global._state === global._rootState) {
          global._done = true;
        }
      }), _groupTokenHandlers);
      exports.handleGroupState = {
        allTokenHandler: allTokenhandler,
        tokenHandlers: groupTokenHandlers,
        preStreamFlushHandler: function preStreamFlushHandler(global) {
          if (global._state !== global._rootState) {
            global._options.warn('Not enough matching closing brackets');
          }
        }
      };
    }, {}],
    47: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.handleOutput = void 0;
          var utils_1 = require("../utils");
          function flushBuffers(global) {
            if (global._bufferedUnicodeOutput) {
              var str = global._bufferedUnicodeOutput.join('');
              global._pushOutput(str);
              delete global._bufferedUnicodeOutput;
            }
            if (global._bufferedBinaryOutput) {
              global._pushOutput(Buffer.concat(global._bufferedBinaryOutput));
              delete global._bufferedBinaryOutput;
            }
          }
          var allTokenHandler = function allTokenHandler(global, token) {
            if (global._bufferedUnicodeOutput && (token.type !== 2 || token.word !== 'uc' && token.word !== 'u')) {
              flushBuffers(global);
            } else if (global._bufferedBinaryOutput && (token.type !== 2 || token.word !== "'")) {
              flushBuffers(global);
            }
          };
          var tokenHandlers = _defineProperty2({}, 3, function _(globals, token) {
            flushBuffers(globals);
            globals._pushOutput(token.data);
          });
          var unicodeControlHandlers = {
            u: function u(global, token) {
              if (!utils_1.isNum(token.param)) {
                throw new Error('Unicode control word with no param');
              }
              var newCodeUnit = token.param < 0 ? String.fromCodePoint(token.param + 0x10000) : String.fromCodePoint(token.param);
              global._bufferedUnicodeOutput = global._bufferedUnicodeOutput || [];
              global._bufferedUnicodeOutput.push(newCodeUnit);
            },
            "'": function _(global, token) {
              global._bufferedBinaryOutput = global._bufferedBinaryOutput || [];
              global._bufferedBinaryOutput.push(token.data);
            }
          };
          exports.handleOutput = {
            allTokenHandler: allTokenHandler,
            tokenHandlers: tokenHandlers,
            controlHandlers: unicodeControlHandlers
          };
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "../utils": 53,
      "buffer": 7
    }],
    48: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleUnicodeSkip = void 0;
      var allTokenHandler = function allTokenHandler(globals, token) {
        switch (token.type) {
          case 0:
          case 1:
            globals._skip = 0;
            break;
          case 2:
            if (globals._skip > 0) {
              globals._skip--;
              return true;
            }
            break;
          case 3:
            if (globals._skip >= token.data.length) {
              globals._skip -= token.data.length;
              return true;
            }
            if (globals._skip > 0) {
              token.data = token.data.slice(globals._skip);
              globals._skip = 0;
            }
            break;
        }
      };
      var unicodeSkipControlHandlers = {
        uc: function uc(global, token) {
          global._state.uc = token.param || 0;
        },
        u: function u(global) {
          global._skip = global._state.uc;
        }
      };
      exports.handleUnicodeSkip = {
        allTokenHandler: allTokenHandler,
        controlHandlers: unicodeSkipControlHandlers
      };
    }, {}],
    49: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.handleTextEscapes = void 0;
      exports.handleTextEscapes = {
        controlHandlers: {
          par: function par(globals) {
            return globals._pushOutput('\r\n');
          },
          line: function line(globals) {
            return globals._pushOutput('\r\n');
          },
          tab: function tab(globals) {
            return globals._pushOutput('\t');
          },
          lquote: function lquote(globals) {
            return globals._pushOutput("\u2018");
          },
          rquote: function rquote(globals) {
            return globals._pushOutput("\u2019");
          },
          ldblquote: function ldblquote(globals) {
            return globals._pushOutput("\u201C");
          },
          rdblquote: function rdblquote(globals) {
            return globals._pushOutput("\u201D");
          },
          bullet: function bullet(globals) {
            return globals._pushOutput("\u2022");
          },
          endash: function endash(globals) {
            return globals._pushOutput("\u2013");
          },
          emdash: function emdash(globals) {
            return globals._pushOutput("\u2014");
          },
          '{': function _(globals) {
            return globals._pushOutput('{');
          },
          '}': function _(globals) {
            return globals._pushOutput('}');
          },
          '\\': function _(globals) {
            return globals._pushOutput('\\');
          },
          '~': function _(globals) {
            return globals._pushOutput("\xA0");
          },
          _: function _(globals) {
            return globals._pushOutput("\xAD");
          }
        }
      };
    }, {}],
    50: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
            function adopt(value) {
              return value instanceof P ? value : new P(function (resolve) {
                resolve(value);
              });
            }
            return new (P || (P = Promise))(function (resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e) {
                  reject(e);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          };
          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.deEncapsulateStream = exports.deEncapsulateSync = exports.DeEncapsulate = exports.Tokenize = void 0;
          var de_encapsulate_1 = require("./de-encapsulate");
          Object.defineProperty(exports, "DeEncapsulate", {
            enumerable: true,
            get: function get() {
              return de_encapsulate_1.DeEncapsulate;
            }
          });
          var stream_flow_1 = require("./stream-flow");
          var tokenize_1 = require("./tokenize");
          Object.defineProperty(exports, "Tokenize", {
            enumerable: true,
            get: function get() {
              return tokenize_1.Tokenize;
            }
          });
          var utils_1 = require("./utils");
          function deEncapsulateSync(rtf, options) {
            var onError = function onError(err) {
              if (utils_1.isDef(err)) {
                throw err;
              }
            };
            var stream1 = new tokenize_1.Tokenize();
            var stream2 = new de_encapsulate_1.DeEncapsulate(options);
            stream1.push = function (token) {
              stream2._transform(token, '', onError);
              return true;
            };
            var chunks = [];
            stream2.push = function (piece) {
              chunks.push(piece);
              return true;
            };
            stream1._transform(rtf, undefined, onError);
            stream1._flush(onError);
            stream2._flush(onError);
            var result = !options || !options.outputMode || options.outputMode === 'string' ? chunks.join('') : Buffer.concat(chunks);
            return {
              mode: stream2.isHtml ? 'html' : 'text',
              text: result
            };
          }
          exports.deEncapsulateSync = deEncapsulateSync;
          function deEncapsulateStream(streamIn, options) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
              var stream1, stream2, chunks, result;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      stream1 = new tokenize_1.Tokenize();
                      stream2 = new de_encapsulate_1.DeEncapsulate(options);
                      _context.next = 4;
                      return stream_flow_1.streamFlow(streamIn, stream1, stream2);
                    case 4:
                      chunks = _context.sent;
                      result = !options || !options.outputMode || options.outputMode === 'string' ? chunks.join('') : Buffer.concat(chunks);
                      return _context.abrupt("return", {
                        mode: stream2.isHtml ? 'html' : 'text',
                        text: result
                      });
                    case 7:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));
          }
          exports.deEncapsulateStream = deEncapsulateStream;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "./de-encapsulate": 38,
      "./stream-flow": 51,
      "./tokenize": 52,
      "./utils": 53,
      "buffer": 7
    }],
    51: [function (require, module, exports) {
      "use strict";

      var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.streamFlow = void 0;
      function streamFlow(stream1) {
        for (var _len2 = arguments.length, streams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          streams[_key2 - 1] = arguments[_key2];
        }
        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", new Promise(function (resolve, _reject) {
                    var reject = function reject(err) {
                      stream1.unpipe();
                      for (var i = 1; i < streams.length; i++) {
                        streams[i - 1].unpipe();
                      }
                      _reject(err);
                    };
                    if (streams.length) {
                      stream1.pipe(streams[0]);
                    }
                    for (var i = 1; i < streams.length; i++) {
                      streams[i - 1].pipe(streams[i]);
                    }
                    stream1.on('error', reject);
                    for (var _i2 = 0; _i2 < streams.length; _i2++) {
                      streams[_i2].on('error', reject);
                    }
                    var sout = streams.length ? streams[streams.length - 1] : stream1;
                    var output = [];
                    sout.on('readable', function () {
                      while (true) {
                        var piece = sout.read();
                        if (piece === null) {
                          break;
                        }
                        output.push(piece);
                      }
                    });
                    sout.on('end', function () {
                      return resolve(output);
                    });
                  }));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
      }
      exports.streamFlow = streamFlow;
    }, {}],
    52: [function (require, module, exports) {
      (function (Buffer) {
        (function () {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Tokenize = void 0;
          var stream_1 = require("stream");
          var utils_1 = require("./utils");
          var isAlpha = function isAlpha(c) {
            return c > 64 && c < 91 || c > 96 && c < 123;
          };
          var isNumeric = function isNumeric(c) {
            return c > 47 && c < 58;
          };
          var Tokenize = /*#__PURE__*/function (_stream_1$Transform2) {
            _inherits(Tokenize, _stream_1$Transform2);
            var _super4 = _createSuper(Tokenize);
            function Tokenize() {
              var _this6;
              _classCallCheck2(this, Tokenize);
              _this6 = _super4.call(this, {
                readableObjectMode: true
              });
              _this6._expectedBinaryBytes = 0;
              _this6._readHexDigitsCount = 0;
              _this6._paramStr = '';
              _this6._mode = 0;
              return _this6;
            }
            _createClass2(Tokenize, [{
              key: "_flushToken",
              value: function _flushToken() {
                var token = this._token;
                if (token) {
                  if (this._paramStr) {
                    token.param = Number.parseInt(this._paramStr, 10);
                  }
                  var buf = token.data;
                  if (buf) {
                    if (buf.length > (token.length || 0)) {
                      token.data = buf.slice(0, token.length);
                    }
                    delete token.length;
                  }
                  this.push(token);
                }
                this._token = null;
                this._readHexDigitsCount = 0;
                this._paramStr = '';
                this._mode = 0;
              }
            }, {
              key: "_handleSpecialOrPush",
              value: function _handleSpecialOrPush() {
                var token = this._token;
                var param = parseInt(this._paramStr || '0', 10) || 0;
                if (token.type === 2 && token.word === 'bin' && param > 0) {
                  this._mode = 4;
                  token.data = Buffer.alloc(param);
                  token.length = 0;
                } else if (token.type === 2 && token.word === '\'') {
                  this._mode = 5;
                  token.data = Buffer.alloc(1);
                  token.length = 0;
                  this._readHexDigitsCount = 0;
                } else {
                  this._flushToken();
                }
              }
            }, {
              key: "_handleByte",
              value: function _handleByte(c) {
                switch (this._mode) {
                  case 4:
                    {
                      var token = this._token;
                      if (token.data && utils_1.isNum(token.length)) {
                        token.data[token.length++] = c;
                      }
                      if (!utils_1.isNum(token.length) || !token.data || token.length >= token.data.length) {
                        this._flushToken();
                      }
                      break;
                    }
                  case 5:
                    {
                      var _token = this._token;
                      var byte = parseInt(String.fromCharCode(c), 16);
                      if (isNaN(byte) || !_token.data) {
                        console.warn('Bad hex digit');
                      } else if (this._readHexDigitsCount === 0) {
                        _token.data[0] += byte * 16;
                      } else {
                        _token.data[0] += byte;
                      }
                      this._readHexDigitsCount++;
                      if (this._readHexDigitsCount === 2) {
                        _token.length = 1;
                        this._flushToken();
                      }
                      break;
                    }
                  case 1:
                    {
                      if (!isAlpha(c)) {
                        this._token = {
                          type: 2,
                          word: String.fromCharCode(c)
                        };
                        this._handleSpecialOrPush();
                      } else {
                        this._mode = 2;
                        this._token = {
                          type: 2,
                          word: String.fromCharCode(c)
                        };
                      }
                      break;
                    }
                  case 2:
                    {
                      var _token2 = this._token;
                      if (isAlpha(c)) {
                        _token2.word += String.fromCharCode(c);
                      } else if (isNumeric(c) || c === 45) {
                        this._mode = 3;
                        this._paramStr = String.fromCharCode(c);
                      } else {
                        this._handleSpecialOrPush();
                        if (c !== 32) this._handleByte(c);
                      }
                      break;
                    }
                  case 3:
                    {
                      if (isNumeric(c)) {
                        this._paramStr += String.fromCharCode(c);
                      } else {
                        this._handleSpecialOrPush();
                        if (c !== 32) this._handleByte(c);
                      }
                      break;
                    }
                  case 0:
                    {
                      switch (c) {
                        case 123:
                          this._flushToken();
                          this.push({
                            type: 0
                          });
                          break;
                        case 125:
                          this._flushToken();
                          this.push({
                            type: 1
                          });
                          break;
                        case 92:
                          this._flushToken();
                          this._mode = 1;
                          break;
                        case 13:
                        case 10:
                          break;
                        default:
                          {
                            var _token3 = this._token;
                            if (!_token3) {
                              this._token = {
                                type: 3,
                                data: Buffer.alloc(256),
                                length: 1
                              };
                              this._token.data[0] = c;
                            } else if (_token3 && _token3.type === 3) {
                              if (_token3.length >= _token3.data.length) {
                                _token3.data = Buffer.concat([_token3.data, Buffer.alloc(256)]);
                              }
                              _token3.data[_token3.length++] = c;
                            } else {
                              throw new Error('Unpushed token!');
                            }
                          }
                      }
                      break;
                    }
                  default:
                    throw new Error('Unknown state!');
                }
              }
            }, {
              key: "_transform",
              value: function _transform(chunk, encoding, cb) {
                try {
                  var buf = utils_1.isStr(chunk) ? Buffer.from(chunk, encoding) : chunk;
                  for (var i = 0; i < buf.length; i++) {
                    var c = buf[i];
                    this._handleByte(c);
                  }
                } catch (err) {
                  return cb(err);
                }
                cb();
              }
            }, {
              key: "_flush",
              value: function _flush(cb) {
                this._flushToken();
                cb();
              }
            }]);
            return Tokenize;
          }(stream_1.Transform);
          exports.Tokenize = Tokenize;
          exports.default = Tokenize;
        }).call(this);
      }).call(this, require("buffer").Buffer);
    }, {
      "./utils": 53,
      "buffer": 7,
      "stream": 57
    }],
    53: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isNum = exports.isStr = exports.isDef = void 0;
      function isDef(thing) {
        return typeof thing !== 'undefined';
      }
      exports.isDef = isDef;
      function isStr(thing) {
        return typeof thing === 'string';
      }
      exports.isStr = isStr;
      function isNum(thing) {
        return typeof thing === 'number';
      }
      exports.isNum = isNum;
    }, {}],
    54: [function (require, module, exports) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.words = void 0;
      exports.words = {
        "'": 1,
        "-": 1,
        "*": 1,
        ":": 1,
        "\\": 1,
        "_": 1,
        "{": 1,
        "|": 1,
        "}": 1,
        "~": 1,
        "ab": 2,
        "absh": 3,
        "abslock": 4,
        "absnoovrlp": 2,
        "absw": 3,
        "acaps": 2,
        "acccircle": 2,
        "acccomma": 2,
        "accdot": 2,
        "accnone": 2,
        "accunderdot": 2,
        "acf": 3,
        "adeff": 3,
        "additive": 4,
        "adeflang": 3,
        "adjustright": 4,
        "adn": 3,
        "aenddoc": 4,
        "aendnotes": 4,
        "aexpnd": 3,
        "af": 3,
        "afelev": 4,
        "afs": 3,
        "aftnbj": 4,
        "aftncn": 5,
        "aftnnalc": 4,
        "aftnnar": 4,
        "aftnnauc": 4,
        "aftnnchi": 4,
        "aftnnchosung": 4,
        "aftnncnum": 4,
        "aftnndbar": 4,
        "aftnndbnum": 4,
        "aftnndbnumd": 4,
        "aftnndbnumk": 4,
        "aftnndbnumt": 4,
        "aftnnganada": 4,
        "aftnngbnum": 4,
        "aftnngbnumd": 4,
        "aftnngbnumk": 4,
        "aftnngbnuml": 4,
        "aftnnrlc": 4,
        "aftnnruc": 4,
        "aftnnzodiac": 4,
        "aftnnzodiacd": 4,
        "aftnnzodiacl": 4,
        "aftnrestart": 4,
        "aftnrstcont": 4,
        "aftnsep": 5,
        "aftnsepc": 5,
        "aftnstart": 3,
        "aftntj": 4,
        "ai": 2,
        "alang": 3,
        "allowfieldendsel": 4,
        "allprot": 4,
        "alntblind": 4,
        "alt": 4,
        "animtext": 3,
        "annotation": 5,
        "annotprot": 4,
        "ansi": 4,
        "ansicpg": 3,
        "aoutl": 2,
        "ApplyBrkRules": 4,
        "ascaps": 2,
        "ashad": 2,
        "asianbrkrule": 4,
        "aspalpha": 2,
        "aspnum": 2,
        "astrike": 2,
        "atnauthor": 5,
        "atndate": 5,
        "atnicn": 5,
        "atnid": 5,
        "atnparent": 5,
        "atnref": 5,
        "atntime": 5,
        "atrfend": 5,
        "atrfstart": 5,
        "aul": 2,
        "auld": 2,
        "auldb": 2,
        "aulnone": 2,
        "aulw": 2,
        "aup": 3,
        "author": 5,
        "autofmtoverride": 4,
        "b": 2,
        "background": 5,
        "bdbfhdr": 4,
        "bdrrlswsix": 4,
        "bgbdiag": 4,
        "bgcross": 4,
        "bgdcross": 4,
        "bgdkbdiag": 4,
        "bgdkcross": 4,
        "bgdkdcross": 4,
        "bgdkfdiag": 4,
        "bgdkhoriz": 4,
        "bgdkvert": 4,
        "bgfdiag": 4,
        "bghoriz": 4,
        "bgvert": 4,
        "bin": 3,
        "binfsxn": 3,
        "binsxn": 3,
        "bkmkcolf": 3,
        "bkmkcoll": 3,
        "bkmkend": 5,
        "bkmkpub": 4,
        "bkmkstart": 5,
        "bliptag": 3,
        "blipuid": 5,
        "blipupi": 3,
        "blue": 3,
        "bookfold": 4,
        "bookfoldrev": 4,
        "bookfoldsheets": 3,
        "box": 4,
        "brdrart": 3,
        "brdrb": 4,
        "brdrbar": 4,
        "brdrbtw": 4,
        "brdrcf": 3,
        "brdrdash": 4,
        "brdrdashd": 4,
        "brdrdashdd": 4,
        "brdrdashdot": 4,
        "brdrdashdotdot": 4,
        "brdrdashdotstr": 4,
        "brdrdashsm": 4,
        "brdrdb": 4,
        "brdrdot": 4,
        "brdremboss": 4,
        "brdrengrave": 4,
        "brdrframe": 4,
        "brdrhair": 4,
        "brdrinset": 4,
        "brdrl": 4,
        "brdrnil": 4,
        "brdrnone": 4,
        "brdroutset": 4,
        "brdrr": 4,
        "brdrs": 4,
        "brdrsh": 4,
        "brdrt": 4,
        "brdrtbl": 4,
        "brdrth": 4,
        "brdrthtnlg": 4,
        "brdrthtnmg": 4,
        "brdrthtnsg": 4,
        "brdrtnthlg": 4,
        "brdrtnthmg": 4,
        "brdrtnthsg": 4,
        "brdrtnthtnlg": 4,
        "brdrtnthtnmg": 4,
        "brdrtnthtnsg": 4,
        "brdrtriple": 4,
        "brdrw": 3,
        "brdrwavy": 4,
        "brdrwavydb": 4,
        "brkfrm": 4,
        "brsp": 3,
        "bullet": 1,
        "buptim": 5,
        "bxe": 4,
        "caccentfive": 4,
        "caccentfour": 4,
        "caccentone": 4,
        "caccentsix": 4,
        "caccentthree": 4,
        "caccenttwo": 4,
        "cachedcolbal": 4,
        "caps": 2,
        "category": 5,
        "cb": 3,
        "cbackgroundone": 4,
        "cbackgroundtwo": 4,
        "cbpat": 3,
        "cchs": 3,
        "cell": 1,
        "cellx": 3,
        "cf": 3,
        "cfollowedhyperlink": 4,
        "cfpat": 3,
        "cgrid": 3,
        "charrsid": 3,
        "charscalex": 3,
        "chatn": 1,
        "chbgbdiag": 4,
        "chbgcross": 4,
        "chbgdcross": 4,
        "chbgdkbdiag": 4,
        "chbgdkcross": 4,
        "chbgdkdcross": 4,
        "chbgdkfdiag": 4,
        "chbgdkhoriz": 4,
        "chbgdkvert": 4,
        "chbgfdiag": 4,
        "chbghoriz": 4,
        "chbgvert": 4,
        "chbrdr": 4,
        "chcbpat": 3,
        "chcfpat": 3,
        "chdate": 1,
        "chdpa": 1,
        "chdpl": 1,
        "chftn": 1,
        "chftnsep": 1,
        "chftnsepc": 1,
        "chpgn": 1,
        "chhres": 3,
        "chshdng": 3,
        "chtime": 1,
        "chyperlink": 4,
        "clbgbdiag": 4,
        "clbgcross": 4,
        "clbgdcross": 4,
        "clbgdkbdiag": 4,
        "clbgdkcross": 4,
        "clbgdkdcross": 4,
        "clbgdkfdiag": 4,
        "clbgdkhor": 4,
        "clbgdkvert": 4,
        "clbgfdiag": 4,
        "clbghoriz": 4,
        "clbgvert": 4,
        "clbrdrb": 4,
        "clbrdrl": 4,
        "clbrdrr": 4,
        "clbrdrt": 4,
        "clcbpat": 3,
        "clcbpatraw": 3,
        "clcfpat": 3,
        "clcfpatraw": 3,
        "cldel": 4,
        "cldelauth": 3,
        "cldeldttm": 3,
        "cldgll": 4,
        "cldglu": 4,
        "clFitText": 4,
        "clftsWidth": 3,
        "clhidemark": 4,
        "clins": 4,
        "clinsauth": 3,
        "clinsdttm": 3,
        "clmgf": 4,
        "clmrg": 4,
        "clmrgd": 4,
        "clmrgdauth": 3,
        "clmrgddttm": 3,
        "clmrgdr": 4,
        "clNoWrap": 4,
        "clpadb": 3,
        "clpadfb": 3,
        "clpadfl": 3,
        "clpadfr": 3,
        "clpadft": 3,
        "clpadl": 3,
        "clpadr": 3,
        "clpadt": 3,
        "clspb": 3,
        "clspfb": 3,
        "clspfl": 3,
        "clspfr": 3,
        "clspft": 3,
        "clspl": 3,
        "clspr": 3,
        "clspt": 3,
        "clshdng": 3,
        "clshdngraw": 3,
        "clshdrawnil": 4,
        "clsplit": 4,
        "clsplitr": 4,
        "cltxbtlr": 4,
        "cltxlrtb": 4,
        "cltxlrtbv": 4,
        "cltxtbrl": 4,
        "cltxtbrlv": 4,
        "clvertalb": 4,
        "clvertalc": 4,
        "clvertalt": 4,
        "clvmgf": 4,
        "clvmrg": 4,
        "clwWidth": 3,
        "cmaindarkone": 4,
        "cmaindarktwo": 4,
        "cmainlightone": 4,
        "cmainlighttwo": 4,
        "collapsed": 4,
        "colno": 3,
        "colorschememapping": 5,
        "colortbl": 5,
        "cols": 3,
        "colsr": 3,
        "colsx": 3,
        "column": 1,
        "colw": 3,
        "comment": 5,
        "company": 5,
        "contextualspace": 4,
        "cpg": 3,
        "crauth": 3,
        "crdate": 3,
        "creatim": 5,
        "cs": 3,
        "cshade": 3,
        "ctextone": 4,
        "ctexttwo": 4,
        "ctint": 3,
        "ctrl": 4,
        "cts": 3,
        "cufi": 3,
        "culi": 3,
        "curi": 3,
        "cvmme": 4,
        "datafield": 5,
        "datastore": 5,
        "date": 4,
        "dbch": 4,
        "defchp": 5,
        "deff": 3,
        "defformat": 4,
        "deflang": 3,
        "deflangfe": 3,
        "defpap": 5,
        "defshp": 4,
        "deftab": 3,
        "deleted": 2,
        "delrsid": 3,
        "dfrauth": 3,
        "dfrdate": 3,
        "dfrmtxtx": 3,
        "dfrmtxty": 3,
        "dfrstart": 3,
        "dfrstop": 3,
        "dfrxst": 3,
        "dghorigin": 3,
        "dghshow": 3,
        "dghspace": 3,
        "dgmargin": 4,
        "dgsnap": 4,
        "dgvorigin": 3,
        "dgvshow": 3,
        "dgvspace": 3,
        "dibitmap": 3,
        "disabled": 2,
        "dn": 3,
        "dntblnsbdb": 4,
        "do": 5,
        "dobxcolumn": 4,
        "dobxmargin": 4,
        "dobxpage": 4,
        "dobymargin": 4,
        "dobypage": 4,
        "dobypara": 4,
        "doccomm": 5,
        "doctemp": 4,
        "doctype": 3,
        "docvar": 5,
        "dodhgt": 3,
        "dolock": 4,
        "donotembedlingdata": 3,
        "donotembedsysfont": 3,
        "donotshowcomments": 4,
        "donotshowinsdel": 4,
        "donotshowmarkup": 4,
        "donotshowprops": 4,
        "dpaendhol": 4,
        "dpaendl": 3,
        "dpaendsol": 4,
        "dpaendw": 3,
        "dparc": 4,
        "dparcflipx": 4,
        "dparcflipy": 4,
        "dpastarthol": 4,
        "dpastartl": 3,
        "dpastartsol": 4,
        "dpastartw": 3,
        "dpcallout": 4,
        "dpcoa": 3,
        "dpcoaccent": 4,
        "dpcobestfit": 4,
        "dpcoborder": 4,
        "dpcodabs": 4,
        "dpcodbottom": 4,
        "dpcodcenter": 4,
        "dpcodescent": 3,
        "dpcodtop": 4,
        "dpcolength": 3,
        "dpcominusx": 4,
        "dpcominusy": 4,
        "dpcooffset": 3,
        "dpcosmarta": 4,
        "dpcotdouble": 4,
        "dpcotright": 4,
        "dpcotsingle": 4,
        "dpcottriple": 4,
        "dpcount": 3,
        "dpellipse": 4,
        "dpendgroup": 4,
        "dpfillbgcb": 3,
        "dpfillbgcg": 3,
        "dpfillbgcr": 3,
        "dpfillbggray": 3,
        "dpfillbgpal": 4,
        "dpfillfgcb": 3,
        "dpfillfgcg": 3,
        "dpfillfgcr": 3,
        "dpfillfggray": 3,
        "dpfillfgpal": 4,
        "dpfillpat": 3,
        "dpgroup": 4,
        "dpline": 4,
        "dplinecob": 3,
        "dplinecog": 3,
        "dplinecor": 3,
        "dplinedado": 4,
        "dplinedadodo": 4,
        "dplinedash": 4,
        "dplinedot": 4,
        "dplinegray": 3,
        "dplinehollow": 4,
        "dplinepal": 4,
        "dplinesolid": 4,
        "dplinew": 3,
        "dppolycount": 3,
        "dppolygon": 4,
        "dppolyline": 4,
        "dpptx": 3,
        "dppty": 3,
        "dprect": 4,
        "dproundr": 4,
        "dpshadow": 4,
        "dpshadx": 3,
        "dpshady": 3,
        "dptxbtlr": 4,
        "dptxbx": 4,
        "dptxbxmar": 3,
        "dptxbxtext": 5,
        "dptxlrtb": 4,
        "dptxlrtbv": 4,
        "dptxtbrl": 4,
        "dptxtbrlv": 4,
        "dpx": 3,
        "dpxsize": 3,
        "dpy": 3,
        "dpysize": 3,
        "dropcapli": 3,
        "dropcapt": 3,
        "ds": 3,
        "dxfrtext": 3,
        "dy": 3,
        "ebcend": 5,
        "ebcstart": 5,
        "edmins": 3,
        "embo": 2,
        "emdash": 1,
        "emfblip": 4,
        "emspace": 1,
        "endash": 1,
        "enddoc": 4,
        "endnhere": 4,
        "endnotes": 4,
        "enforceprot": 3,
        "enspace": 1,
        "expnd": 3,
        "expndtw": 3,
        "expshrtn": 4,
        "f": 3,
        "faauto": 4,
        "facenter": 4,
        "facingp": 4,
        "factoidname": 5,
        "fafixed": 4,
        "fahang": 4,
        "falt": 5,
        "faroman": 4,
        "favar": 4,
        "fbias": 3,
        "fbidi": 4,
        "fbidis": 4,
        "fbimajor": 4,
        "fbiminor": 4,
        "fchars": 5,
        "fcharset": 3,
        "fcs": 3,
        "fdbmajor": 4,
        "fdbminor": 4,
        "fdecor": 4,
        "felnbrelev": 4,
        "fet": 3,
        "fetch": 4,
        "ffdefres": 3,
        "ffdeftext": 5,
        "ffentrymcr": 5,
        "ffexitmcr": 5,
        "ffformat": 5,
        "ffhaslistbox": 3,
        "ffhelptext": 5,
        "ffhps": 3,
        "ffl": 5,
        "ffmaxlen": 3,
        "ffname": 5,
        "ffownhelp": 3,
        "ffownstat": 3,
        "ffprot": 3,
        "ffrecalc": 3,
        "ffres": 3,
        "ffsize": 3,
        "ffstattext": 5,
        "fftype": 3,
        "fftypetxt": 3,
        "fhimajor": 4,
        "fhiminor": 4,
        "fi": 3,
        "fid": 3,
        "field": 5,
        "file": 5,
        "filetbl": 5,
        "fittext": 3,
        "fjgothic": 4,
        "fjminchou": 4,
        "fldalt": 4,
        "flddirty": 4,
        "fldedit": 4,
        "fldinst": 5,
        "fldlock": 4,
        "fldpriv": 4,
        "fldrslt": 5,
        "fldtype": 5,
        "flomajor": 4,
        "flominor": 4,
        "fmodern": 4,
        "fn": 3,
        "fname": 5,
        "fnetwork": 4,
        "fnil": 4,
        "fnonfilesys": 4,
        "fontemb": 5,
        "fontfile": 5,
        "fonttbl": 5,
        "footer": 5,
        "footerf": 5,
        "footerl": 5,
        "footerr": 5,
        "footery": 3,
        "footnote": 5,
        "forceupgrade": 4,
        "formatConverter": 5,
        "formdisp": 4,
        "formfield": 5,
        "formprot": 4,
        "formshade": 4,
        "fosnum": 3,
        "fprq": 3,
        "fracwidth": 4,
        "frelative": 3,
        "frmtxbtlr": 4,
        "frmtxlrtb": 4,
        "frmtxlrtbv": 4,
        "frmtxtbrl": 4,
        "frmtxtbrlv": 4,
        "froman": 4,
        "fromhtml": 3,
        "fromtext": 4,
        "fs": 3,
        "fscript": 4,
        "fswiss": 4,
        "ftech": 4,
        "ftnalt": 4,
        "ftnbj": 4,
        "ftncn": 5,
        "ftnil": 4,
        "ftnlytwnine": 4,
        "ftnnalc": 4,
        "ftnnar": 4,
        "ftnnauc": 4,
        "ftnnchi": 4,
        "ftnnchosung": 4,
        "ftnncnum": 4,
        "ftnndbar": 4,
        "ftnndbnum": 4,
        "ftnndbnumd": 4,
        "ftnndbnumk": 4,
        "ftnndbnumt": 4,
        "ftnnganada": 4,
        "ftnngbnum": 4,
        "ftnngbnumd": 4,
        "ftnngbnumk": 4,
        "ftnngbnuml": 4,
        "ftnnrlc": 4,
        "ftnnruc": 4,
        "ftnnzodiac": 4,
        "ftnnzodiacd": 4,
        "ftnnzodiacl": 4,
        "ftnrestart": 4,
        "ftnrstcont": 4,
        "ftnrstpg": 4,
        "ftnsep": 5,
        "ftnsepc": 5,
        "ftnstart": 3,
        "ftntj": 4,
        "fttruetype": 4,
        "fvaliddos": 4,
        "fvalidhpfs": 4,
        "fvalidmac": 4,
        "fvalidntfs": 4,
        "g": 5,
        "gcw": 3,
        "generator": 5,
        "green": 3,
        "grfdocevents": 3,
        "gridtbl": 5,
        "gutter": 3,
        "gutterprl": 4,
        "guttersxn": 3,
        "header": 5,
        "headerf": 5,
        "headerl": 5,
        "headerr": 5,
        "headery": 3,
        "hich": 4,
        "highlight": 3,
        "hl": 5,
        "hlfr": 5,
        "hlinkbase": 5,
        "hlloc": 5,
        "hlsrc": 5,
        "horzdoc": 4,
        "horzsect": 4,
        "horzvert": 3,
        "hr": 3,
        "hres": 3,
        "hrule": 4,
        "hsv": 5,
        "htmautsp": 4,
        "htmlbase": 4,
        "htmlrtf": 2,
        "htmltag": 5,
        "hwelev": 4,
        "hyphauto": 2,
        "hyphcaps": 2,
        "hyphconsec": 3,
        "hyphhotz": 3,
        "hyphpar": 2,
        "i": 2,
        "id": 3,
        "ignoremixedcontent": 3,
        "ilfomacatclnup": 3,
        "ilvl": 3,
        "impr": 2,
        "indmirror": 4,
        "indrlsweleven": 4,
        "info": 5,
        "insrsid": 3,
        "intbl": 4,
        "ipgp": 3,
        "irowband": 3,
        "irow": 3,
        "itap": 3,
        "ixe": 4,
        "jcompress": 4,
        "jexpand": 4,
        "jis": 4,
        "jpegblip": 4,
        "jsksu": 4,
        "keep": 4,
        "keepn": 4,
        "kerning": 3,
        "keycode": 5,
        "keywords": 5,
        "krnprsnet": 4,
        "ksulang": 3,
        "jclisttab": 4,
        "landscape": 4,
        "lang": 3,
        "langfe": 3,
        "langfenp": 3,
        "langnp": 3,
        "lastrow": 4,
        "latentstyles": 5,
        "lbr": 3,
        "lchars": 5,
        "ldblquote": 1,
        "level": 3,
        "levelfollow": 3,
        "levelindent": 3,
        "leveljc": 3,
        "leveljcn": 3,
        "levellegal": 3,
        "levelnfc": 3,
        "levelnfcn": 3,
        "levelnorestart": 3,
        "levelnumbers": 5,
        "levelold": 3,
        "levelpicture": 3,
        "levelpicturenosize": 4,
        "levelprev": 3,
        "levelprevspace": 3,
        "levelspace": 3,
        "levelstartat": 3,
        "leveltemplateid": 3,
        "leveltext": 5,
        "lfolevel": 5,
        "li": 3,
        "line": 1,
        "linebetcol": 4,
        "linecont": 4,
        "linemod": 3,
        "lineppage": 4,
        "linerestart": 4,
        "linestart": 3,
        "linestarts": 3,
        "linex": 3,
        "linkself": 4,
        "linkstyles": 4,
        "linkval": 5,
        "lin": 3,
        "lisa": 3,
        "lisb": 3,
        "list": 5,
        "listhybrid": 4,
        "listid": 3,
        "listlevel": 5,
        "listname": 5,
        "listoverride": 5,
        "listoverridecount": 3,
        "listoverrideformat": 3,
        "listoverridestartat": 4,
        "listoverridetable": 5,
        "listpicture": 5,
        "listrestarthdn": 3,
        "listsimple": 3,
        "liststyleid": 3,
        "liststylename": 5,
        "listtable": 5,
        "listtemplateid": 3,
        "listtext": 5,
        "lnbrkrule": 4,
        "lndscpsxn": 4,
        "lnongrid": 4,
        "loch": 4,
        "lquote": 1,
        "ls": 3,
        "lsdlocked": 3,
        "lsdlockeddef": 3,
        "lsdlockedexcept": 5,
        "lsdpriority": 3,
        "lsdprioritydef": 3,
        "lsdqformat": 3,
        "lsdqformatdef": 3,
        "lsdsemihidden": 3,
        "lsdsemihiddendef": 3,
        "lsdstimax": 3,
        "lsdunhideused": 3,
        "lsdunhideuseddef": 3,
        "ltrch": 4,
        "ltrdoc": 4,
        "ltrmark": 1,
        "ltrpar": 4,
        "ltrrow": 4,
        "ltrsect": 4,
        "lvltentative": 4,
        "lytcalctblwd": 4,
        "lytexcttp": 4,
        "lytprtmet": 4,
        "lyttblrtgr": 4,
        "mac": 4,
        "macc": 5,
        "maccPr": 5,
        "macpict": 4,
        "mailmerge": 5,
        "makebackup": 4,
        "maln": 5,
        "malnScr": 5,
        "manager": 5,
        "margb": 3,
        "margbsxn": 3,
        "margl": 3,
        "marglsxn": 3,
        "margmirror": 4,
        "margmirsxn": 4,
        "margPr": 5,
        "margr": 3,
        "margrsxn": 3,
        "margSz": 3,
        "margt": 3,
        "margtsxn": 3,
        "mbar": 5,
        "mbarPr": 5,
        "mbaseJc": 5,
        "mbegChr": 5,
        "mborderBox": 5,
        "mborderBoxPr": 5,
        "mbox": 5,
        "mboxPr": 5,
        "mbrk": 3,
        "mbrkBin": 3,
        "mbrkBinSub": 3,
        "mcGp": 3,
        "mcGpRule": 3,
        "mchr": 5,
        "mcount": 5,
        "mcSp": 3,
        "mctrlPr": 5,
        "md": 5,
        "mdefJc": 3,
        "mdeg": 5,
        "mdegHide": 5,
        "mden": 5,
        "mdiff": 5,
        "mdiffSty": 3,
        "mdispDef": 3,
        "mdPr": 5,
        "me": 5,
        "mendChr": 5,
        "meqArr": 5,
        "meqArrPr": 5,
        "mf": 5,
        "mfName": 5,
        "mfPr": 5,
        "mfunc": 5,
        "mfuncPr": 5,
        "mgroupChr": 5,
        "mgroupChrPr": 5,
        "mgrow": 5,
        "mhideBot": 5,
        "mhideLeft": 5,
        "mhideRight": 5,
        "mhideTop": 5,
        "mhtmltag": 5,
        "min": 3,
        "minterSp": 3,
        "mintLim": 3,
        "mintraSp": 3,
        "mjc": 3,
        "mlim": 5,
        "mlimLoc": 5,
        "mlimLow": 5,
        "mlimLowPr": 5,
        "mlimUpp": 5,
        "mlimUppPr": 5,
        "mlit": 4,
        "mlMargin": 3,
        "mm": 5,
        "mmaddfieldname": 5,
        "mmath": 5,
        "mmathFont": 3,
        "mmathPict": 5,
        "mmathPr": 5,
        "mmattach": 4,
        "mmaxDist": 5,
        "mmblanklines": 4,
        "mmc": 5,
        "mmcJc": 5,
        "mmconnectstr": 5,
        "mmconnectstrdata": 5,
        "mmcPr": 5,
        "mmcs": 5,
        "mmdatasource": 5,
        "mmdatatypeaccess": 4,
        "mmdatatypeexcel": 4,
        "mmdatatypefile": 4,
        "mmdatatypeodbc": 4,
        "mmdatatypeodso": 4,
        "mmdatatypeqt": 4,
        "mmdefaultsql": 4,
        "mmdestemail": 4,
        "mmdestfax": 4,
        "mmdestnewdoc": 4,
        "mmdestprinter": 4,
        "mmerrors": 3,
        "mmfttypeaddress": 4,
        "mmfttypebarcode": 4,
        "mmfttypedbcolumn": 4,
        "mmfttypemapped": 4,
        "mmfttypenull": 4,
        "mmfttypesalutation": 4,
        "mmheadersource": 5,
        "mmjdsotype": 3,
        "mmlinktoquery": 4,
        "mmmailsubject": 5,
        "mmmaintypecatalog": 4,
        "mmmaintypeemail": 4,
        "mmmaintypeenvelopes": 4,
        "mmmaintypefax": 4,
        "mmmaintypelabels": 4,
        "mmmaintypeletters": 4,
        "mmodso": 5,
        "mmodsoactive": 3,
        "mmodsocoldelim": 3,
        "mmodsocolumn": 3,
        "mmodsodynaddr": 3,
        "mmodsofhdr": 3,
        "mmodsofilter": 5,
        "mmodsofldmpdata": 5,
        "mmodsofmcolumn": 3,
        "mmodsohash": 3,
        "mmodsolid": 3,
        "mmodsomappedname": 5,
        "mmodsoname": 5,
        "mmodsorecipdata": 5,
        "mmodsosort": 5,
        "mmodsosrc": 5,
        "mmodsotable": 5,
        "mmodsoudl": 5,
        "mmodsoudldata": 5,
        "mmodsouniquetag": 5,
        "mmPr": 5,
        "mmquery": 5,
        "mmr": 5,
        "mmreccur": 3,
        "mmshowdata": 4,
        "mnary": 5,
        "mnaryLim": 3,
        "mnaryPr": 5,
        "mnoBreak": 5,
        "mnor": 4,
        "mnum": 5,
        "mo": 3,
        "mobjDist": 5,
        "moMath": 5,
        "moMathPara": 5,
        "moMathParaPr": 5,
        "mopEmu": 5,
        "mphant": 5,
        "mphantPr": 5,
        "mplcHide": 5,
        "mpos": 5,
        "mpostSp": 3,
        "mpreSp": 3,
        "mr": 5,
        "mrad": 5,
        "mradPr": 5,
        "mrMargin": 3,
        "mrPr": 5,
        "mrSp": 3,
        "mrSpRule": 3,
        "mscr": 3,
        "msepChr": 5,
        "mshow": 5,
        "mshp": 5,
        "msmallFrac": 3,
        "msmcap": 4,
        "msPre": 5,
        "msPrePr": 5,
        "msSub": 5,
        "msSubPr": 5,
        "msSubSup": 5,
        "msSubSupPr": 5,
        "msSup": 5,
        "msSupPr": 5,
        "mstrikeBLTR": 5,
        "mstrikeH": 5,
        "mstrikeTLBR": 5,
        "mstrikeV": 5,
        "msty": 3,
        "msub": 5,
        "msubHide": 5,
        "msup": 5,
        "msupHide": 5,
        "mtransp": 5,
        "mtype": 5,
        "muser": 4,
        "mvauth": 3,
        "mvdate": 3,
        "mvertJc": 5,
        "mvf": 4,
        "mvfmf": 5,
        "mvfml": 5,
        "mvt": 4,
        "mvtof": 5,
        "mvtol": 5,
        "mwrapIndent": 3,
        "mwrapRight": 3,
        "mzeroAsc": 5,
        "mzeroDesc": 5,
        "mzeroWid": 5,
        "nestcell": 1,
        "nestrow": 1,
        "nesttableprops": 5,
        "newtblstyruls": 4,
        "nextfile": 5,
        "noafcnsttbl": 4,
        "nobrkwrptbl": 4,
        "nocolbal": 4,
        "nocompatoptions": 4,
        "nocwrap": 4,
        "nocxsptable": 4,
        "noextrasprl": 4,
        "nofchars": 3,
        "nofcharsws": 3,
        "nofeaturethrottle": 4,
        "nofpages": 3,
        "nofwords": 3,
        "nogrowautofit": 4,
        "noindnmbrts": 4,
        "nojkernpunct": 4,
        "nolead": 4,
        "noline": 4,
        "nolnhtadjtbl": 4,
        "nonesttables": 5,
        "nonshppict": 5,
        "nooverflow": 4,
        "noproof": 4,
        "noqfpromote": 4,
        "nosectexpand": 4,
        "nosnaplinegrid": 4,
        "nospaceforul": 4,
        "nosupersub": 4,
        "notabind": 4,
        "notbrkcnstfrctbl": 4,
        "notcvasp": 4,
        "notvatxbx": 4,
        "nouicompat": 4,
        "noultrlspc": 4,
        "nowidctlpar": 4,
        "nowrap": 4,
        "nowwrap": 4,
        "noxlattoyen": 4,
        "objalias": 5,
        "objalign": 3,
        "objattph": 4,
        "objautlink": 4,
        "objclass": 5,
        "objcropb": 3,
        "objcropl": 3,
        "objcropr": 3,
        "objcropt": 3,
        "objdata": 5,
        "object": 5,
        "objemb": 4,
        "objh": 3,
        "objhtml": 4,
        "objicemb": 4,
        "objlink": 4,
        "objlock": 4,
        "objname": 5,
        "objocx": 4,
        "objpub": 4,
        "objscalex": 3,
        "objscaley": 3,
        "objsect": 5,
        "objsetsize": 4,
        "objsub": 4,
        "objtime": 5,
        "objtransy": 3,
        "objupdate": 4,
        "objw": 3,
        "ogutter": 3,
        "oldas": 4,
        "oldcprops": 5,
        "oldlinewrap": 4,
        "oldpprops": 5,
        "oldsprops": 5,
        "oldtprops": 5,
        "oleclsid": 5,
        "operator": 5,
        "otblrul": 4,
        "outl": 2,
        "outlinelevel": 3,
        "overlay": 4,
        "page": 1,
        "pagebb": 4,
        "panose": 5,
        "paperh": 3,
        "paperw": 3,
        "par": 1,
        "pararsid": 3,
        "pard": 4,
        "password": 5,
        "passwordhash": 5,
        "pc": 4,
        "pca": 4,
        "pgbrdrb": 4,
        "pgbrdrfoot": 4,
        "pgbrdrhead": 4,
        "pgbrdrl": 4,
        "pgbrdropt": 3,
        "pgbrdrr": 4,
        "pgbrdrsnap": 4,
        "pgbrdrt": 4,
        "pghsxn": 3,
        "pgnbidia": 4,
        "pgnbidib": 4,
        "pgnchosung": 4,
        "pgncnum": 4,
        "pgncont": 4,
        "pgndbnum": 4,
        "pgndbnumd": 4,
        "pgndbnumk": 4,
        "pgndbnumt": 4,
        "pgndec": 4,
        "pgndecd": 4,
        "pgnganada": 4,
        "pgngbnum": 4,
        "pgngbnumd": 4,
        "pgngbnumk": 4,
        "pgngbnuml": 4,
        "pgnhindia": 4,
        "pgnhindib": 4,
        "pgnhindic": 4,
        "pgnhindid": 4,
        "pgnhn": 3,
        "pgnhnsc": 4,
        "pgnhnsh": 4,
        "pgnhnsm": 4,
        "pgnhnsn": 4,
        "pgnhnsp": 4,
        "pgnid": 4,
        "pgnlcltr": 4,
        "pgnlcrm": 4,
        "pgnrestart": 4,
        "pgnstart": 3,
        "pgnstarts": 3,
        "pgnthaia": 4,
        "pgnthaib": 4,
        "pgnthaic": 4,
        "pgnucltr": 4,
        "pgnucrm": 4,
        "pgnvieta": 4,
        "pgnx": 3,
        "pgny": 3,
        "pgnzodiac": 4,
        "pgnzodiacd": 4,
        "pgnzodiacl": 4,
        "pgp": 5,
        "pgptbl": 5,
        "pgwsxn": 3,
        "phcol": 4,
        "phmrg": 4,
        "phpg": 4,
        "picbmp": 4,
        "picbpp": 3,
        "piccropb": 3,
        "piccropl": 3,
        "piccropr": 3,
        "piccropt": 3,
        "pich": 3,
        "pichgoal": 3,
        "picprop": 5,
        "picscaled": 4,
        "picscalex": 3,
        "picscaley": 3,
        "pict": 5,
        "picw": 3,
        "picwgoal": 3,
        "pindtabqc": 4,
        "pindtabql": 4,
        "pindtabqr": 4,
        "plain": 4,
        "pmartabqc": 4,
        "pmartabql": 4,
        "pmartabqr": 4,
        "pmmetafile": 3,
        "pn": 5,
        "pnacross": 4,
        "pnaiu": 4,
        "pnaiud": 4,
        "pnaiueo": 4,
        "pnaiueod": 4,
        "pnb": 2,
        "pnbidia": 4,
        "pnbidib": 4,
        "pncaps": 2,
        "pncard": 4,
        "pncf": 3,
        "pnchosung": 4,
        "pncnum": 4,
        "pndbnum": 4,
        "pndbnumd": 4,
        "pndbnumk": 4,
        "pndbnuml": 4,
        "pndbnumt": 4,
        "pndec": 4,
        "pndecd": 4,
        "pnf": 3,
        "pnfs": 3,
        "pnganada": 4,
        "pngblip": 4,
        "pngbnum": 4,
        "pngbnumd": 4,
        "pngbnumk": 4,
        "pngbnuml": 4,
        "pnhang": 4,
        "pni": 2,
        "pnindent": 3,
        "pniroha": 4,
        "pnirohad": 4,
        "pnlcltr": 4,
        "pnlcrm": 4,
        "pnlvl": 3,
        "pnlvlblt": 4,
        "pnlvlbody": 4,
        "pnlvlcont": 4,
        "pnnumonce": 4,
        "pnord": 4,
        "pnordt": 4,
        "pnprev": 4,
        "pnqc": 4,
        "pnql": 4,
        "pnqr": 4,
        "pnrauth": 3,
        "pnrdate": 3,
        "pnrestart": 4,
        "pnrnfc": 3,
        "pnrnot": 4,
        "pnrpnbr": 3,
        "pnrrgb": 3,
        "pnrstart": 3,
        "pnrstop": 3,
        "pnrxst": 3,
        "pnscaps": 2,
        "pnseclvl": 5,
        "pnsp": 3,
        "pnstart": 3,
        "pnstrike": 2,
        "pntext": 5,
        "pntxta": 5,
        "pntxtb": 5,
        "pnucltr": 4,
        "pnucrm": 4,
        "pnul": 2,
        "pnuld": 4,
        "pnuldash": 4,
        "pnuldashd": 4,
        "pnuldashdd": 4,
        "pnuldb": 4,
        "pnulhair": 4,
        "pnulnone": 4,
        "pnulth": 4,
        "pnulw": 4,
        "pnulwave": 4,
        "pnzodiac": 4,
        "pnzodiacd": 4,
        "pnzodiacl": 4,
        "posnegx": 3,
        "posnegy": 3,
        "posx": 3,
        "posxc": 4,
        "posxi": 4,
        "posxl": 4,
        "posxo": 4,
        "posxr": 4,
        "posy": 3,
        "posyb": 4,
        "posyc": 4,
        "posyil": 4,
        "posyin": 4,
        "posyout": 4,
        "posyt": 4,
        "prauth": 3,
        "prcolbl": 4,
        "prdate": 3,
        "printdata": 4,
        "printim": 5,
        "private": 5,
        "propname": 5,
        "proptype": 3,
        "protect": 2,
        "protend": 5,
        "protlevel": 3,
        "protstart": 5,
        "protusertbl": 5,
        "psover": 4,
        "psz": 3,
        "ptabldot": 4,
        "ptablmdot": 4,
        "ptablminus": 4,
        "ptablnone": 4,
        "ptabluscore": 4,
        "pubauto": 4,
        "pvmrg": 4,
        "pvpara": 4,
        "pvpg": 4,
        "pwd": 3,
        "pxe": 5,
        "qc": 4,
        "qd": 4,
        "qj": 4,
        "qk": 3,
        "ql": 4,
        "qmspace": 1,
        "qr": 4,
        "qt": 4,
        "rawclbgdkbdiag": 4,
        "rawclbgbdiag": 4,
        "rawclbgcross": 4,
        "rawclbgdcross": 4,
        "rawclbgdkcross": 4,
        "rawclbgdkdcross": 4,
        "rawclbgdkfdiag": 4,
        "rawclbgdkhor": 4,
        "rawclbgdkvert": 4,
        "rawclbgfdiag": 4,
        "rawclbghoriz": 4,
        "rawclbgvert": 4,
        "rdblquote": 1,
        "readonlyrecommended": 4,
        "readprot": 4,
        "red": 3,
        "relyonvml": 3,
        "remdttm": 4,
        "rempersonalinfo": 4,
        "result": 5,
        "revauth": 3,
        "revauthdel": 3,
        "revbar": 3,
        "revdttm": 3,
        "revdttmdel": 3,
        "revised": 2,
        "revisions": 4,
        "revprop": 3,
        "revprot": 4,
        "revtbl": 5,
        "revtim": 5,
        "ri": 3,
        "rin": 3,
        "row": 1,
        "rquote": 1,
        "rsid": 3,
        "rsidroot": 3,
        "rsidtbl": 5,
        "rsltbmp": 4,
        "rslthtml": 4,
        "rsltmerge": 4,
        "rsltpict": 4,
        "rsltrtf": 4,
        "rslttxt": 4,
        "rtf": 5,
        "rtlch": 4,
        "rtldoc": 4,
        "rtlgutter": 4,
        "rtlmark": 1,
        "rtlpar": 4,
        "rtlrow": 4,
        "rtlsect": 4,
        "rxe": 5,
        "s": 3,
        "sa": 3,
        "saauto": 2,
        "saftnnalc": 4,
        "saftnnar": 4,
        "saftnnauc": 4,
        "saftnnchi": 4,
        "saftnnchosung": 4,
        "saftnncnum": 4,
        "saftnndbar": 4,
        "saftnndbnum": 4,
        "saftnndbnumd": 4,
        "saftnndbnumk": 4,
        "saftnndbnumt": 4,
        "saftnnganada": 4,
        "saftnngbnum": 4,
        "saftnngbnumd": 4,
        "saftnngbnumk": 4,
        "saftnngbnuml": 4,
        "saftnnrlc": 4,
        "saftnnruc": 4,
        "saftnnzodiac": 4,
        "saftnnzodiacd": 4,
        "saftnnzodiacl": 4,
        "saftnrestart": 4,
        "saftnrstcont": 4,
        "saftnstart": 3,
        "sautoupd": 4,
        "saveinvalidxml": 4,
        "saveprevpict": 4,
        "sb": 3,
        "sbasedon": 3,
        "sbauto": 2,
        "sbkcol": 4,
        "sbkeven": 4,
        "sbknone": 4,
        "sbkodd": 4,
        "sbkpage": 4,
        "sbys": 4,
        "scaps": 2,
        "scompose": 4,
        "sec": 3,
        "sect": 1,
        "sectd": 4,
        "sectdefaultcl": 4,
        "sectexpand": 3,
        "sectlinegrid": 3,
        "sectnum": 1,
        "sectrsid": 3,
        "sectspecifycl": 4,
        "sectspecifygen": 4,
        "sectspecifyl": 4,
        "sectunlocked": 4,
        "sftnbj": 4,
        "sftnnalc": 4,
        "sftnnar": 4,
        "sftnnauc": 4,
        "sftnnchi": 4,
        "sftnnchosung": 4,
        "sftnncnum": 4,
        "sftnndbar": 4,
        "sftnndbnum": 4,
        "sftnndbnumd": 4,
        "sftnndbnumk": 4,
        "sftnndbnumt": 4,
        "sftnnganada": 4,
        "sftnngbnum": 4,
        "sftnngbnumd": 4,
        "sftnngbnumk": 4,
        "sftnngbnuml": 4,
        "sftnnrlc": 4,
        "sftnnruc": 4,
        "sftnnzodiac": 4,
        "sftnnzodiacd": 4,
        "sftnnzodiacl": 4,
        "sftnrestart": 4,
        "sftnrstcont": 4,
        "sftnrstpg": 4,
        "sftnstart": 3,
        "sftntj": 4,
        "shad": 2,
        "shading": 3,
        "shidden": 4,
        "shift": 4,
        "showplaceholdtext": 3,
        "showxmlerrors": 3,
        "shp": 5,
        "shpbottom": 3,
        "shpbxcolumn": 4,
        "shpbxignore": 4,
        "shpbxmargin": 4,
        "shpbxpage": 4,
        "shpbyignore": 4,
        "shpbymargin": 4,
        "shpbypage": 4,
        "shpbypara": 4,
        "shpfblwtxt": 3,
        "shpfhdr": 3,
        "shpgrp": 5,
        "shpinst": 5,
        "shpleft": 3,
        "shplid": 3,
        "shplockanchor": 4,
        "shppict": 5,
        "shpright": 3,
        "shprslt": 5,
        "shptop": 3,
        "shptxt": 5,
        "shpwrk": 3,
        "shpwr": 3,
        "shpz": 3,
        "sl": 3,
        "slink": 3,
        "slmult": 3,
        "slocked": 4,
        "sn": 5,
        "snaptogridincell": 4,
        "snext": 3,
        "softcol": 4,
        "softlheight": 3,
        "softline": 4,
        "softpage": 4,
        "sp": 5,
        "spersonal": 4,
        "spltpgpar": 4,
        "splytwnine": 4,
        "spriority": 3,
        "sprsbsp": 4,
        "sprslnsp": 4,
        "sprsspbf": 4,
        "sprstsm": 4,
        "sprstsp": 4,
        "spv": 4,
        "sqformat": 4,
        "srauth": 3,
        "srdate": 3,
        "sreply": 4,
        "ssemihidden": 3,
        "staticval": 5,
        "stextflow": 3,
        "strike": 2,
        "striked": 2,
        "stshfbi": 3,
        "stshfdbch": 3,
        "stshfhich": 3,
        "stshfloch": 3,
        "stylelock": 4,
        "stylelockbackcomp": 4,
        "stylelockenforced": 4,
        "stylelockqfset": 4,
        "stylelocktheme": 4,
        "stylesheet": 5,
        "stylesortmethod": 3,
        "styrsid": 3,
        "sub": 4,
        "subdocument": 3,
        "subfontbysize": 4,
        "subject": 5,
        "sunhideused": 3,
        "super": 4,
        "sv": 5,
        "svb": 5,
        "swpbdr": 4,
        "tab": 1,
        "tabsnoovrlp": 4,
        "taprtl": 4,
        "tb": 3,
        "tblind": 3,
        "tblindtype": 3,
        "tbllkbestfit": 4,
        "tbllkborder": 4,
        "tbllkcolor": 4,
        "tbllkfont": 4,
        "tbllkhdrcols": 4,
        "tbllkhdrrows": 4,
        "tbllklastcol": 4,
        "tbllklastrow": 4,
        "tbllknocolband": 4,
        "tbllknorowband": 4,
        "tbllkshading": 4,
        "tblrsid": 3,
        "tc": 5,
        "tcelld": 4,
        "tcf": 3,
        "tcl": 3,
        "tcn": 4,
        "tdfrmtxtBottom": 3,
        "tdfrmtxtLeft": 3,
        "tdfrmtxtRight": 3,
        "tdfrmtxtTop": 3,
        "template": 5,
        "themedata": 5,
        "themelang": 3,
        "themelangcs": 3,
        "themelangfe": 3,
        "time": 4,
        "title": 5,
        "titlepg": 4,
        "tldot": 4,
        "tleq": 4,
        "tlhyph": 4,
        "tlmdot": 4,
        "tlth": 4,
        "tlul": 4,
        "toplinepunct": 4,
        "tphcol": 4,
        "tphmrg": 4,
        "tphpg": 4,
        "tposnegx": 3,
        "tposnegy": 3,
        "tposxc": 4,
        "tposxi": 4,
        "tposxl": 4,
        "tposx": 3,
        "tposxo": 4,
        "tposxr": 4,
        "tposy": 3,
        "tposyb": 4,
        "tposyc": 4,
        "tposyil": 4,
        "tposyin": 4,
        "tposyout": 4,
        "tposyt": 4,
        "tpvmrg": 4,
        "tpvpara": 4,
        "tpvpg": 4,
        "tqc": 4,
        "tqdec": 4,
        "tqr": 4,
        "trackformatting": 3,
        "trackmoves": 3,
        "transmf": 4,
        "trauth": 3,
        "trautofit": 2,
        "trbgbdiag": 4,
        "trbgcross": 4,
        "trbgdcross": 4,
        "trbgdkbdiag": 4,
        "trbgdkcross": 4,
        "trbgdkdcross": 4,
        "trbgdkfdiag": 4,
        "trbgdkhor": 4,
        "trbgdkvert": 4,
        "trbgfdiag": 4,
        "trbghoriz": 4,
        "trbgvert": 4,
        "trbrdrb": 4,
        "trbrdrh": 4,
        "trbrdrl": 4,
        "trbrdrr": 4,
        "trbrdrt": 4,
        "trbrdrv": 4,
        "trcbpat": 3,
        "trcfpat": 3,
        "trdate": 3,
        "trftsWidthA": 3,
        "trftsWidthB": 3,
        "trftsWidth": 3,
        "trgaph": 3,
        "trhdr": 4,
        "trkeep": 4,
        "trkeepfollow": 4,
        "trleft": 3,
        "trowd": 4,
        "trpaddb": 3,
        "trpaddfb": 3,
        "trpaddfl": 3,
        "trpaddfr": 3,
        "trpaddft": 3,
        "trpaddl": 3,
        "trpaddr": 3,
        "trpaddt": 3,
        "trpadob": 3,
        "trpadofb": 3,
        "trpadofl": 3,
        "trpadofr": 3,
        "trpadoft": 3,
        "trpadol": 3,
        "trpador": 3,
        "trpadot": 3,
        "trpat": 3,
        "trqc": 4,
        "trql": 4,
        "trqr": 4,
        "trrh": 3,
        "trshdng": 3,
        "trspdb": 3,
        "trspdfb": 3,
        "trspdfl": 3,
        "trspdfr": 3,
        "trspdft": 3,
        "trspdl": 3,
        "trspdr": 3,
        "trspdt": 3,
        "trspob": 3,
        "trspofb": 3,
        "trspofl": 3,
        "trspofr": 3,
        "trspoft": 3,
        "trspol": 3,
        "trspor": 3,
        "trspot": 3,
        "truncatefontheight": 4,
        "truncex": 4,
        "trwWidthA": 3,
        "trwWidthB": 3,
        "trwWidth": 3,
        "ts": 3,
        "tsbgbdiag": 4,
        "tsbgcross": 4,
        "tsbgdcross": 4,
        "tsbgdkbdiag": 4,
        "tsbgdkcross": 4,
        "tsbgdkdcross": 4,
        "tsbgdkfdiag": 4,
        "tsbgdkhor": 4,
        "tsbgdkvert": 4,
        "tsbgfdiag": 4,
        "tsbghoriz": 4,
        "tsbgvert": 4,
        "tsbrdrb": 4,
        "tsbrdrdgl": 4,
        "tsbrdrdgr": 4,
        "tsbrdrh": 4,
        "tsbrdrl": 4,
        "tsbrdrr": 4,
        "tsbrdrt": 4,
        "tsbrdrv": 4,
        "tscbandhorzeven": 4,
        "tscbandhorzodd": 4,
        "tscbandsh": 3,
        "tscbandsv": 3,
        "tscbandverteven": 4,
        "tscbandvertodd": 4,
        "tscellcbpat": 3,
        "tscellcfpat": 3,
        "tscellpaddb": 3,
        "tscellpaddfb": 3,
        "tscellpaddfl": 3,
        "tscellpaddfr": 3,
        "tscellpaddft": 3,
        "tscellpaddl": 3,
        "tscellpaddr": 3,
        "tscellpaddt": 3,
        "tscellpct": 3,
        "tscellwidth": 3,
        "tscellwidthfts": 3,
        "tscfirstcol": 4,
        "tscfirstrow": 4,
        "tsclastcol": 4,
        "tsclastrow": 4,
        "tscnecell": 4,
        "tscnwcell": 4,
        "tscsecell": 4,
        "tscswcell": 4,
        "tsd": 4,
        "tsnowrap": 4,
        "tsrowd": 4,
        "tsvertalb": 4,
        "tsvertalc": 4,
        "tsvertalt": 4,
        "twoinone": 3,
        "twoonone": 4,
        "tx": 3,
        "txbxtwalways": 4,
        "txbxtwfirst": 4,
        "txbxtwfirstlast": 4,
        "txbxtwlast": 4,
        "txbxtwno": 4,
        "txe": 5,
        "u": 3,
        "uc": 3,
        "ud": 5,
        "ul": 2,
        "ulc": 3,
        "uld": 4,
        "uldash": 2,
        "uldashd": 2,
        "uldashdd": 2,
        "uldb": 2,
        "ulhair": 2,
        "ulhwave": 2,
        "ulldash": 2,
        "ulnone": 4,
        "ulth": 2,
        "ulthd": 2,
        "ulthdash": 2,
        "ulthdashd": 2,
        "ulthdashdd": 2,
        "ulthldash": 2,
        "ululdbwave": 2,
        "ulw": 4,
        "ulwave": 2,
        "up": 3,
        "upr": 5,
        "urtf": 3,
        "useltbaln": 4,
        "usenormstyforlist": 4,
        "userprops": 5,
        "usexform": 4,
        "utinl": 4,
        "v": 2,
        "validatexml": 3,
        "vern": 3,
        "version": 3,
        "vertal": 4,
        "vertalb": 4,
        "vertalc": 4,
        "vertalj": 4,
        "vertalt": 4,
        "vertdoc": 4,
        "vertsect": 4,
        "viewbksp": 3,
        "viewkind": 3,
        "viewnobound": 4,
        "viewscale": 3,
        "viewzk": 3,
        "wbitmap": 3,
        "wbmbitspixel": 3,
        "wbmplanes": 3,
        "wbmwidthbytes": 3,
        "webhidden": 4,
        "wgrffmtfilter": 5,
        "widctlpar": 4,
        "widowctrl": 4,
        "windowcaption": 5,
        "wmetafile": 3,
        "wpeqn": 4,
        "wpjst": 4,
        "wpsp": 4,
        "wraparound": 4,
        "wrapdefault": 4,
        "wrapthrough": 4,
        "wraptight": 4,
        "wraptrsp": 4,
        "writereservation": 5,
        "writereservhash": 5,
        "wrppunct": 4,
        "xe": 5,
        "xef": 3,
        "xform": 5,
        "xmlattr": 4,
        "xmlattrname": 5,
        "xmlattrns": 3,
        "xmlattrvalue": 5,
        "xmlclose": 5,
        "xmlname": 5,
        "xmlns": 3,
        "xmlnstbl": 5,
        "xmlopen": 5,
        "xmlsdttcell": 4,
        "xmlsdttpara": 4,
        "xmlsdttregular": 4,
        "xmlsdttrow": 4,
        "xmlsdttunknown": 4,
        "yr": 3,
        "yts": 3,
        "yxe": 4,
        "zwbo": 1,
        "zwj": 1,
        "zwnbo": 1,
        "zwnj": 1
      };
    }, {}],
    55: [function (require, module, exports) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      /* eslint-disable node/no-deprecated-api */
      var buffer = require('buffer');
      var Buffer = buffer.Buffer;

      // alternative to using Object.keys for old browsers
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        // Copy properties from require('buffer')
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer.prototype);

      // Copy static methods from Buffer
      copyProps(Buffer, SafeBuffer);
      SafeBuffer.from = function (arg, encodingOrOffset, length) {
        if (typeof arg === 'number') {
          throw new TypeError('Argument must not be a number');
        }
        return Buffer(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function (size, fill, encoding) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }
        var buf = Buffer(size);
        if (fill !== undefined) {
          if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }
        return Buffer(size);
      };
      SafeBuffer.allocUnsafeSlow = function (size) {
        if (typeof size !== 'number') {
          throw new TypeError('Argument must be a number');
        }
        return buffer.SlowBuffer(size);
      };
    }, {
      "buffer": 7
    }],
    56: [function (require, module, exports) {
      (function (process) {
        (function () {
          /* eslint-disable node/no-deprecated-api */

          'use strict';

          var buffer = require('buffer');
          var Buffer = buffer.Buffer;
          var safer = {};
          var key;
          for (key in buffer) {
            if (!buffer.hasOwnProperty(key)) continue;
            if (key === 'SlowBuffer' || key === 'Buffer') continue;
            safer[key] = buffer[key];
          }
          var Safer = safer.Buffer = {};
          for (key in Buffer) {
            if (!Buffer.hasOwnProperty(key)) continue;
            if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
            Safer[key] = Buffer[key];
          }
          safer.Buffer.prototype = Buffer.prototype;
          if (!Safer.from || Safer.from === Uint8Array.from) {
            Safer.from = function (value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('The "value" argument must not be of type number. Received type ' + _typeof(value));
              }
              if (value && typeof value.length === 'undefined') {
                throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + _typeof(value));
              }
              return Buffer(value, encodingOrOffset, length);
            };
          }
          if (!Safer.alloc) {
            Safer.alloc = function (size, fill, encoding) {
              if (typeof size !== 'number') {
                throw new TypeError('The "size" argument must be of type number. Received type ' + _typeof(size));
              }
              if (size < 0 || size >= 2 * (1 << 30)) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
              var buf = Buffer(size);
              if (!fill || fill.length === 0) {
                buf.fill(0);
              } else if (typeof encoding === 'string') {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
              return buf;
            };
          }
          if (!safer.kStringMaxLength) {
            try {
              safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
            } catch (e) {
              // we can't determine kStringMaxLength in environments where process.binding
              // is unsupported, so let's not set it
            }
          }
          if (!safer.constants) {
            safer.constants = {
              MAX_LENGTH: safer.kMaxLength
            };
            if (safer.kStringMaxLength) {
              safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
            }
          }
          module.exports = safer;
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "_process": 36,
      "buffer": 7
    }],
    57: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      module.exports = Stream;
      var EE = require('events').EventEmitter;
      var inherits = require('inherits');
      inherits(Stream, EE);
      Stream.Readable = require('readable-stream/lib/_stream_readable.js');
      Stream.Writable = require('readable-stream/lib/_stream_writable.js');
      Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
      Stream.Transform = require('readable-stream/lib/_stream_transform.js');
      Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
      Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
      Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js');

      // Backwards-compat with node 0.4.x
      Stream.Stream = Stream;

      // old-style streams.  Note that the pipe method (the only relevant
      // part of this class) is overridden in the Readable class.

      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function (dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on('data', ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on('drain', ondrain);

        // If the 'end' option is not supplied, dest.end() will be called when
        // source gets the 'end' or 'close' events.  Only dest.end() once.
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on('end', onend);
          source.on('close', onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === 'function') dest.destroy();
        }

        // don't leave dangling pipes when there are errors.
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, 'error') === 0) {
            throw er; // Unhandled stream error in pipe.
          }
        }

        source.on('error', onerror);
        dest.on('error', onerror);

        // remove all the event listeners that were added.
        function cleanup() {
          source.removeListener('data', ondata);
          dest.removeListener('drain', ondrain);
          source.removeListener('end', onend);
          source.removeListener('close', onclose);
          source.removeListener('error', onerror);
          dest.removeListener('error', onerror);
          source.removeListener('end', cleanup);
          source.removeListener('close', cleanup);
          dest.removeListener('close', cleanup);
        }
        source.on('end', cleanup);
        source.on('close', cleanup);
        dest.on('close', cleanup);
        dest.emit('pipe', source);

        // Allow for unix-like usage: A.pipe(B).pipe(C)
        return dest;
      };
    }, {
      "events": 11,
      "inherits": 33,
      "readable-stream/lib/_stream_duplex.js": 59,
      "readable-stream/lib/_stream_passthrough.js": 60,
      "readable-stream/lib/_stream_readable.js": 61,
      "readable-stream/lib/_stream_transform.js": 62,
      "readable-stream/lib/_stream_writable.js": 63,
      "readable-stream/lib/internal/streams/end-of-stream.js": 67,
      "readable-stream/lib/internal/streams/pipeline.js": 69
    }],
    58: [function (require, module, exports) {
      'use strict';

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === 'string') {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(NodeError, _Base);
          function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function (i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

      function endsWith(str, search, this_len) {
        if (this_len === undefined || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

      function includes(str, search, start) {
        if (typeof start !== 'number') {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
        // determiner: 'must be' or 'must not be'
        var determiner;
        if (typeof expected === 'string' && startsWith(expected, 'not ')) {
          determiner = 'must not be';
          expected = expected.replace(/^not /, '');
        } else {
          determiner = 'must be';
        }
        var msg;
        if (endsWith(name, ' argument')) {
          // For cases like 'first argument'
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
        } else {
          var type = includes(name, '.') ? 'property' : 'argument';
          msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
        }
        msg += ". Received type ".concat(_typeof(actual));
        return msg;
      }, TypeError);
      createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
      createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
        return 'The ' + name + ' method is not implemented';
      });
      createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
      createErrorType('ERR_STREAM_DESTROYED', function (name) {
        return 'Cannot call ' + name + ' after a stream was destroyed';
      });
      createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
      createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
      createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
      createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
      createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
        return 'Unknown encoding: ' + arg;
      }, TypeError);
      createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
      module.exports.codes = codes;
    }, {}],
    59: [function (require, module, exports) {
      (function (process) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // a duplex stream is just a stream that is both readable and writable.
          // Since JS doesn't have multiple prototypal inheritance, this class
          // prototypally inherits from Readable, and then parasitically from
          // Writable.
          'use strict';

          /*<replacement>*/
          var objectKeys = Object.keys || function (obj) {
            var keys = [];
            for (var key in obj) {
              keys.push(key);
            }
            return keys;
          };
          /*</replacement>*/

          module.exports = Duplex;
          var Readable = require('./_stream_readable');
          var Writable = require('./_stream_writable');
          require('inherits')(Duplex, Readable);
          {
            // Allow the keys array to be GC'ed.
            var keys = objectKeys(Writable.prototype);
            for (var v = 0; v < keys.length; v++) {
              var method = keys[v];
              if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
            }
          }
          function Duplex(options) {
            if (!(this instanceof Duplex)) return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            this.allowHalfOpen = true;
            if (options) {
              if (options.readable === false) this.readable = false;
              if (options.writable === false) this.writable = false;
              if (options.allowHalfOpen === false) {
                this.allowHalfOpen = false;
                this.once('end', onend);
              }
            }
          }
          Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          Object.defineProperty(Duplex.prototype, 'writableBuffer', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          Object.defineProperty(Duplex.prototype, 'writableLength', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          }); // the no-half-open enforcer

          function onend() {
            // If the writable side ended, then we're ok.
            if (this._writableState.ended) return; // no more data can be written.
            // But allow more writes to happen in this tick.

            process.nextTick(onEndNT, this);
          }
          function onEndNT(self) {
            self.end();
          }
          Object.defineProperty(Duplex.prototype, 'destroyed', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === undefined || this._writableState === undefined) {
                return false;
              }
              return this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (this._readableState === undefined || this._writableState === undefined) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed

              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          });
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "./_stream_readable": 61,
      "./_stream_writable": 63,
      "_process": 36,
      "inherits": 33
    }],
    60: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      // a passthrough stream.
      // basically just the most minimal sort of Transform stream.
      // Every written chunk gets output as-is.
      'use strict';

      module.exports = PassThrough;
      var Transform = require('./_stream_transform');
      require('inherits')(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function (chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, {
      "./_stream_transform": 62,
      "inherits": 33
    }],
    61: [function (require, module, exports) {
      (function (process, global) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          'use strict';

          module.exports = Readable;
          /*<replacement>*/

          var Duplex;
          /*</replacement>*/

          Readable.ReadableState = ReadableState;
          /*<replacement>*/

          var EE = require('events').EventEmitter;
          var EElistenerCount = function EElistenerCount(emitter, type) {
            return emitter.listeners(type).length;
          };
          /*</replacement>*/

          /*<replacement>*/

          var Stream = require('./internal/streams/stream');
          /*</replacement>*/

          var Buffer = require('buffer').Buffer;
          var OurUint8Array = global.Uint8Array || function () {};
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          /*<replacement>*/

          var debugUtil = require('util');
          var debug;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog('stream');
          } else {
            debug = function debug() {};
          }
          /*</replacement>*/

          var BufferList = require('./internal/streams/buffer_list');
          var destroyImpl = require('./internal/streams/destroy');
          var _require = require('./internal/streams/state'),
            getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require('../errors').codes,
            ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
            ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
            ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
            ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.

          var StringDecoder;
          var createReadableStreamAsyncIterator;
          var from;
          require('inherits')(Readable, Stream);
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
          function prependListener(emitter, event, fn) {
            // Sadly this is not cacheable as some libraries bundle their own
            // event emitter implementation with them.
            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
            // userland ones.  NEVER DO THIS. This is here only because this code needs
            // to continue to work with older versions of Node.js that do not include
            // the prependListener() method. The goal is to eventually remove this hack.

            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream, isDuplex) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {}; // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream.
            // These options can be provided separately as readableXXX and writableXXX.

            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
            // make all the buffer merging and length checks go away

            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
            // Note: 0 is a valid value, means "don't call _read preemptively ever"

            this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
            // linked list can remove elements from the beginning faster than
            // array.shift()

            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
            // immediately, or on a later tick.  We set this to true at first, because
            // any actions that shouldn't happen until "later" should generally also
            // not happen before the first read call.

            this.sync = true; // whenever we return null, then we set a flag to say
            // that we're awaiting a 'readable' event emission.

            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.paused = true; // Should close be emitted on destroy. Defaults to true.

            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

            this.autoDestroy = !!options.autoDestroy; // has it been destroyed

            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.

            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require('./_stream_duplex');
            if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
            // the ReadableState constructor, at least with V8 6.5

            var isDuplex = this instanceof Duplex;
            this._readableState = new ReadableState(options, this, isDuplex); // legacy

            this.readable = true;
            if (options) {
              if (typeof options.read === 'function') this._read = options.read;
              if (typeof options.destroy === 'function') this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, 'destroyed', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === undefined) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._readableState) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed

              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function (err, cb) {
            cb(err);
          }; // Manually shove something into the read() buffer.
          // This returns true if the highWaterMark has not been hit yet,
          // similar to how Writable.write() returns true if you should
          // write() some more.

          Readable.prototype.push = function (chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === 'string') {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = '';
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          }; // Unshift should *always* be something directly out of read()

          Readable.prototype.unshift = function (chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            debug('readableAddChunk', chunk);
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck) er = chunkInvalid(state, chunk);
              if (er) {
                errorOrDestroy(stream, er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                } else if (state.destroyed) {
                  return false;
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
                maybeReadMore(stream, state);
              }
            } // We can push more data if we are below the highWaterMark.
            // Also, if we have no data yet, we can stand some more bytes.
            // This is to work around cases where hwm=0, such as the repl.

            return !state.ended && (state.length < state.highWaterMark || state.length === 0);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              state.awaitDrain = 0;
              stream.emit('data', chunk);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
              if (state.needReadable) emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
            }
            return er;
          }
          Readable.prototype.isPaused = function () {
            return this._readableState.flowing === false;
          }; // backwards compatibility.

          Readable.prototype.setEncoding = function (enc) {
            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
            var decoder = new StringDecoder(enc);
            this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

            this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

            var p = this._readableState.buffer.head;
            var content = '';
            while (p !== null) {
              content += decoder.write(p.data);
              p = p.next;
            }
            this._readableState.buffer.clear();
            if (content !== '') this._readableState.buffer.push(content);
            this._readableState.length = content.length;
            return this;
          }; // Don't raise the hwm > 1GB

          var MAX_HWM = 0x40000000;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
              n = MAX_HWM;
            } else {
              // Get the next highest power of 2 to prevent increasing hwm excessively in
              // tiny amounts
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          } // This function is designed to be inlinable, so please take care when making
          // changes to the function body.

          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended) return 0;
            if (state.objectMode) return 1;
            if (n !== n) {
              // Only flow one buffer at a time
              if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
            } // If we're asking for more than the current hwm, then raise the hwm.

            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length) return n; // Don't have enough

            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          } // you can override either this method, or the async _read(n) below.

          Readable.prototype.read = function (n) {
            debug('read', n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
            // already have a bunch of data in the buffer, then just trigger
            // the 'readable' event and move on.

            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
              debug('read: emitReadable', state.length, state.ended);
              if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

            if (n === 0 && state.ended) {
              if (state.length === 0) endReadable(this);
              return null;
            } // All the actual chunk generation logic needs to be
            // *below* the call to _read.  The reason is that in certain
            // synthetic stream cases, such as passthrough streams, _read
            // may be a completely synchronous operation which may change
            // the state of the read buffer, providing enough data when
            // before there was *not* enough.
            //
            // So, the steps are:
            // 1. Figure out what the state of things will be after we do
            // a read from the buffer.
            //
            // 2. If that resulting state will trigger a _read, then call _read.
            // Note that this may be asynchronous, or synchronous.  Yes, it is
            // deeply ugly to write APIs this way, but that still doesn't mean
            // that the Readable class should behave improperly, as streams are
            // designed to be sync/async agnostic.
            // Take note if the _read call is sync or async (ie, if the read call
            // has returned yet), so that we know whether or not it's safe to emit
            // 'readable' etc.
            //
            // 3. Actually pull the requested chunks out of the buffer and return.
            // if we need a readable event, then we need to do some reading.

            var doRead = state.needReadable;
            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug('length less than watermark', doRead);
            } // however, if we've ended, then there's no point, and if we're already
            // reading, then it's unnecessary.

            if (state.ended || state.reading) {
              doRead = false;
              debug('reading or ended', doRead);
            } else if (doRead) {
              debug('do read');
              state.reading = true;
              state.sync = true; // if the length is currently zero, then we *need* a readable event.

              if (state.length === 0) state.needReadable = true; // call internal read method

              this._read(state.highWaterMark);
              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
              // and we need to re-evaluate how much data we can return to the user.

              if (!state.reading) n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0) ret = fromList(n, state);else ret = null;
            if (ret === null) {
              state.needReadable = state.length <= state.highWaterMark;
              n = 0;
            } else {
              state.length -= n;
              state.awaitDrain = 0;
            }
            if (state.length === 0) {
              // If we have nothing in the buffer, then we want to know
              // as soon as we *do* get something into the buffer.
              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

              if (nOrig !== n && state.ended) endReadable(this);
            }
            if (ret !== null) this.emit('data', ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            debug('onEofChunk');
            if (state.ended) return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            if (state.sync) {
              // if we are sync, wait until next tick to emit the data.
              // Otherwise we risk emitting data in the flow()
              // the readable code triggers during a read() call
              emitReadable(stream);
            } else {
              // emit 'readable' now to make sure it gets picked up.
              state.needReadable = false;
              if (!state.emittedReadable) {
                state.emittedReadable = true;
                emitReadable_(stream);
              }
            }
          } // Don't emit readable right away in sync mode, because this can trigger
          // another read() call => stack overflow.  This way, it might trigger
          // a nextTick recursion warning, but that's not so bad.

          function emitReadable(stream) {
            var state = stream._readableState;
            debug('emitReadable', state.needReadable, state.emittedReadable);
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug('emitReadable', state.flowing);
              state.emittedReadable = true;
              process.nextTick(emitReadable_, stream);
            }
          }
          function emitReadable_(stream) {
            var state = stream._readableState;
            debug('emitReadable_', state.destroyed, state.length, state.ended);
            if (!state.destroyed && (state.length || state.ended)) {
              stream.emit('readable');
              state.emittedReadable = false;
            } // The stream needs another readable event if
            // 1. It is not flowing, as the flow mechanism will take
            //    care of it.
            // 2. It is not ended.
            // 3. It is below the highWaterMark, so we can schedule
            //    another readable later.

            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
            flow(stream);
          } // at this point, the user has presumably seen the 'readable' event,
          // and called read() to consume some data.  that may have triggered
          // in turn another _read(n) call, in which case reading = true if
          // it's in progress.
          // However, if we're not ended, or reading, and the length < hwm,
          // then go ahead and try to read some more preemptively.

          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              process.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            // Attempt to read more data if we should.
            //
            // The conditions for reading more data are (one of):
            // - Not enough data buffered (state.length < state.highWaterMark). The loop
            //   is responsible for filling the buffer with enough data if such data
            //   is available. If highWaterMark is 0 and we are not in the flowing mode
            //   we should _not_ attempt to buffer any extra data. We'll get more data
            //   when the stream consumer calls read() instead.
            // - No data in the buffer, and the stream is in flowing mode. In this mode
            //   the loop below is responsible for ensuring read() is called. Failing to
            //   call read here would abort the flow and there's no other mechanism for
            //   continuing the flow if the stream consumer has just subscribed to the
            //   'data' event.
            //
            // In addition to the above conditions to keep reading data, the following
            // conditions prevent the data from being read:
            // - The stream has ended (state.ended).
            // - There is already a pending 'read' operation (state.reading). This is a
            //   case where the the stream has called the implementation defined _read()
            //   method, but they are processing the call asynchronously and have _not_
            //   called push() with new data. In this case we skip performing more
            //   read()s. The execution ends in this method again after the _read() ends
            //   up calling push() with more data.
            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
              var len = state.length;
              debug('maybeReadMore read 0');
              stream.read(0);
              if (len === state.length)
                // didn't get any data, stop spinning.
                break;
            }
            state.readingMore = false;
          } // abstract method.  to be overridden in specific implementation classes.
          // call cb(er, data) where data is <= n in length.
          // for virtual (non-string, non-buffer) streams, "length" is somewhat
          // arbitrary, and perhaps not very meaningful.

          Readable.prototype._read = function (n) {
            errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
          };
          Readable.prototype.pipe = function (dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
            dest.on('unpipe', onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug('onunpipe');
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug('onend');
              dest.end();
            } // when the dest drains, it reduces the awaitDrain counter
            // on the source.  This would be more elegant with a .once()
            // handler in flow(), but adding and removing repeatedly is
            // too slow.

            var ondrain = pipeOnDrain(src);
            dest.on('drain', ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug('cleanup'); // cleanup event handlers once the pipe is broken

              dest.removeListener('close', onclose);
              dest.removeListener('finish', onfinish);
              dest.removeListener('drain', ondrain);
              dest.removeListener('error', onerror);
              dest.removeListener('unpipe', onunpipe);
              src.removeListener('end', onend);
              src.removeListener('end', unpipe);
              src.removeListener('data', ondata);
              cleanedUp = true; // if the reader is waiting for a drain event from this
              // specific writer, then it would cause it to never start
              // flowing again.
              // So, if this is awaiting a drain, then we just call it now.
              // If we don't know, then assume that we are waiting for one.

              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
            }
            src.on('data', ondata);
            function ondata(chunk) {
              debug('ondata');
              var ret = dest.write(chunk);
              debug('dest.write', ret);
              if (ret === false) {
                // If the user unpiped during `dest.write()`, it is possible
                // to get stuck in a permanently paused state if that write
                // also returned false.
                // => Check whether `dest` is still a piping destination.
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug('false write response, pause', state.awaitDrain);
                  state.awaitDrain++;
                }
                src.pause();
              }
            } // if the dest has an error, then stop piping into it.
            // however, don't suppress the throwing behavior for this.

            function onerror(er) {
              debug('onerror', er);
              unpipe();
              dest.removeListener('error', onerror);
              if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
            } // Make sure our error handler is attached before userland ones.

            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

            function onclose() {
              dest.removeListener('finish', onfinish);
              unpipe();
            }
            dest.once('close', onclose);
            function onfinish() {
              debug('onfinish');
              dest.removeListener('close', onclose);
              unpipe();
            }
            dest.once('finish', onfinish);
            function unpipe() {
              debug('unpipe');
              src.unpipe(dest);
            } // tell the dest that it's being piped to

            dest.emit('pipe', src); // start the flow if it hasn't been started already.

            if (!state.flowing) {
              debug('pipe resume');
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function pipeOnDrainFunctionResult() {
              var state = src._readableState;
              debug('pipeOnDrain', state.awaitDrain);
              if (state.awaitDrain) state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function (dest) {
            var state = this._readableState;
            var unpipeInfo = {
              hasUnpiped: false
            }; // if we're not piping anywhere, then do nothing.

            if (state.pipesCount === 0) return this; // just one destination.  most common case.

            if (state.pipesCount === 1) {
              // passed in one, but it's not the right one.
              if (dest && dest !== state.pipes) return this;
              if (!dest) dest = state.pipes; // got a match.

              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest) dest.emit('unpipe', this, unpipeInfo);
              return this;
            } // slow case. multiple pipe destinations.

            if (!dest) {
              // remove all.
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit('unpipe', this, {
                  hasUnpiped: false
                });
              }
              return this;
            } // try to find the right one.

            var index = indexOf(state.pipes, dest);
            if (index === -1) return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1) state.pipes = state.pipes[0];
            dest.emit('unpipe', this, unpipeInfo);
            return this;
          }; // set up data events if they are asked for
          // Ensure readable listeners eventually get something

          Readable.prototype.on = function (ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            var state = this._readableState;
            if (ev === 'data') {
              // update readableListening so that resume() may be a no-op
              // a few lines down. This is needed to support once('readable').
              state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

              if (state.flowing !== false) this.resume();
            } else if (ev === 'readable') {
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.flowing = false;
                state.emittedReadable = false;
                debug('on readable', state.length, state.reading);
                if (state.length) {
                  emitReadable(this);
                } else if (!state.reading) {
                  process.nextTick(nReadingNextTick, this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          Readable.prototype.removeListener = function (ev, fn) {
            var res = Stream.prototype.removeListener.call(this, ev, fn);
            if (ev === 'readable') {
              // We need to check if there is someone still listening to
              // readable and reset the state. However this needs to happen
              // after readable has been emitted but before I/O (nextTick) to
              // support once('readable', fn) cycles. This means that calling
              // resume within the same tick will have no
              // effect.
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          Readable.prototype.removeAllListeners = function (ev) {
            var res = Stream.prototype.removeAllListeners.apply(this, arguments);
            if (ev === 'readable' || ev === undefined) {
              // We need to check if there is someone still listening to
              // readable and reset the state. However this needs to happen
              // after readable has been emitted but before I/O (nextTick) to
              // support once('readable', fn) cycles. This means that calling
              // resume within the same tick will have no
              // effect.
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          function updateReadableListening(self) {
            var state = self._readableState;
            state.readableListening = self.listenerCount('readable') > 0;
            if (state.resumeScheduled && !state.paused) {
              // flowing needs to be set to true now, otherwise
              // the upcoming resume will not flow.
              state.flowing = true; // crude way to check if we should resume
            } else if (self.listenerCount('data') > 0) {
              self.resume();
            }
          }
          function nReadingNextTick(self) {
            debug('readable nexttick read 0');
            self.read(0);
          } // pause() and resume() are remnants of the legacy readable stream API
          // If the user uses them, then switch into old mode.

          Readable.prototype.resume = function () {
            var state = this._readableState;
            if (!state.flowing) {
              debug('resume'); // we flow only if there is no one listening
              // for readable, but we still have to call
              // resume()

              state.flowing = !state.readableListening;
              resume(this, state);
            }
            state.paused = false;
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              process.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            debug('resume', state.reading);
            if (!state.reading) {
              stream.read(0);
            }
            state.resumeScheduled = false;
            stream.emit('resume');
            flow(stream);
            if (state.flowing && !state.reading) stream.read(0);
          }
          Readable.prototype.pause = function () {
            debug('call pause flowing=%j', this._readableState.flowing);
            if (this._readableState.flowing !== false) {
              debug('pause');
              this._readableState.flowing = false;
              this.emit('pause');
            }
            this._readableState.paused = true;
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug('flow', state.flowing);
            while (state.flowing && stream.read() !== null) {
              ;
            }
          } // wrap an old-style stream as the async data source.
          // This is *not* part of the readable stream interface.
          // It is an ugly unfortunate mess of history.

          Readable.prototype.wrap = function (stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on('end', function () {
              debug('wrapped end');
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on('data', function (chunk) {
              debug('wrapped data');
              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

              if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            }); // proxy all the other methods.
            // important when wrapping filters and duplexes.

            for (var i in stream) {
              if (this[i] === undefined && typeof stream[i] === 'function') {
                this[i] = function methodWrap(method) {
                  return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            } // proxy certain important events.

            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            } // when we try to consume some more bytes, simply unpause the
            // underlying stream.

            this._read = function (n) {
              debug('wrapped _read', n);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          if (typeof Symbol === 'function') {
            Readable.prototype[Symbol.asyncIterator] = function () {
              if (createReadableStreamAsyncIterator === undefined) {
                createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
              }
              return createReadableStreamAsyncIterator(this);
            };
          }
          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          });
          Object.defineProperty(Readable.prototype, 'readableBuffer', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState && this._readableState.buffer;
            }
          });
          Object.defineProperty(Readable.prototype, 'readableFlowing', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.flowing;
            },
            set: function set(state) {
              if (this._readableState) {
                this._readableState.flowing = state;
              }
            }
          }); // exposed for testing purposes only.

          Readable._fromList = fromList;
          Object.defineProperty(Readable.prototype, 'readableLength', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.length;
            }
          }); // Pluck off n bytes from an array of buffers.
          // Length is the combined lengths of all the buffers in the list.
          // This function is designed to be inlinable, so please take care when making
          // changes to the function body.

          function fromList(n, state) {
            // nothing buffered
            if (state.length === 0) return null;
            var ret;
            if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
              // read it all, truncate the list
              if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              // read part of list
              ret = state.buffer.consume(n, state.decoder);
            }
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            debug('endReadable', state.endEmitted);
            if (!state.endEmitted) {
              state.ended = true;
              process.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit('end');
              if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the writable side is ready for autoDestroy as well
                var wState = stream._writableState;
                if (!wState || wState.autoDestroy && wState.finished) {
                  stream.destroy();
                }
              }
            }
          }
          if (typeof Symbol === 'function') {
            Readable.from = function (iterable, opts) {
              if (from === undefined) {
                from = require('./internal/streams/from');
              }
              return from(Readable, iterable, opts);
            };
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x) return i;
            }
            return -1;
          }
        }).call(this);
      }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "../errors": 58,
      "./_stream_duplex": 59,
      "./internal/streams/async_iterator": 64,
      "./internal/streams/buffer_list": 65,
      "./internal/streams/destroy": 66,
      "./internal/streams/from": 68,
      "./internal/streams/state": 70,
      "./internal/streams/stream": 71,
      "_process": 36,
      "buffer": 7,
      "events": 11,
      "inherits": 33,
      "string_decoder/": 72,
      "util": 5
    }],
    62: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.
      // a transform stream is a readable/writable stream where you do
      // something with the data.  Sometimes it's called a "filter",
      // but that's not a great name for it, since that implies a thing where
      // some bits pass through, and others are simply ignored.  (That would
      // be a valid example of a transform, of course.)
      //
      // While the output is causally related to the input, it's not a
      // necessarily symmetric or synchronous transformation.  For example,
      // a zlib stream might take multiple plain-text writes(), and then
      // emit a single compressed chunk some time in the future.
      //
      // Here's how this works:
      //
      // The Transform stream has all the aspects of the readable and writable
      // stream classes.  When you write(chunk), that calls _write(chunk,cb)
      // internally, and returns false if there's a lot of pending writes
      // buffered up.  When you call read(), that calls _read(n) until
      // there's enough pending readable data buffered up.
      //
      // In a transform stream, the written data is placed in a buffer.  When
      // _read(n) is called, it transforms the queued up data, calling the
      // buffered _write cb's as it consumes chunks.  If consuming a single
      // written chunk would result in multiple output chunks, then the first
      // outputted bit calls the readcb, and subsequent chunks just go into
      // the read buffer, and will cause it to emit 'readable' if necessary.
      //
      // This way, back-pressure is actually determined by the reading side,
      // since _read has to be called to start processing a new chunk.  However,
      // a pathological inflate type of transform can cause excessive buffering
      // here.  For example, imagine a stream where every byte of input is
      // interpreted as an integer from 0-255, and then results in that many
      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
      // 1kb of data being output.  In this case, you could write a very small
      // amount of input, and end up with a very large amount of output.  In
      // such a pathological inflating mechanism, there'd be no way to tell
      // the system to stop doing the transform.  A single 4MB write could
      // cause the system to run out of memory.
      //
      // However, even in such a pathological case, only a single written chunk
      // would be consumed, and then the rest would wait (un-transformed) until
      // the results of the previous transformed chunk were consumed.
      'use strict';

      module.exports = Transform;
      var _require$codes = require('../errors').codes,
        ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
        ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
        ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require('./_stream_duplex');
      require('inherits')(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit('error', new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          // single equals check for both `null` and `undefined`
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }; // start out asking for a readable event once data is transformed.

        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.

        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === 'function') this._transform = options.transform;
          if (typeof options.flush === 'function') this._flush = options.flush;
        } // When the writable side finishes, then flush out anything remaining.

        this.on('prefinish', prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === 'function' && !this._readableState.destroyed) {
          this._flush(function (er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function (chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      }; // This is the part where you do stuff!
      // override this function in implementation classes.
      // 'chunk' is an input chunk.
      //
      // Call `push(newChunk)` to pass along transformed output
      // to the readable side.  You may call 'push' zero or more times.
      //
      // Call `cb(err)` when you are done with this chunk.  If you pass
      // an error, then that'll put the hurt on the whole operation.  If you
      // never call cb(), then you'll never get another chunk.

      Transform.prototype._transform = function (chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
      };
      Transform.prototype._write = function (chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      }; // Doesn't matter what the args are here.
      // _transform does all the work.
      // That we got here means that the readable side wants more data.

      Transform.prototype._read = function (n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          // mark that we need a transform, so that any data that comes in
          // will get processed, now that we've asked for it.
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function (err, cb) {
        Duplex.prototype._destroy.call(this, err, function (err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er) return stream.emit('error', er);
        if (data != null)
          // single equals check for both `null` and `undefined`
          stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
        // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided

        if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }, {
      "../errors": 58,
      "./_stream_duplex": 59,
      "inherits": 33
    }],
    63: [function (require, module, exports) {
      (function (process, global) {
        (function () {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // A bit simpler than readable streams.
          // Implement an async ._write(chunk, encoding, cb), and it'll handle all
          // the drain event emission and buffering.
          'use strict';

          module.exports = Writable;
          /* <replacement> */

          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          } // It seems a linked list but it is not
          // there will be only 2 of these for each stream

          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function () {
              onCorkedFinish(_this, state);
            };
          }
          /* </replacement> */

          /*<replacement>*/

          var Duplex;
          /*</replacement>*/

          Writable.WritableState = WritableState;
          /*<replacement>*/

          var internalUtil = {
            deprecate: require('util-deprecate')
          };
          /*</replacement>*/

          /*<replacement>*/

          var Stream = require('./internal/streams/stream');
          /*</replacement>*/

          var Buffer = require('buffer').Buffer;
          var OurUint8Array = global.Uint8Array || function () {};
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require('./internal/streams/destroy');
          var _require = require('./internal/streams/state'),
            getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require('../errors').codes,
            ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
            ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
            ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
            ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
            ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
            ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
            ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
            ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          require('inherits')(Writable, Stream);
          function nop() {}
          function WritableState(options, stream, isDuplex) {
            Duplex = Duplex || require('./_stream_duplex');
            options = options || {}; // Duplex streams are both readable and writable, but share
            // the same options object.
            // However, some cases require setting options to different
            // values for the readable and the writable sides of the duplex stream,
            // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
            // contains buffers or objects.

            this.objectMode = !!options.objectMode;
            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
            // Note: 0 is a valid value, means that we always return false if
            // the entire buffer is not flushed immediately on write()

            this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

            this.finalCalled = false; // drain event flag.

            this.needDrain = false; // at the start of calling end()

            this.ending = false; // when end() has been called, and returned

            this.ended = false; // when 'finish' is emitted

            this.finished = false; // has it been destroyed

            this.destroyed = false; // should we decode strings into buffers before passing to _write?
            // this is here so that some node-core streams can optimize string
            // handling at a lower level.

            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
            // encoding is 'binary' so we have to make this configurable.
            // Everything else in the universe uses 'utf8', though.

            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
            // of how much we're waiting to get pushed to some underlying
            // socket or file.

            this.length = 0; // a flag to see when we're in the middle of a write.

            this.writing = false; // when true all writes will be buffered until .uncork() call

            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
            // or on a later tick.  We set this to true at first, because any
            // actions that shouldn't happen until "later" should generally also
            // not happen before the first write call.

            this.sync = true; // a flag to know if we're processing previously buffered items, which
            // may call the _write() callback in the same tick, so that we don't
            // end up in an overlapped onwrite situation.

            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

            this.onwrite = function (er) {
              onwrite(stream, er);
            }; // the callback that the user supplies to write(chunk,encoding,cb)

            this.writecb = null; // the amount that is being written when _write is called.

            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
            // this must be 0 before 'finish' can be emitted

            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
            // This is relevant for synchronous Transform streams

            this.prefinished = false; // True if the error was already emitted and should not be thrown again

            this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

            this.autoDestroy = !!options.autoDestroy; // count buffered requests

            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
            // one allocated and free to use, and we maintain at most two

            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function () {
            try {
              Object.defineProperty(WritableState.prototype, 'buffer', {
                get: internalUtil.deprecate(function writableStateBufferGetter() {
                  return this.getBuffer();
                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
              });
            } catch (_) {}
          })(); // Test _writableState for inheritance to account for Duplex streams,
          // whose prototype chain only points to Readable.

          var realHasInstance;
          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function value(object) {
                if (realHasInstance.call(this, object)) return true;
                if (this !== Writable) return false;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function realHasInstance(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
            // `realHasInstance` is necessary because using plain `instanceof`
            // would return false, as no `_writableState` property is attached.
            // Trying to use the custom `instanceof` for Writable here will also break the
            // Node.js LazyTransform implementation, which has a non-trivial getter for
            // `_writableState` that would lead to infinite recursion.
            // Checking for a Stream.Duplex instance is faster here instead of inside
            // the WritableState constructor, at least with V8 6.5

            var isDuplex = this instanceof Duplex;
            if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
            this._writableState = new WritableState(options, this, isDuplex); // legacy.

            this.writable = true;
            if (options) {
              if (typeof options.write === 'function') this._write = options.write;
              if (typeof options.writev === 'function') this._writev = options.writev;
              if (typeof options.destroy === 'function') this._destroy = options.destroy;
              if (typeof options.final === 'function') this._final = options.final;
            }
            Stream.call(this);
          } // Otherwise people can pipe Writable streams, which is just wrong.

          Writable.prototype.pipe = function () {
            errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
          };
          function writeAfterEnd(stream, cb) {
            var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

            errorOrDestroy(stream, er);
            process.nextTick(cb, er);
          } // Checks that a user-supplied chunk is valid, especially for the particular
          // mode the stream is in. Currently this means that `null` is never accepted
          // and undefined/non-string values are only allowed in object mode.

          function validChunk(stream, state, chunk, cb) {
            var er;
            if (chunk === null) {
              er = new ERR_STREAM_NULL_VALUES();
            } else if (typeof chunk !== 'string' && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
            }
            if (er) {
              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
              return false;
            }
            return true;
          }
          Writable.prototype.write = function (chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
            if (typeof cb !== 'function') cb = nop;
            if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function () {
            this._writableState.corked++;
          };
          Writable.prototype.uncork = function () {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            // node::ParseEncoding() requires lower case.
            if (typeof encoding === 'string') encoding = encoding.toLowerCase();
            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          Object.defineProperty(Writable.prototype, 'writableBuffer', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          }); // if we're already writing something, then just put this
          // in the queue, and wait our turn.  Otherwise, call _write
          // If we return false, then we need a drain event, so set that flag.

          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = 'buffer';
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

            if (!ret) state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk: chunk,
                encoding: encoding,
                isBuf: isBuf,
                callback: cb,
                next: null
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              // defer the callback if we are being called synchronously
              // to avoid piling up things on the stack
              process.nextTick(cb, er); // this can emit finish, and it will always happen
              // after error

              process.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er);
            } else {
              // the caller expect this to happen before if
              // it is async
              cb(er);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er); // this can emit finish, but finish must
              // always follow error

              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
            onwriteStateUpdate(state);
            if (er) onwriteError(stream, state, sync, er, cb);else {
              // Check if we're actually ready to finish, but don't emit yet
              var finished = needFinish(state) || stream.destroyed;
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                process.nextTick(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          } // Must force callback to be called on nextTick, so that we don't
          // emit 'drain' before the write() consumer gets the 'false' return
          // value, and has a chance to attach a 'drain' listener.

          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit('drain');
            }
          } // if there's something in the buffer waiting, then process it

          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              // Fast case, write everything using _writev()
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf) allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
              // as the hot path ends with doWrite

              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              // Slow case, write chunks one-by-one
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
                // it means that we need to wait until it does.
                // also, that means that the chunk and cb are currently
                // being processed, so move the buffer counter past them.

                if (state.writing) {
                  break;
                }
              }
              if (entry === null) state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function (chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function (chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === 'function') {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === 'function') {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

            if (state.corked) {
              state.corked = 1;
              this.uncork();
            } // ignore unnecessary end() calls.

            if (!state.ending) endWritable(this, state, cb);
            return this;
          };
          Object.defineProperty(Writable.prototype, 'writableLength', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function (err) {
              state.pendingcb--;
              if (err) {
                errorOrDestroy(stream, err);
              }
              state.prefinished = true;
              stream.emit('prefinish');
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === 'function' && !state.destroyed) {
                state.pendingcb++;
                state.finalCalled = true;
                process.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit('prefinish');
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit('finish');
                if (state.autoDestroy) {
                  // In case of duplex streams we need a way to detect
                  // if the readable side is ready for autoDestroy as well
                  var rState = stream._readableState;
                  if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                  }
                }
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            } // reuse the free corkReq.

            state.corkedRequestsFree.next = corkReq;
          }
          Object.defineProperty(Writable.prototype, 'destroyed', {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._writableState === undefined) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function set(value) {
              // we ignore the value if the stream
              // has not been initialized yet
              if (!this._writableState) {
                return;
              } // backward compatibility, the user is explicitly
              // managing destroyed

              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function (err, cb) {
            cb(err);
          };
        }).call(this);
      }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "../errors": 58,
      "./_stream_duplex": 59,
      "./internal/streams/destroy": 66,
      "./internal/streams/state": 70,
      "./internal/streams/stream": 71,
      "_process": 36,
      "buffer": 7,
      "inherits": 33,
      "util-deprecate": 73
    }],
    64: [function (require, module, exports) {
      (function (process) {
        (function () {
          'use strict';

          var _Object$setPrototypeO;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var finished = require('./end-of-stream');
          var kLastResolve = Symbol('lastResolve');
          var kLastReject = Symbol('lastReject');
          var kError = Symbol('error');
          var kEnded = Symbol('ended');
          var kLastPromise = Symbol('lastPromise');
          var kHandlePromise = Symbol('handlePromise');
          var kStream = Symbol('stream');
          function createIterResult(value, done) {
            return {
              value: value,
              done: done
            };
          }
          function readAndResolve(iter) {
            var resolve = iter[kLastResolve];
            if (resolve !== null) {
              var data = iter[kStream].read(); // we defer if data is null
              // we can be expecting either 'end' or
              // 'error'

              if (data !== null) {
                iter[kLastPromise] = null;
                iter[kLastResolve] = null;
                iter[kLastReject] = null;
                resolve(createIterResult(data, false));
              }
            }
          }
          function onReadable(iter) {
            // we wait for the next tick, because it might
            // emit an error with process.nextTick
            process.nextTick(readAndResolve, iter);
          }
          function wrapForNext(lastPromise, iter) {
            return function (resolve, reject) {
              lastPromise.then(function () {
                if (iter[kEnded]) {
                  resolve(createIterResult(undefined, true));
                  return;
                }
                iter[kHandlePromise](resolve, reject);
              }, reject);
            };
          }
          var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
            get stream() {
              return this[kStream];
            },
            next: function next() {
              var _this = this;

              // if we have detected an error in the meanwhile
              // reject straight away
              var error = this[kError];
              if (error !== null) {
                return Promise.reject(error);
              }
              if (this[kEnded]) {
                return Promise.resolve(createIterResult(undefined, true));
              }
              if (this[kStream].destroyed) {
                // We need to defer via nextTick because if .destroy(err) is
                // called, the error will be emitted via nextTick, and
                // we cannot guarantee that there is no error lingering around
                // waiting to be emitted.
                return new Promise(function (resolve, reject) {
                  process.nextTick(function () {
                    if (_this[kError]) {
                      reject(_this[kError]);
                    } else {
                      resolve(createIterResult(undefined, true));
                    }
                  });
                });
              } // if we have multiple next() calls
              // we will wait for the previous Promise to finish
              // this logic is optimized to support for await loops,
              // where next() is only called once at a time

              var lastPromise = this[kLastPromise];
              var promise;
              if (lastPromise) {
                promise = new Promise(wrapForNext(lastPromise, this));
              } else {
                // fast path needed to support multiple this.push()
                // without triggering the next() queue
                var data = this[kStream].read();
                if (data !== null) {
                  return Promise.resolve(createIterResult(data, false));
                }
                promise = new Promise(this[kHandlePromise]);
              }
              this[kLastPromise] = promise;
              return promise;
            }
          }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
            return this;
          }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
            var _this2 = this;

            // destroy(err, cb) is a private API
            // we can guarantee we have that here, because we control the
            // Readable class this is attached to
            return new Promise(function (resolve, reject) {
              _this2[kStream].destroy(null, function (err) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve(createIterResult(undefined, true));
              });
            });
          }), _Object$setPrototypeO), AsyncIteratorPrototype);
          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
            var _Object$create;
            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
              value: stream,
              writable: true
            }), _defineProperty(_Object$create, kLastResolve, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kLastReject, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kError, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kEnded, {
              value: stream._readableState.endEmitted,
              writable: true
            }), _defineProperty(_Object$create, kHandlePromise, {
              value: function value(resolve, reject) {
                var data = iterator[kStream].read();
                if (data) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(data, false));
                } else {
                  iterator[kLastResolve] = resolve;
                  iterator[kLastReject] = reject;
                }
              },
              writable: true
            }), _Object$create));
            iterator[kLastPromise] = null;
            finished(stream, function (err) {
              if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
                var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
                // returned by next() and store the error

                if (reject !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  reject(err);
                }
                iterator[kError] = err;
                return;
              }
              var resolve = iterator[kLastResolve];
              if (resolve !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(undefined, true));
              }
              iterator[kEnded] = true;
            });
            stream.on('readable', onReadable.bind(null, iterator));
            return iterator;
          };
          module.exports = createReadableStreamAsyncIterator;
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "./end-of-stream": 67,
      "_process": 36
    }],
    65: [function (require, module, exports) {
      'use strict';

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require('buffer'),
        Buffer = _require.Buffer;
      var _require2 = require('util'),
        inspect = _require2.inspect;
      var custom = inspect && inspect.custom || 'inspect';
      function copyBuffer(src, target, offset) {
        Buffer.prototype.copy.call(src, target, offset);
      }
      module.exports = /*#__PURE__*/
      function () {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0) this.tail.next = entry;else this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0) return '';
            var p = this.head;
            var ret = '' + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0) return Buffer.alloc(0);
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          } // Consumes a specified amount of bytes or characters from the buffered data.
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              // `slice` is the same for buffers and strings.
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              // First chunk is a perfect match.
              ret = this.shift();
            } else {
              // Result spans more than one buffer.
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          } // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next;else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          } // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next;else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          } // Make sure the linked list only shows the minimal necessary information.
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }, {
      "buffer": 7,
      "util": 5
    }],
    66: [function (require, module, exports) {
      (function (process) {
        (function () {
          'use strict';

          // undocumented cb() API, needed for core, not for public API
          function destroy(err, cb) {
            var _this = this;
            var readableDestroyed = this._readableState && this._readableState.destroyed;
            var writableDestroyed = this._writableState && this._writableState.destroyed;
            if (readableDestroyed || writableDestroyed) {
              if (cb) {
                cb(err);
              } else if (err) {
                if (!this._writableState) {
                  process.nextTick(emitErrorNT, this, err);
                } else if (!this._writableState.errorEmitted) {
                  this._writableState.errorEmitted = true;
                  process.nextTick(emitErrorNT, this, err);
                }
              }
              return this;
            } // we set destroyed to true before firing error callbacks in order
            // to make it re-entrance safe in case destroy() is called within callbacks

            if (this._readableState) {
              this._readableState.destroyed = true;
            } // if this is a duplex stream mark the writable part as destroyed as well

            if (this._writableState) {
              this._writableState.destroyed = true;
            }
            this._destroy(err || null, function (err) {
              if (!cb && err) {
                if (!_this._writableState) {
                  process.nextTick(emitErrorAndCloseNT, _this, err);
                } else if (!_this._writableState.errorEmitted) {
                  _this._writableState.errorEmitted = true;
                  process.nextTick(emitErrorAndCloseNT, _this, err);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              } else if (cb) {
                process.nextTick(emitCloseNT, _this);
                cb(err);
              } else {
                process.nextTick(emitCloseNT, _this);
              }
            });
            return this;
          }
          function emitErrorAndCloseNT(self, err) {
            emitErrorNT(self, err);
            emitCloseNT(self);
          }
          function emitCloseNT(self) {
            if (self._writableState && !self._writableState.emitClose) return;
            if (self._readableState && !self._readableState.emitClose) return;
            self.emit('close');
          }
          function undestroy() {
            if (this._readableState) {
              this._readableState.destroyed = false;
              this._readableState.reading = false;
              this._readableState.ended = false;
              this._readableState.endEmitted = false;
            }
            if (this._writableState) {
              this._writableState.destroyed = false;
              this._writableState.ended = false;
              this._writableState.ending = false;
              this._writableState.finalCalled = false;
              this._writableState.prefinished = false;
              this._writableState.finished = false;
              this._writableState.errorEmitted = false;
            }
          }
          function emitErrorNT(self, err) {
            self.emit('error', err);
          }
          function errorOrDestroy(stream, err) {
            // We have tests that rely on errors being emitted
            // in the same tick, so changing this is semver major.
            // For now when you opt-in to autoDestroy we allow
            // the error to be emitted nextTick. In a future
            // semver major update we should change the default to this.
            var rState = stream._readableState;
            var wState = stream._writableState;
            if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
          }
          module.exports = {
            destroy: destroy,
            undestroy: undestroy,
            errorOrDestroy: errorOrDestroy
          };
        }).call(this);
      }).call(this, require('_process'));
    }, {
      "_process": 36
    }],
    67: [function (require, module, exports) {
      // Ported from https://github.com/mafintosh/end-of-stream with
      // permission from the author, Mathias Buus (@mafintosh).
      'use strict';

      var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function () {
          if (called) return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {}
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === 'function';
      }
      function eos(stream, opts, callback) {
        if (typeof opts === 'function') return eos(stream, null, opts);
        if (!opts) opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish() {
          if (!stream.writable) onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish() {
          writable = false;
          writableEnded = true;
          if (!readable) callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend() {
          readable = false;
          readableEnded = true;
          if (!writable) callback.call(stream);
        };
        var onerror = function onerror(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest() {
          stream.req.on('finish', onfinish);
        };
        if (isRequest(stream)) {
          stream.on('complete', onfinish);
          stream.on('abort', onclose);
          if (stream.req) onrequest();else stream.on('request', onrequest);
        } else if (writable && !stream._writableState) {
          // legacy streams
          stream.on('end', onlegacyfinish);
          stream.on('close', onlegacyfinish);
        }
        stream.on('end', onend);
        stream.on('finish', onfinish);
        if (opts.error !== false) stream.on('error', onerror);
        stream.on('close', onclose);
        return function () {
          stream.removeListener('complete', onfinish);
          stream.removeListener('abort', onclose);
          stream.removeListener('request', onrequest);
          if (stream.req) stream.req.removeListener('finish', onfinish);
          stream.removeListener('end', onlegacyfinish);
          stream.removeListener('close', onlegacyfinish);
          stream.removeListener('finish', onfinish);
          stream.removeListener('end', onend);
          stream.removeListener('error', onerror);
          stream.removeListener('close', onclose);
        };
      }
      module.exports = eos;
    }, {
      "../../../errors": 58
    }],
    68: [function (require, module, exports) {
      module.exports = function () {
        throw new Error('Readable.from is not available in the browser');
      };
    }, {}],
    69: [function (require, module, exports) {
      // Ported from https://github.com/mafintosh/pump with
      // permission from the author, Mathias Buus (@mafintosh).
      'use strict';

      var eos;
      function once(callback) {
        var called = false;
        return function () {
          if (called) return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require('../../../errors').codes,
        ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        // Rethrow the error if it exists to avoid swallowing it
        if (err) throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === 'function';
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on('close', function () {
          closed = true;
        });
        if (eos === undefined) eos = require('./end-of-stream');
        eos(stream, {
          readable: reading,
          writable: writing
        }, function (err) {
          if (err) return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function (err) {
          if (closed) return;
          if (destroyed) return;
          destroyed = true; // request.destroy just do .end - .abort is what we want

          if (isRequest(stream)) return stream.abort();
          if (typeof stream.destroy === 'function') return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED('pipe'));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length) return noop;
        if (typeof streams[streams.length - 1] !== 'function') return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0])) streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS('streams');
        }
        var error;
        var destroys = streams.map(function (stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function (err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }, {
      "../../../errors": 58,
      "./end-of-stream": 67
    }],
    70: [function (require, module, exports) {
      'use strict';

      var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : 'highWaterMark';
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        } // Default value

        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark: getHighWaterMark
      };
    }, {
      "../../../errors": 58
    }],
    71: [function (require, module, exports) {
      module.exports = require('events').EventEmitter;
    }, {
      "events": 11
    }],
    72: [function (require, module, exports) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      'use strict';

      /*<replacement>*/
      var Buffer = require('safe-buffer').Buffer;
      /*</replacement>*/

      var isEncoding = Buffer.isEncoding || function (encoding) {
        encoding = '' + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc) return 'utf8';
        var retried;
        while (true) {
          switch (enc) {
            case 'utf8':
            case 'utf-8':
              return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 'utf16le';
            case 'latin1':
            case 'binary':
              return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
              return enc;
            default:
              if (retried) return; // undefined
              enc = ('' + enc).toLowerCase();
              retried = true;
          }
        }
      }
      ;

      // Do not cache `Buffer.isEncoding` when checking encoding names as some
      // modules monkey-patch it to support additional encodings
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
        return nenc || enc;
      }

      // StringDecoder provides an interface for efficiently splitting a series of
      // buffers into a series of JS strings without breaking apart multi-byte
      // characters.
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function (buf) {
        if (buf.length === 0) return '';
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === undefined) return '';
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || '';
      };
      StringDecoder.prototype.end = utf8End;

      // Returns only complete characters in a Buffer
      StringDecoder.prototype.text = utf8Text;

      // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
      StringDecoder.prototype.fillLast = function (buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };

      // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
      // continuation byte. If an invalid byte is detected, -2 is returned.
      function utf8CheckByte(byte) {
        if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
        return byte >> 6 === 0x02 ? -1 : -2;
      }

      // Checks at most 3 bytes at the end of a Buffer in order to detect an
      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
      // needed to complete the UTF-8 character (if applicable) are returned.
      function utf8CheckIncomplete(self, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }

      // Validates as many continuation bytes for a multi-byte UTF-8 character as
      // needed or are available. If we see a non-continuation byte where we expect
      // one, we "replace" the validated continuation bytes we've seen so far with
      // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
      // behavior. The continuation byte check is included three times in the case
      // where all of the continuation bytes for a character exist in the same buffer.
      // It is also done this way as a slight performance increase instead of using a
      // loop.
      function utf8CheckExtraBytes(self, buf, p) {
        if ((buf[0] & 0xC0) !== 0x80) {
          self.lastNeed = 0;
          return "\uFFFD";
        }
        if (self.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "\uFFFD";
          }
          if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
              self.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }

      // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== undefined) return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }

      // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
      // partial character, the character's bytes are buffered until the required
      // number of bytes are available.
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString('utf8', i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString('utf8', i, end);
      }

      // For UTF-8, a replacement character is added when ending on a partial
      // character.
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + "\uFFFD";
        return r;
      }

      // UTF-16LE typically needs two bytes per character, but even if we have an even
      // number of bytes available, we need to check if we end on a leading/high
      // surrogate. In that case, we need to wait for the next two bytes in order to
      // decode the last character properly.
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString('utf16le', i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString('utf16le', i, buf.length - 1);
      }

      // For UTF-16LE we do not explicitly append special replacement characters if we
      // end on a partial character, we simply let v8 handle that.
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString('utf16le', 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString('base64', i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString('base64', i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : '';
        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
        return r;
      }

      // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : '';
      }
    }, {
      "safe-buffer": 55
    }],
    73: [function (require, module, exports) {
      (function (global) {
        (function () {
          /**
           * Module exports.
           */

          module.exports = deprecate;

          /**
           * Mark that a method should not be used.
           * Returns a modified function which warns once by default.
           *
           * If `localStorage.noDeprecation = true` is set, then it is a no-op.
           *
           * If `localStorage.throwDeprecation = true` is set, then deprecated functions
           * will throw an Error when invoked.
           *
           * If `localStorage.traceDeprecation = true` is set, then deprecated functions
           * will invoke `console.trace()` instead of `console.error()`.
           *
           * @param {Function} fn - the function to deprecate
           * @param {String} msg - the string to print to the console when `fn` is invoked
           * @returns {Function} a new "deprecated" version of `fn`
           * @api public
           */

          function deprecate(fn, msg) {
            if (config('noDeprecation')) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config('throwDeprecation')) {
                  throw new Error(msg);
                } else if (config('traceDeprecation')) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          }

          /**
           * Checks `localStorage` for boolean values for the given `name`.
           *
           * @param {String} name
           * @returns {Boolean}
           * @api private
           */

          function config(name) {
            // accessing global.localStorage can trigger a DOMException in sandboxed iframes
            try {
              if (!global.localStorage) return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return String(val).toLowerCase() === 'true';
          }
        }).call(this);
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}]
  }, {}, [1])(1);
});
